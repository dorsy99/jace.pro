---
title: "Connect workflow to events on other tables using a custom column and the Observer Design Pattern"
date: 2015-11-23T08:01:08.000Z
authors: ["treycarroll"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=c1bd2aa9dbd0dbc01dcaf3231f9619fa"
---
<p>Design patterns are a way of "templatizing" solutions to recurring problems.   Before we talk about things in technical terms, I'd like to tell you a little story.</p><p></p><p>Once upon a time...   Mom got Johnny up for school.   She carefully looked over his things.   Lunch?   Check.   Homework?   Check.   Cell phone?   Check.   As she put him on the bus, she called over his shoulder, "Don't forget to call me at lunch to tell me if you make it to the finals in the spelling bee.   That way I can arrange to pick you up after your practice."</p><p></p><p>This little "parable" illustrates what happens in our code when we instantiate an object dependency.   The items in Johnny's backpack represent constructor parameters, things our object will need to get its work done.   But that cell phone represents a special tool. Just like Mom needed Johnny to tell her about a particular turn of events so that she could respond appropriately, our classes often have similar behavioral inter-dependencies.   Specifically, it is common for one object to need to know if something changes inside another object.   In fact, there is often a list of objects that need to know about such changes, so that they can perform some corresponding operation.</p><p></p><p>In design pattern lingo, we call this situation the "Observer" pattern.   The ever-so-interesting-to-other-objects object is called the "subject".     The dependent objects that react to signals from the subject are called observers.   Since there can be many observers of a single subject, the relationship is one to many.</p><p></p><p><img class="jive-image" src="http://www.people.westminstercollege.edu/faculty/ggagne/may2012/lab2/observer.jpg"/></p><p>Take a look at these two example classes that implement a variant of the Observer pattern:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14482897236773505 jive_text_macro" data-renderedposition="601.6334838867188_7.997159004211426_1078_433" jivemacro_uid="_14482897236773505"><p>var u_Subject = Class.create();</p><p>u_Subject.prototype = {</p><p></p><p>   initialize: function() {</p><p>   },</p><p></p><p>   observers: [],</p><p></p><p>   register: function(observer){</p><p>         this.observers.push(observer);</p><p>   },</p><p></p><p>   doWork: function(){</p><p>         if(Math.floor(Math.random()*10) % 2 == 0){</p><p>               this._notify('Even');</p><p>         }else{</p><p>               this._notify('Odd');</p><p>         }</p><p>   },</p><p></p><p>   _notify: function(msg){</p><p>         for (var i=0; i&lt; this.observers.length; i++) {</p><p>               this.observers[i].getMessage(msg);</p><p>         }</p><p>   },</p><p></p><p>   type: 'u_Subject'</p><p>}</p></pre><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_1448290288497523 jive_macro_code jive_text_macro" data-renderedposition="1054.3607177734375_7.997159004211426_1078_247" jivemacro_uid="_1448290288497523"><p>var u_Observer = Class.create();</p><p>u_Observer.prototype = {</p><p>       </p><p>   initialize: function(subject, name) {</p><p>       subject.register(this);</p><p>       this.name = name;</p><p>   },</p><p></p><p>   getMessage: function(message){</p><p>         gs.print('Observer ' + this.name + ' printing message from subject:' + message );</p><p>   },</p><p></p><p>       name:'',</p><p></p><p>       type: 'u_Observer'</p><p>}</p></pre><p></p><p>Now from a background script we could do this:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14482903953015259 jive_text_macro" data-renderedposition="1361.6334228515625_7.997159004211426_1078_93" jivemacro_uid="_14482903953015259"><p>var sub = new u_Subject(); </p><p>var obj1 = new u_Observer(sub, 'Observer1'); </p><p>var obj2 = new u_Observer(sub, 'Observer2'); </p><p>var obj3 = new u_Observer(sub, 'Observer3'); </p><p>sub.doWork(); </p><p>sub.doWork();</p></pre><p></p><p>Output for a sample run:</p><p><img   class="image-2 jive-image" src="42a5c08adb581304b322f4621f9619c9.iix" style="max-width: 1200px; max-height: 900px;"/></p><p></p><p>Notice that something that is happening in a single subject object is sending the same message to (and triggering a print call in) multiple observers.   That's pretty cool if you think about it.</p><p></p><p>In case you're thinking that there is no place for the Observer design pattern in practical day-to-day ServiceNow scripting, let me propose a scenario and see if you have ever bumped into anything similar:</p><p></p><p>You have a Workflow running on a catalog item.   That Workflow executes a "Run Script" activity which creates a new Change Request.     Then the Workflow moves to a "Wait for Condition" activity.     The idea is for the catalog item to hang around and wait until the Change moves to a particular state, and then flow to the next activity.     You implement the Workflow, but are sorely disappointed to find that the "Wait for Condition" activity never detects the state change on the Change, though you're sure that your code is written correctly.   What gives?   While updates to the RITM would trigger the "Wait for Condition" activity to be re-evaluated, updates on a completely different task (the Change) do not.     The RITM Workflow is stranded!</p><p></p><p>So, what's the solution?     We can implement a variation of the Observer pattern on the Task table with just a couple of quick modifications.</p><p></p><p><span style="line-height: 1.5;">1. Add a GlideList field to the Task table.</span></p><p></p><p><img   class="image-1 jive-image" src="1ea6e4cedb5457049c9ffb651f961940.iix" style="max-width: 1200px; max-height: 900px;"/></p><p></p><p>2. Add an Advanced Before (Insert/Update) Business Rule called run flows on observers:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14482907336173742 jive_text_macro" data-renderedposition="2612.54248046875_7.997159004211426_1078_263" jivemacro_uid="_14482907336173742"><p>// It is possible that a WF on a different task is sitting at a wait for condition Activity.   </p><p>// If an activity is registered as this task's observer we will 'nudge' that task's WF, </p><p>//       causing it to recheck its Wait For activity's condition.</p><p>//Condition: !current.u_observers.nil()</p><p style="color: #666666; font-family: arial, sans-serif;">(function(){ </p><p style="color: #666666; font-family: arial, sans-serif;">       var wf = new Workflow(); </p><p></p><p style="color: #666666; font-family: arial, sans-serif;">       var ri = new GlideRecord("task"); </p><p style="color: #666666; font-family: arial, sans-serif;">       ri.addQuery('sys_id','IN',current.u_observers);</p><p style="color: #666666; font-family: arial, sans-serif;">       ri.query(); </p><p></p><p style="color: #666666; font-family: arial, sans-serif;">       while(ri.next()){ </p><p style="color: #666666; font-family: arial, sans-serif;">               wf.runFlows(ri, 'update'); </p><p style="color: #666666; font-family: arial, sans-serif;">       } </p><p></p><p style="color: #666666; font-family: arial, sans-serif;">})(); </p><p style="color: #666666; font-family: arial, sans-serif;"></p></pre><p style="color: #666666; font-family: arial, sans-serif;"></p><p style="color: #666666; font-family: arial, sans-serif;">* Thanks to <a title="sabell2012" __default_attr="7849" __jive_macro_name="user" class="jive_macro jive_macro_user" data-orig-content="sabell2012" data-renderedposition="2897.087890625_83.45169830322266_88_15" href="/community?id=community_user_profile&user=838f86e9db181fc09c9ffb651f9619d9">sabell2012</a> for the improvement on this code!</p><p></p><p>Now when the Change (the subject) is updated, all of observers will get a signal to run their flows, as if that Task had been updated.</p><p></p><p>This is really powerful!     With one addition to the Task table, any Task can easily be informed (have its Workflow triggered) due to an update to any other Task.   Though I created this for the use-case described above, I now feel that the applications are wide-ranging, and that it will be a default configuration for all of the instances I work on moving forward.</p><p></p><p>If you want to be a better developer, you owe it to yourself to spend some energy learning about design patterns.     I really enjoy the Head First Design Patterns (subset) book, but there are tons of great resources available online as well.   Please feel free to add links to your favorite DP resources below in the comments.</p><p></p><p>We'll find out who the real hard-core geeks are among us if they say that they found the GOF book pleasant bedside reading.   <span __jive_emoticon_name="wink" __jive_macro_name="emoticon" class="jive_emote jive_macro" data-renderedposition="3115.269775390625_802.5426025390625_16_16" src="/8.0.1.35b65d4/images/emoticons/wink.png"></span></p>