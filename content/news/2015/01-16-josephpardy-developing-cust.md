---
title: "Developing Custom Applications for Performance"
date: 2015-01-16T05:54:42.000Z
authors: ["josephpardy"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=73ace625dbd0dbc01dcaf3231f961966"
---
<p style="margin-bottom: .0001pt; text-indent: .5in;"><span style="font-size: 11.0pt; font-family: 'Calibri',sans-serif; color: black;">ServiceNow has become a platform that is essential for some businesses to function by supplying a platform for common development where data can be shared. This interconnectedness fosters an environment where data is kept up to date through the daily work of the employees, directly empowering and influencing all corners of the business. To take full advantage of this environment the audience must extend beyond IT.   Once the user base has expanded to interact with more departments in the company its processes and applications must also expand to meet their needs. In this article we will start to discuss the development practices and techniques that should be employed in an environment where many users and applications are interacting; to ensure that the performance of your system is not impacted. </span></p><p style="margin-bottom: .0001pt;"></p><p style="margin-bottom: .0001pt; text-indent: .5in;"><span style="font-size: 11.0pt; font-family: 'Calibri',sans-serif; color: black;">IT organization can drive adoption to the platform by becoming the provider of services to the company's many groups using core applications like Service Catalog, CMS, and Knowledge. Quick access to information, services, and support can be provided through these tools with an attractive and customizable user interface.   Many times though the needs of an organization become complex and a custom component or application is needed to support their work. Application development on ServiceNow gives organizations both inside and outside of IT the ability to enhance their workflows and business processes. Efficiency and excellence in business can be empowered with this interconnected and flexible system of applications.   </span></p><p style="margin-bottom: .0001pt;"></p><p style="margin-bottom: .0001pt; text-indent: .5in;"><span style="font-size: 11.0pt; font-family: 'Calibri',sans-serif; color: black;">A larger more diverse user base interacting with data from across the business using a variety of applications will start to put strain on the system.   Having a slow and cumbersome application impacts the speed in which the organization performs, and could impact other applications and groups that rely on their data. Structuring your applications with modularity and performance in mind will help build an environment where applications do not collide with each other. There are some key approaches that should be considered to isolate your processes and data and take advantage of the systems resources. Using asynchronous techniques in Business Rules, Script Includes, and Client Scripts will set the foundation for a scalable application environment.</span></p><p style="margin-bottom: .0001pt;"></p><p style="margin-bottom: .0001pt; text-indent: .5in;"><span style="font-size: 11.0pt; font-family: 'Calibri',sans-serif; color: black;">Asynchronous processes can move data and instructions through the system utilizing its resources without making the user wait for those actions to complete. We keep the system busy with processing requests and allow higher priority tasks to execute that would impact other users. Large amounts of data that needs to be processed or code that needs to be executed should happen asynchronously for anything that is not required to return to the user directly. Actions such as additional record creation or field calculation can be placed into an asynchronous Business Rule. To the user these actions perform behind the scene and their page returns to them quickly and allows them to move onto their next task. </span></p><p style="margin-bottom: .0001pt;"></p><p style="margin-bottom: .0001pt; text-indent: .5in;"><span style="font-size: 11.0pt; font-family: 'Calibri',sans-serif; color: black;">Within code we have the capability to control what we are processing utilizing events in ServiceNow. We can create custom events and handlers in the system to send data processing and instructions to be executed in the background. This is perfect for long running scripts that are not required to complete right away or might even timeout. For instance, let's say you had large amount of records to read and transform data into another table. At some point the number of records you are looping through could make for an extremely long running process, especially if there are additional tables to look up based on each record's information. Structuring your code to create an event for each record and a handler that will execute the transformation of that single record would allow the system to potentially process multiple records at once and not have any single process execute for too long. Eliminating long running processes on the system will help all concurrent users avoid experiencing any performance issues. </span></p><p style="margin-bottom: .0001pt; text-indent: .5in;"><span style="font-size: 11.0pt; font-family: 'Calibri',sans-serif; color: black;"><br/></span></p><p style="margin-bottom: .0001pt; text-indent: .5in;"><span style="font-size: 11.0pt; font-family: 'Calibri',sans-serif; color: black;">The code below is an example of what would be written to generate events for using a custom event that we have registered "record.transform" for the purposes of transforming each record individually:</span></p><p style="margin-bottom: .0001pt; text-indent: .5in;"><span style="font-size: 11.0pt; font-family: 'Calibri',sans-serif; color: black;"><br/></span></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_text_macro jive_macro_code _jivemacro_uid_14387240670526414" jivemacro_uid="_14387240670526414">
<p><span style="font-size: 9pt; line-height: 12pt;">//assume the records variable is a GlideRecord object</span></p>
<p>while (records.next()) {</p>
<p>   //the two extra parameters can be used to pass additional information like 'sys_id'</p>
<p>       gs.eventQueue("record.transform", records, records.sys_id, '');</p>
<p>}</p>


</pre><p style="margin-bottom: .0001pt;"><span style="color: #000000; font-family: Calibri, sans-serif; font-size: 15px; text-indent: 48px;">                             </span></p><p style="margin-bottom: .0001pt;"><span style="color: #000000; font-family: Calibri, sans-serif; font-size: 15px; text-indent: 48px;">                             This is some code that would be in place to handle the "record.transform" event:</span></p><p style="margin-bottom: .0001pt;"><span style="color: #000000; font-family: Calibri, sans-serif; font-size: 15px; text-indent: 48px;"><br/></span></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_14387240670416767 jive_text_macro jive_macro_code" jivemacro_uid="_14387240670416767">
<p>//Importing a script include that will perform the transform</p>
<p>gs.include('RecordTransformer');</p>
<p>var sys_id = event.parm1;</p>
<p>var result = new RecordTransformer().transformRecord(sys_id);</p>
<p>//the result here is the success or failure of the the transform</p>
<p>gs.log(result, 'RecordTransformResult');</p>


</pre><p style="margin-bottom: .0001pt;"></p><p style="margin-bottom: .0001pt; text-indent: .5in;"><span style="font-size: 11.0pt; font-family: 'Calibri',sans-serif; color: black;">Sometimes it is not just raw data processing that needs to be optimized in order to provide the user with a good experience. Inefficient client side JavaScript can present the illusion of a poor performing system. For example retrieving a record in another table from the client side would cause an additional communication to the server after the form has loaded. In most cases this could be handled with a before display Business Rule that can perform that action on the server and make it's result available in the scratchpad to the front end. In some cases it may be necessary to wait for an interaction with the user before that data can be fetched. Enhancing fields with auto population and lookups based on the information that they are providing is a great way to enrich the user experience. In Client Scripts GlideAjax enables our ability to connect data in other parts of the system to the user's inputs on the form. Not all Ajax performs asynchronously though, using functions like <em>getXMLWait()</em> with stop all functions on the form until it has received a response from the server. This is a very choppy user experience where the user perceives the system to be extremely slow. Using a call back function to update the form on the return from the server would allow the user to keep moving through the form, and the data will populate in nearly the exact amount of time without interruption. </span></p><p style="margin-bottom: .0001pt;"></p><p style="margin-bottom: .0001pt;"><span style="color: #000000; font-family: Calibri, sans-serif; font-size: 15px; text-indent: 48px;">                         Here is a code example for using GlideAjax on the client side utilizing a callback function:</span></p><p style="margin-bottom: .0001pt;"></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_text_macro jive_macro_code _jivemacro_uid_14387240670179023" jivemacro_uid="_14387240670179023">
<p>//This GlideAjax Function retrieves related records from a Script Include for reference on the clientside</p>
<p>var ga = new GlideAjax('RelatedRecords');</p>
<p>//the sysparm_name parameter calls out the function that will be evoked in the script include</p>
<p>ga.addParam('sysparm_name', 'getRecords')</p>
<p>ga.addParam('sysparm_foreign_id', g_form.getUniqueValue());</p>
<p>ga.getXMLAnswer(RecordsParse);</p>
<p></p>
<p>function RecordsParse(response) {</p>
<p>     //In this case we are going to assume that the script include is returning an array of records</p>
<p>     var answer = response;</p>
<p>     alert(answer.length());</p>
<p>}</p>


</pre><p style="margin-bottom: .0001pt;"></p><p style="margin-bottom: .0001pt; text-indent: .5in;"><span style="font-size: 11.0pt; font-family: 'Calibri',sans-serif; color: black;">These are some examples of how we can reduce the dependencies of process execution in the system and attempt to avoid poor performance. We focused mostly on asynchronous data processing and code execution. These practices can reduce the appearance of performance issues to users and take advantage of the system's resources efficiently. Applications that do not create long running processes will not interfere with other users and applications in the system. Having this environment where applications interact but do not collide will encourage people to use the platform. In a future article where we discuss some basic optimizations and strategies for tables and the data stored there to improve querying efficiency and reporting. </span></p>