---
title: "What index should it be  OR  Slow Queries explained"
date: 2015-09-29T23:35:30.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=8e9c6ee1dbd0dbc01dcaf3231f96197e"
---
<p>Since Fuji, administrators can now add indexes to their own instances as needed. Fellow support agent <a title="Bill Tang" __default_attr="39645" __jive_macro_name="user" class="jive_macro_user jive_macro" data-orig-content="Bill Tang" href="/community?id=community_user_profile&user=63329ea5dbd81fc09c9ffb651f961930">Bill Tang</a> wrote in detail how you can <a __default_attr="4388" __jive_macro_name="blogpost" class="jive_macro jive_macro_blogpost" data-orig-content="Improve your ServiceNow instance performance by creating database indexes via the User Interface" href="/community?id=community_blog&sys_id=62edaee9dbd0dbc01dcaf3231f9619ee" modifiedtitle="true" title="Improve your ServiceNow instance performance by creating database indexes via the User Interface.">Improve your ServiceNow instance performance by creating database indexes via the User Interface</a> To expand on this function, I want to focus on what you can do if you have a slow query in the slow query log and want to know how to make this specific query faster.</p><p></p><p><em>A note of caution though - adding too many indexes, even if they work well for a query - can be detrimental to the table's overall performance. Always feel free to consult with your support engineers to determine if adding the new index will be beneficial.</em></p><p></p><p></p><table border="1"><tbody><tr><td><h3>Example of a slow query log</h3><p>First you need to analyze the Slow Queries log under <a title="ki.servicenow.com/index.php?title=Running_System_Diagnostics#gsc.tab=0" href="http://wiki.servicenow.com/index.php?title=Running_System_Diagnostics#gsc.tab=0">System Diagnostics</a> and to do that, you will need to be able to interpret all the information given in every log entry. I have used my instance as an example on how and in which order to read the slow query information:</p><p><img   alt="slow log.jpg" class="image-0 jive-image" src="4ca5f442db989304b322f4621f9619c0.iix" style="height: 298px; width: 620px; display: block; margin-left: auto; margin-right: auto;"/></p><p></p><p>First, I sort my list descending on Total execution time - this is where I can make the biggest difference, because these slow queries are executed most often. I usually don't worry about queries that are in the single or double digits, but everything higher than that for average execution time, I will analyze more closely. Once I have finished my analysis on those findings, I move on to the queries with the highest average execution time.</p><p></p><p>Let us look at a single query that needs improvement and analyze it:</p><p>Slow Queries Example:</p><p>SELECTFROM (sys_dictionary sys_dictionary0   INNER JOIN sys_metadata sys_metadata0 ON sys_dictionary0.`sys_id` = sys_metadata0.`sys_id` )   WHERE sys_dictionary0.`choice_table` IS NOT NULL</p><p></p><p>Total execution time: 50 Minutes</p><p>Execution count: 40.091</p><p>Average execution time (ms): 75,72</p><p></p><p><span style="font-size: 10pt; line-height: 1.5em;">Example stack trace: </span></p><p>glide.scheduler.worker.0</p><p>   com.glide.db.query_stats.QueryPattern.setStackTrace(QueryPattern.java:59)</p><p>   com.glide.db.query_stats.QueryStats.handleMetaData(QueryStats.java:111)</p><p>   com.glide.db.query_stats.QueryStats.addToNursery(QueryStats.java:86)</p><p>   com.glide.db.query_stats.QueryStats.recordQuery(QueryStats.java:74)</p><p>   com.glide.db.query_stats.QueryStats.recordQuery(QueryStats.java:63)</p><p>   com.glide.db.DBI.saveStats(DBI.java:1035)</p><p>   com.glide.db.DBI.sqlVerbosity(DBI.java:1029)</p><p>   com.glide.db.DBI.executeStatement(DBI.java:785)</p><p>   com.glide.db.DBI.executeStatement(DBI.java:766)</p><p>   com.glide.db.DBQuery.executeAsResultSet0(DBQuery.java:290)</p><p>   com.glide.db.DBQuery.executeAsResultSet0(DBQuery.java:265)</p><p>   com.glide.db.DBQuery.executeAndReturnTable(DBQuery.java:231)</p><p>   com.glide.db.DBAction.executeNormal(DBAction.java:197)</p><p>   com.glide.db.DBAction.executeAndReturnException(DBAction.java:166)</p><p>   com.glide.db.RDBMSQueryContext.executeQuery(RDBMSQueryContext.java:46)</p><p>   com.glide.db.DBQuery.execute(DBQuery.java:1772)</p><p>   com.glide.choice.ChoiceDependency.&lt;init&gt;(ChoiceDependency.java:39)</p><p>   com.glide.choice.ChoiceDependency.get(ChoiceDependency.java:28)</p><p>   com.glide.choice.ChoiceChangeListener.expandMe(ChoiceChangeListener.java:49)</p><p>   com.glide.choice.ChoiceChangeListener.flushChanges(ChoiceChangeListener.java:37)</p><p>   com.glide.db.AChangeListener.onExecute(AChangeListener.java:43)</p><p>   com.glide.db.DBAction.processListeners(DBAction.java:143)</p><p>   com.glide.db.DBAction.executeAndReturnException(DBAction.java:171)</p><p>   com.glide.script.GlideRecordITable.delete(GlideRecordITable.java:177)</p><p>   com.glide.script.GlideRecord.delete(GlideRecord.java:4913)</p><p>   com.glide.script.system.GlideSystemUtilDB.tableClearByTable(GlideSystemUtilDB.java:523)</p><p>   com.glide.script.system.GlideSystemUtilDB.cleanupTableReferences(GlideSystemUtilDB.java:504)</p><p>   com.glide.script.system.GlideSystemUtilDB.dropTable(GlideSystemUtilDB.java:741)</p><p>   com.glide.script.system.GlideSystemUtilDB.js_dropTable(GlideSystemUtilDB.java:428)</p><p>   ...</p><p>   org.mozilla.javascript.gen.c5175.call(sys_script_include.77e30b080a00052638e7274157b9b97a:30)</p><p>   org.mozilla.javascript.ScriptRuntime.call(ScriptRuntime.java:1227)</p><p>   org.mozilla.javascript.gen.c3087.call(sys_script_include.bb1996e80a0a0b0f00499e4a748ddfb7:58)</p><p>   org.mozilla.javascript.ScriptRuntime.call(ScriptRuntime.java:1227)</p><p>   org.mozilla.javascript.gen.c3088.call(sys_script_include.bb1996e80a0a0b0f00499e4a748ddfb7:67)</p><p>   org.mozilla.javascript.ScriptRuntime.call(ScriptRuntime.java:1227)</p><p>   org.mozilla.javascript.gen.c5173.call(sysevent_script_action.2227b84a0a0a0b950004868f9ece6509:3)</p><p>   org.mozilla.javascript.gen.c5173.exec(sysevent_script_action.2227b84a0a0a0b950004868f9ece6509)</p><p>   com.glide.script.ScriptEvaluator.execute(ScriptEvaluator.java:233)</p><p>...</p><p>   com.glide.script.fencing.GlideScopedEvaluator.evaluateScript(GlideScopedEvaluator.java:192)</p><p>   com.glide.policy.ScriptActionHandler.executeScriptInScope(ScriptActionHandler.java:144)</p><p>   com.glide.policy.ScriptActionHandler.process0(ScriptActionHandler.java:62)</p><p>   com.glide.policy.ScriptActionHandler.process(ScriptActionHandler.java:39)</p><p>   com.glide.policy.EventProcessor.processEventDuringNormalOperation(EventProcessor.java:164)</p><p>...</p><p>   com.glide.policy.EventManager._process(EventManager.java:160)</p><p>   com.glide.policy.EventManager.process(EventManager.java:142)</p><p>...</p><p>   org.mozilla.javascript.FunctionObject.doInvoke(FunctionObject.java:597)</p><p>   org.mozilla.javascript.FunctionObject.call(FunctionObject.java:504)</p><p>   org.mozilla.javascript.ScriptRuntime.call(ScriptRuntime.java:1227)</p><p>...</p><p>   com.glide.schedule.JobExecutor.execute(JobExecutor.java:79)</p><p>   com.glide.schedule.GlideScheduleWorker.executeJob(GlideScheduleWorker.java:177)</p><p>   com.glide.schedule.GlideScheduleWorker.process(GlideScheduleWorker.java:124)</p><p>   com.glide.schedule.GlideScheduleWorker.run(GlideScheduleWorker.java:56)</p><p></p><p>Example URL: events process</p><p>First sighting: 2015-09-22 17:10:33</p><p></p><h4>The Explain Plan</h4><table border="1"></table><p>OrderSelect TypeTableTypePossible KeysKeyKey lengthRefRowsExtraID0SIMPLEsys_dictionary0ALLPRIMARY25.629Using where11SIMPLEsys_metadata0eq_refPRIMARYPRIMARY96empigeist2_2.sys_dictionary0.sys_id11</p><p></p><h4>The Database Indexes</h4><table border="1"><tbody><tr><td><strong>Table</strong></td><td><strong>Reference Table</strong></td><td><strong>Index</strong></td></tr><tr><td>sys_scope</td><td>sys_scope</td><td>sys_metadata</td></tr><tr><td>reference</td><td>reference</td><td>sys_dictionary</td></tr><tr><td>element, name</td><td>element</td><td>sys_dictionary</td></tr><tr><td>sys_id</td><td>PRIMARY</td><td>sys_metadata</td></tr><tr><td>sys_id</td><td>PRIMARY</td><td>sys_dictionary</td></tr><tr><td>sys_package</td><td>sys_package</td><td>sys_metadata</td></tr><tr><td>name, element</td><td>name</td><td>sys_dictionary</td></tr><tr><td>sys_update_name, sys_class_name</td><td>sys_update_name</td><td>sys_metadata</td></tr></tbody></table><p></p><p></p><p>This is all the information available to you in the Slow Queries log. I will explain them in the order in which they make most sense to me - from the time the query was issued to the additional information that helps us understand what is going on.</p></td></tr></tbody></table><p></p><h3>Interpreting the slow query log information</h3><h4>Query Source</h4><p>Through the example URL we know that this query was issued by the events process. Another common example URL might be /home.do - meaning the slow query is on a user's home page. The stack trace confirms that this query comes from a worker:   com.glide.schedule.GlideScheduleWorker.run(GlideScheduleWorker.java:56).</p><p></p><p>Following the stack further, I see org.mozilla.javascript.gen.c5175.call(sys_script_include.77e30b080a00052638e7274157b9b97a:30), which refers to a script include called TableDrop, which in line 30 gs.dropTable(tableName); which includes - of course - querying the dictionary record for which table to drop.</p><p></p><h4>Query run times</h4><p>Now that we know the background of this query - how often did it run, how long did it take? The answers to this can be found here:</p><p>Total execution time: 50 Minutes</p><p>Execution count: 40.091</p><p>Average execution time (ms): 75,72</p><p></p><p>Then the question becomes - why does it take so long for a simple query?</p><p></p><h4>Query analysis</h4><p>The query is:</p><p>SELECTFROM (sys_dictionary sys_dictionary0   INNER JOIN sys_metadata sys_metadata0 ON sys_dictionary0.`sys_id` = sys_metadata0.`sys_id` )   WHERE sys_dictionary0.`choice_table` IS NOT NULL</p><p></p><p>What does this query do?</p><p>It first queries the sys_dictionary table for all records where choice_table is not null. Then it joins the result of that with the information in the sys_metadata table for all records where the sys_ids match.</p><p></p><h4>Interpreting an explain plan</h4><p>Why does this take so long? To find that out, we look at the explain plan:</p><table border="1"><tbody><tr><td><strong>Order</strong></td><td><strong>Select Type</strong></td><td><strong>Table</strong></td><td><strong>Type</strong></td><td><strong>Possible Keys</strong></td><td><strong>Key</strong></td><td><strong>Key len</strong></td><td><strong>Ref</strong></td><td><strong>Rows</strong></td><td><strong>Extra</strong></td><td><strong>ID</strong></td></tr><tr><td>0</td><td>SIMPLE</td><td>sys_dictionary0</td><td>ALL</td><td>PRIMARY</td><td></td><td></td><td></td><td>25.629</td><td>Using where</td><td>1</td></tr><tr><td>1</td><td>SIMPLE</td><td>sys_metadata0</td><td>eq_ref</td><td>PRIMARY</td><td>PRIMARY</td><td>96</td><td>empigeist2_2.sys_dictionary0.sys_id</td><td>1</td><td>Extra</td><td>1</td></tr></tbody></table><p></p><p></p><p>This is the real interesting part - what does all this mean?</p><p>The more common Select Types are:</p><ul><li>SIMPLE; no UNION or subquery</li><li>PRIMARY; outermost SELECT</li><li>UNION; second or later SELECT in a UNION</li><li>SUBQUERY; first SELECT in subquery</li><li>DERIVED; derived table (subquery in WHERE clause)</li></ul><p></p><p>The most commonly seen types are - in order of efficiency:</p><table border="1"><tbody><tr><td><strong>Name</strong></td><td><strong>Description</strong></td></tr><tr><td>const</td><td>At most, one matching value, treated as a constant.   I.e. active = 1</td></tr><tr><td>eq_ref</td><td>Joining or looking up unique index values.   JOIN uses a unique index or key prefix.   I.e. joining two tables on the PRIMARY key.</td></tr><tr><td>ref</td><td>Joining or looking up non-unique index values.   JOIN uses a non-unique index or key prefix.   Indexed fields compared with '=', '!='. Best data access strategy for non-unique values.</td></tr><tr><td>index_merge</td><td>Perform several index searches using different keys from same table   and merge the results.</td></tr><tr><td>range</td><td>Range index scan. The key column is compared to a constant using operators like BETWEEN, IN, &gt;, &gt;=. I.e. sys_created_on &gt; "2015-09-23 00:00:00".</td></tr><tr><td>index</td><td>Full Index scan. The entire index tree is scanned.</td></tr><tr><td>ALL</td><td>Full Table scan.   The Entire table is scanned.</td></tr></tbody></table><p></p><p>Now that we have all this information, what does our explain mean:</p><table border="1"><tbody><tr><td><strong>Order</strong></td><td><strong>Select Type</strong></td><td><strong>Table</strong></td><td><strong>Type</strong></td><td><strong>Possible Keys</strong></td><td><strong>Key</strong></td><td><strong>Key len</strong></td><td><strong>Ref</strong></td><td><strong>Rows</strong></td><td><strong>Extra</strong></td><td><strong>ID</strong></td></tr><tr><td>0</td><td>SIMPLE</td><td>sys_dictionary0</td><td>ALL</td><td>PRIMARY</td><td></td><td></td><td></td><td>25.629</td><td>Using where</td><td>1</td></tr><tr><td>1</td><td>SIMPLE</td><td>sys_metadata0</td><td>eq_ref</td><td>PRIMARY</td><td>PRIMARY</td><td>96</td><td>empigeist2_2.sys_dictionary0.sys_id</td><td>1</td><td></td><td>1</td></tr></tbody></table><p></p><p>We are querying two tables, sys_dictionary first, and then sys_metadata. In the case of sys_dictionary, we use a full table scan through the primary key (sys_id) and have to scan through 25.629 records, that we then filter out from there through the where clause. <span style="font-size: 10pt; line-height: 1.5em;">On the sys_metadata table, we merge the results of the first query record by record based on the primary key, sys_id.</span></p><p></p><p>Why did it use the primary key and a full table scan on the dictionary query? The answer is simple - there is no index on choice_table, so it had no matching index to go with. If we were to add an index (non-unique, since we do not create unique indexes for query tuning) on choice_table, our explain would then look like something like this:</p><p></p><table border="1"><tbody><tr><td><strong>Order</strong></td><td><strong>Select Type</strong></td><td><strong>Table</strong></td><td><strong>Type</strong></td><td><strong>Possible Keys</strong></td><td><strong>Key</strong></td><td><strong>Key len</strong></td><td><strong>Ref</strong></td><td><strong>Rows</strong></td><td><strong>Extra</strong></td><td><strong>ID</strong></td></tr><tr><td>0</td><td>SIMPLE</td><td>sys_dictionary0</td><td>ref</td><td>PRIMARY, choice_table</td><td>choice_table</td><td>40</td><td></td><td>5.427</td><td>Using index; using where</td><td>1</td></tr><tr><td>1</td><td>SIMPLE</td><td>sys_metadata0</td><td>eq_ref</td><td>PRIMARY</td><td>PRIMARY</td><td>96</td><td>empigeist2_2.sys_dictionary0.sys_id</td><td>1</td><td></td><td>1</td></tr></tbody></table><p></p><p>As you can tell, <strong>the extra now tells us an index was found and used</strong>. The number of rows we had to comb through to get to our records is significantly smaller, and it returns way faster than before.</p><p></p><p>Talking about the extras, here is a sampling of what they can be:</p><ul><li>Using filesort; filtered rows are gone through again for sorting</li><li>Using index; all data is retrieved from a single index (covering index)</li><li>Using index; using where; index is also used for all key lookups</li><li>Using temporary; a temporary table is required to process the query</li><li>Using where; a WHERE clause is used</li><li>Using join buffer; rows are re-used from the join buffer</li></ul><p></p><h3>Finding the best index for your query</h3><p>How do you know if an index will be good and taken or not - looking at the query is the first step, but there is also this thing called "cardinality." At one point, the database will decide that taking the index has no benefit and will revert to a full table scan. You will look at the explain plan very confused and say "I gave it an index, why would it not take it???"</p><p></p><p>Imagine the following situation: You are searching for all users named Jim that work in the Finance department. Your company has a total of 30000 users, out of those, 500 are named Jim, there are nearly a thousand different names in your list of users, and you have 15 departments in your company (meaning about 2000 users per department).</p><p></p><p>The story of cardinality is - how can I narrow down my results fastest, so I don't have to search through too much information. In our search for Jim in Finance - are we better off searching for Jim first, or for the Finance Department?</p><p></p><p>If we search (and index) for Jim first, we will go through an index tree that has nearly a thousand sorted nodes (all the different first names). If we search (and index) for departments first, we will go through only 15 nodes. But if you look at how many records it would find within the record, you would have 500 for the name, and around 2000 for the department, meaning searching and indexing for name first will narrow our results down fastest and furthest.</p><p></p><p>Different situation - you want to find all closed incidents in your system. 99% of all your incidents are closed. Will an index on state help? Most likely not, since there are so many closed incidents compared to the complete set of data, that it very likely will revert to a full table scan at that point.</p><p></p><h3>Sometimes you need to change they query, not the index</h3><p>And of course there are situations where an index cannot be used at all. <span style="font-size: 10pt; line-height: 1.5em;">We all love the "contains" searches that ServiceNow offers. In SQL speak, they translate to a LIKE '%xxx%', or a double wildcard. Databases cannot use an index on that type of query at all - always ending up with a full table scan (unless there is a saving grace of another part of the query that can be indexed)</span></p><p></p><p>Another example are OR queries against different fields: WHERE first_name="Jim" OR last_name="Smith" - in this case, it will first search all Jims, then all Smith's and merge the results together - it cannot use one index for both. We always recommend making those two queries and merge the results through other methods.</p><p></p><p>One more common example - if you group by one thing and order by another, the same situation occurs - what to take? Then I won't take any... : GROUP BY first_name, ORDER BY last_name</p><p></p><p>---</p><p></p><p style="text-align: center;"><em>Special thanks to our fantastic Performance Engineer Scott Nemes at ServiceNow who reviewed and provided some of those great tables that I included in here. Scott, you are the BEST!</em></p>