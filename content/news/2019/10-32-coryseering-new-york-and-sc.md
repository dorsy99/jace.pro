---
title: "New York and Scoped Applications  some new features"
date: 2019-11-01T03:16:40.000Z
authors: ["coryseering"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=ef21c1d21bf04c507a5933f2cd4bcb34"
---
<div>
<h1>New York and Scoped Applications - some new features</h1>
<br />
<h2>Deletes</h2>
<div>When ServiceNow introduced Scoped Applications (<em>waaaaaay</em> back in Fuji) we wanted the package to always represent the complete and current state of the app. To this end, the Publish mechanism (whether you publish to the private repo for your company, or to the Store, or even to an Update Set) will do a fresh query against all of the metadata tables to serialize your app&#39;s records for unloading. Your published app is always a reflection of what the app looks like <strong>now</strong>, and fresh installs of your application should look the same on any target instance that installs it.</div>
<br />
<div>Part of the nature of the platform is that any record that exists in your instance continues to exist, through platform upgrades and plugin installs and app updates- unless there is a specific command to delete that record. This can be done through the use of Fix Scripts or by loading a new copy of the record, but with a specific &#34;<em>action</em>&#34; attribute to tell the system you want to delete it.</div>
<br />
<div>These two things combined actually make for one of the features of Scoped Applications that people <strong>don&#39;t</strong> like. Scoped app developers want their installed app versions to look like (to have the same files) as when they clicked Publish for that version on their development system. If the develop version 1 of their app, then delete a Business Rule and a Script Include and replace it with an Event &#43; Script Action for version 2 of their app, then they want the Business Rule and the Script Include to be deleted when their instances upgrade from version 1 of the app to version 2. However, since we don&#39;t capture that &#34;delete&#34; action as a Fix Script or as a copy of the record with a Delete action (because the records no longer exist), you lose that history. In this case, user&#39;s instances which had version 1 installed will continue to have the Business Rule and the Script Include, even though version 2 of the application doesn&#39;t ship them anymore. This makes for an interesting comparison with instances that installed version 2 and never had version 1 at all. In those instances, that Business Rule and Script Include would not be present.</div>
<br />
<div>The strategy for managing this has been to modify the records instead of deleting them. As an application developer, if you want to stop using a Business Rule, set the &#34;<em>active</em>&#34; flag on the rule to <strong>false</strong>. If you want to stop using a Script Include, just stop calling it in your other active code. This is a bit unsatisfactory, since it means that you continue to ship things that you don&#39;t want to have to care about anymore. Your app can become cluttered over time. You are, in essence, responsible for maintaining the &#34;history&#34; of your application with every release.</div>
<br />
<div>For the New York release, we introduced a new concept to Scoped Applications, called the <span style="text-decoration: underline;">author_elective_update</span> folder. When your application is packaged for the repo or for committing to Source Control, we will unload additional things into this folder that we would previous have ignored. The <span style="text-decoration: underline;">author_elective_update</span> folder is where we will unload Deletes. When your application is installed on your own instances, we will automatically load these Deletes from the <span style="text-decoration: underline;">author_elective_update</span> folder. For our example above, this would result in the Business Rule and the Script Include being deleted from the system when the application is upgraded from version 1 to version 2. Additionally, if you make changes to the schema of your application by deleting a table or a column, that delete will be tracked in <span style="text-decoration: underline;">author_elective_update</span> but will not be applied by default.</div>
<br />
<div>If your application comes from a vendor and they have Deletes in some new version of the application, we will <strong>not</strong> automatically apply them when you upgrade the application. You have the option of applying the Deletes manually post-upgrade just like you can do when the instance itself is upgraded. We will record an Upgrade History for this application, and write Skips into the log for each application upgrade. You can go through those Skips and choose to apply them (such as accepting a Delete for a Script Include or a Business Rule) or leave them be.</div>
<br />
<div>One other type of metadata that will also be put into <span style="text-decoration: underline;">author_elective_update</span> are choice sets. We will now be putting choice sets for your app&#39;s tables into the <span style="text-decoration: underline;">author_elective_update</span> folder. We do this so that you can modify your choice lists- for instance, by removing one option and adding another- and seeing the option <em>actually get removed</em> when your app is updated on your production instance. Previously, in this scenario we would only have <em>added the new option</em>, leaving the option you wanted to delete there too.</div>
<br />
<div>These changes mean that updates to your applications should work more in line with how Update Set updates work. Since app updates do not give you an interface to preview changes yet, we have built-in some properties that you can use to control how updates from <span style="text-decoration: underline;">author_elective_updates</span> are treated. We have four levels of control currently:</div>
<br />
<div>- To turn off the feature completely, set the system property <strong>com.glide.apps.include_my_deletes</strong> to <strong>false</strong>. This will prevent the system from loading anything out of the <span style="text-decoration: underline;">author_elective_update</span> folder. This will also prevent records being <em>added to</em> the <span style="text-decoration: underline;">author_elective_update</span> folder, if you have in-development applications on this instance which you intent to Publish.</div>
<div>- To only save and load Choice sets, set the system property <strong>com.glide.apps.include_only_sys_choice</strong> to <strong>true</strong>.</div>
<div>- To allow automatically apply schema drops (automatically delete tables or columns which no longer exist in your application), set the system property <strong>com.glide.apps.include_my_schema</strong> to <strong>true</strong>.</div>
<div>- To decide on a case-by-case basis, set <strong>com.glide.apps.force_skips</strong> to <strong>true</strong>.</div>
<br /><br />
<h2>Scenarios</h2>
<div>Consider the following scenarios:</div>
<div>1. You are building a new application to put on the Store, and storing your work in Source Control</div>
<div>2. You are a vendor and already have versions of your application on the Store, and you are providing a new version</div>
<div>3. You have an existing application that you distribute to your company&#39;s instances using the repo, and you are providing a new version</div>
<div>4. You work on the same application across multiple instances, and you sync to the same Source Control branch(es)</div>
<br />
<h3>New Vendor-Application Scenario</h3>
<div>Since you are building a new application, there really isn&#39;t much that has changed for you. During the course of building your application, you may end up creating and deleting multiple kinds of metadata. As you commit your changes to Source Control, you will find that the <span style="text-decoration: underline;">author_elective_update</span> folder starts to accumulate some records. You can turn this off by setting the system property <strong>com.glide.apps.include_my_deletes</strong> to <strong>false</strong>. On your next commit, you will find that the <span style="text-decoration: underline;">author_elective_update</span> folder no longer exists. If you choose not to turn it off then the folder will be present when the application is Published to the store. When your customer installs it for the first time, and if <em>they</em> have not set <strong>com.glide.apps.include_my_deletes</strong> to <strong>false</strong>, the Deletes will be loaded into their system but should have no effect since the original files the Deletes represent don&#39;t exist on their system.</div>
<br />
<h3>Existing Vendor-Application Scenario</h3>
<div>If you have an existing application on the repo and you decide to develop new features for it, we will record the Deletes for your application into the <span style="text-decoration: underline;">author_elective_update</span> folder. The actual contents of this folder will vary based upon the history of actions taken on this development instance.</div>
<br />
<div>If you are working on this application for the original instance that the application was developed on, and you haven&#39;t cloned-over or otherwise deleted the application (or its records in sys_metadata_delete) then the history of all of your deletes will be included. If you have cloned the application, or you&#39;ve performed Source Control operations that uninstall and reinstall the application (such as switching branches) then the history of Deletes for this application has probably already been removed. We will track <em>new</em> Deletes in the <span style="text-decoration: underline;">author_elective_update</span> folder, but we cannot retroactively create Deletes for metadata that no longer exists.</div>
<br />
<div>When you publish the new version of your app, the Deletes that have been recorded on the instance are included. If you want to know what those are, you can browse the <span style="text-decoration: underline;">author_elective_update</span> folder in your git repository, or look at the sys_metadata_delete table and filter on your application. From the time you upgrade to New York (and start committing to your repo) your Deletes will be stored with your app as you commit to Source Control or Publish to the Store.</div>
<br />
<div>When your customers upgrade to this new version of your application, the Deletes in your <span style="text-decoration: underline;">author_elective_update</span> folder will be written as Skips in the Upgrade History entry for this application upgrade. Your users can browse the Skip list, and apply the changes on a case-by-case basis. Your customers have the option of setting <strong>com.glide.apps.include_my_deletes</strong> to <strong>false</strong>, which will skip writing Skip records as well (emulating the behavior of Madrid-and-earlier instances, which don&#39;t have a concept of <span style="text-decoration: underline;">author_elective_update</span> at all).</div>
<br />
<h3>Existing Application For Your Company Instances Scenario</h3>
<div>As in the above scenario, if you have an existing application on the repo and you decide to develop new features for it, we will record the Deletes for your application into the <span style="text-decoration: underline;">author_elective_update</span> folder. The actual contents of this folder will vary based upon the history of actions taken on this development instance. The only difference between this scenario and the one above is what happens when the instance gets an upgrade for the app from the repo (not from Source Control).</div>
<br />
<div>When your instances upgrade to this new version of your application, the Deletes in your application will be applied based upon the preferences below. You have 4 options:</div>
<div>1. The default setting: Accept any Deletes except schema changes (Skip deleting columns or tables)</div>
<div>2. Accept only Choice updates, and Skip the rest by setting <strong>com.glide.apps.include_only_sys_choice</strong> to <strong>true</strong></div>
<div>3. Accept all Deletes, including schema deletes, by setting <strong>com.glide.apps.include_my_schema</strong> to <strong>true</strong></div>
<div>4. Don&#39;t accept any Deletes, but write out Skips so you can apply them on a case-by-case basis by setting <strong>com.glide.apps.force_skips</strong> to <strong>true</strong></div>
<div>5. Don&#39;t accept any Deletes and skip writing Skips (thus emulating the behavior of Madrid-and-earlier instances) by setting <strong>com.glide.apps.include_my_deletes</strong> to <strong>false</strong>.</div>
<br />
<h3>Working On An Application Across Multiple Instances With Source Control Scenario</h3>
<div>In this scenario, you are working on an application across multiple instances, and keeping the application in-sync across instances by using the same branch during development. In this scenario, your Deletes are captured as you work on (and commit) your changes. All changes in the <span style="text-decoration: underline;">author_elective_update</span> folder will be pulled into the instance when you Apply Remote Changes in Source Control, or when you switch to a branch which contains <span style="text-decoration: underline;">author_elective_update</span>. You can accept these changes, or you can set <strong>com.glide.apps.include_my_deletes</strong> to <strong>false</strong> and when you perform a Source Control operation that would have loaded them, we will instead write our Skip records in an Upgrade History entry.</div>
<br />
<h2>TL;DR (Too Long, Didn&#39;t read)</h2>
<div>In short, you have control over how the <span style="text-decoration: underline;">author_elective_update</span> folder is handled. You can turn it off totally by setting <strong>com.glide.apps.include_my_deletes</strong> to <strong>false</strong>. You can set the specific level of records you want to apply (everything, everything except schema changes, or only Choice Sets). You can also make sure that the apps you develop will ship Deletes in the <span style="text-decoration: underline;">author_elective_update</span> folder, but you skip all <em>incoming</em> changes from any vendor app&#39;s <span style="text-decoration: underline;">author_elective_update</span> folder by setting <strong>com.glide.apps.disable_elective_skip_history</strong> to <strong>true</strong> and also setting <strong>com.glide.apps.force_skips</strong> to <strong>true</strong>.</div>
<br />
<div>I know the settings are complex, but so are the scenarios this feature should handle. You have different levels of trust between applications you develop within your own company and applications you get from vendors via the Store; you need applications imported via Source Control to load everything possible as the source of truth.</div>
<br /><br />
<h2>Glossary of Terms</h2>
<div>- <strong>Metadata</strong> are the records that define an application. You may also see it called <strong>file</strong>, <strong>application file</strong>, <strong>sys_metadata</strong> or <strong>app record</strong>. It includes record types like <em>Business rules</em>, <em>Script include</em>s, <em>Table definitions</em>, <em>Client scripts</em>, and so on. This is distinct from <strong>data</strong> which are things applications <strong><em>read</em></strong>, <strong><em>write</em></strong>, <strong><em>update</em></strong> and <strong><em>delete</em></strong> (like <em>Incidents</em>, <em>Change Requests</em>, <em>Problems</em>, <em>Projects</em>, <em>Users</em>, <em>Locations</em>, and so on).</div>
<br />
<div>- <strong>Package</strong> is the term used to describe the the collection of records that make up the application, specifically as it applies to installing or updating that application on instances other than where it was originally developed. Typically, this means the package built and stored in the repo, for distribution through the Store or the &#34;My Applications&#34; page, but also loosely used to describe the contents of a branch in a git repository when the application is connected to Source Control, or to an Update Set when the app has specifically been Published to an Update Set.</div>
<br />
<div>- <strong>Repo</strong> has a couple of different uses, depending on context.</div>
<div>- With regards to Publishing applications, the <strong>repo</strong> is a storage mechanism provided by ServiceNow and made available to all of the instances that belong to a given company. All Applications published to this repo can be installed on all of that company&#39;s instances, but those applications are not made available to other company&#39;s instances.</div>
<div>- When used with regards to the Source Control integration for scoped apps, a <strong>repo</strong> is any repository which you have linked the app&#39;s source code to. This is typically a Github or Gitlabs repository, within which you can store your app&#39;s source code, and which you can push changes to or import changes from, using the controls within Studio.</div>
<br />
<div>- <strong>Store</strong> is where applications can be put up for sale to ServiceNow customers. A scoped app can be published to the Store for other customers to purchase, and you can see the store at https://store.servicenow.com</div>
<br />
<div>- <strong>Update sets</strong> are one of the ways that changes to records in ServiceNow can be tracked. When Publishing to an Update set, a new set is created and every file in your application will be copied here.</div>
<br />
<div>- <strong>Serialize</strong> means taking the record from the database and writing it out as XML. This occurs whenever an update is written to an Update set, or when you right-click a record header and choose Export -&gt; XML, or when you commit changes via the Source Control integration. Serialized data may include more than one record in the output (such as when a record&#39;s attachments are included in the output, or when a Form layout, List layout, or Choice set is exported).</div>
<br />
<div>- <strong>Deletes</strong> are a way of tracking when a specific application file has been deleted from a system. They are recorded as records in the table <span style="text-decoration: underline;">sys_metadata_delete</span>.</div>
<br />
<div>- <strong>Unloading</strong> is the act of serializing a record and storing the result- either in an Update Set, in a Source Control commit, or into an application package being put on the repo or Store.</div>
<br />
<div>- <strong>Fix script</strong> is a way of running code after an upgrade, a plugin update, or an app update.</div>
<br />
<div>- <strong>Schema</strong> is a term that encompasses your tables and columns. Dropping (deleting) a table or an individual column is considered a schema change.</div>
<br />
<div>- <strong>Upgrade History</strong> is a module in ServiceNow that lets you see the history of upgrades to your platform, as well as individual plugin activation histories, and individual application upgrades.</div>
<br />
<div>- <strong>Module</strong> is an entry in the Navigator list (also referred to as the &#34;left-hand nav&#34;) of the ServiceNow interface</div>
<br />
<div>- <strong>Choice sets</strong> are records in ServiceNow that contain multiple individual choices for a single table&#39;s choice field.</div>
<br />
<div>- <strong>Skips</strong> are records in the <span style="text-decoration: underline;">sys_upgrade_history_log</span> table which are related to an Upgrade History entry, and detail whether a vendor-supplied (or ServiceNow-supplied) file was not loaded during an upgrade, but can be applied manually.</div>
</div>