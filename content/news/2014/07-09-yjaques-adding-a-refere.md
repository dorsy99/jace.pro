---
title: "Adding a reference Location to a User Record and Geolocating as you go"
date: 2014-07-08T23:25:14.000Z
authors: ["yjaques"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=c2cd62e9dbd0dbc01dcaf3231f961956"
---
<p>Where I work we have a terrible old LDAP directory full of obscenely bad location data. However, that's what we use to create our sys_user table in Service Now. So many of the users were missing location information that I decided to programatically start fixing that. The script below iterates through the sys_user table looking for users that have an empty Location field but have something in their Department field. Department for us is typically a geographic location with a city and/or country in the field. So where location is empty but department full the script then searches the cmn_location table looking for a match. If it finds one then problem solved, the sys_id of the matched location is placed in the user record and updated. If there's no match (usually the case) the script hands the problem off to Google who usually comes up with something. If so, the location is created and inserted in the cmn_location table and the returned sys_id is then used to populate the location field of the user table.</p><p></p><p>The script can be run as a background script. (And of course you could slightly modify it and have run as a business rule on insert/update to sys_user table). To see how to create the REST service look at my other post on geolocation.</p><p></p><p>var users = new GlideRecord('sys_user');</p><p>// Issue the query to the database to get all records</p><p>users.query();</p><p>var j=0;     </p><p>while (users.next()) {</p><p>         if(users.location=="" &amp; users.department !="") {</p><p>                   if(updateUser(users)) {</p><p>                             gs.log("Updated: "+users.name);</p><p>                   } else {</p><p>                             gs.log("Failed to update: "+users.name);</p><p>                   }</p><p>                   //set this number for however many iterations you want to try to fix. since it takes about 15 seconds per fix due to Google REST API you can seriously freeze up your instance if you run this as a background script. I recommend doing a 100 at a time.</p><p>                   if (j&lt;1)</p><p>                             j++;</p><p>                   else</p><p>                             break;</p><p>         }</p><p>}</p><p></p><p></p><p>function updateUser(users) {</p><p>         //find the location if it exists</p><p>         var locations = new GlideRecord('cmn_location');</p><p>         while (locations.next()) {</p><p>                   if(users.department.name == locations.name) {</p><p>                             users.location=locations.sys_id;</p><p>                             users.update();</p><p>                             return true;</p><p>                   }</p><p>         }</p><p>         //we didn't find a match so create the location based on the department         </p><p>         //create a new location record                   </p><p>         var gr = new GlideRecord('cmn_location');</p><p>         gr.initialize(); </p><p>         gr.name = users.department.name; </p><p>         </p><p>         //geolocate</p><p>         gs.log("requesting address:"+users.department.name);</p><p>         //get the Rest Message service</p><p>         var r = new RESTMessage('Google GeoLocate', 'get');</p><p>         r.setStringParameter('address',users.department.name);</p><p>         var response = r.execute();</p><p>         </p><p>         // put in a wait or it will return undefined</p><p>         var k = 1;</p><p>         while ( response == null ) {</p><p>                   response = r.getResponse( 1000 );</p><p>                   k++;</p><p>                   if ( k &gt; 30 ) {</p><p>                             gs.log( 'service time-out' );</p><p>                             break;</p><p>                   }</p><p>         }</p><p>         gs.log( "response took ... " + k + " seconds");</p><p>         var mess = "";</p><p>         //parse response</p><p>         var parser = new JSONParser();</p><p>         var parsed = parser.parse(response.getBody());</p><p>         if(parsed != null &amp;&amp; typeof(parsed) != undefined) {</p><p>                   gr.latitude = parsed.results[0].geometry.location.lat;</p><p>                   gr.longitude = parsed.results[0].geometry.location.lng;</p><p>                   </p><p>                   var g_address = parsed.results[0].address_components;                   </p><p>                   for(var m=0;m&lt;g_address.length;m++) {                             </p><p>                             for(var n=0;n&lt;g_address[m].types.length;n++) {                                       </p><p>                                       if (g_address[m].types[n] == "country") {</p><p>                                                 gr.country = g_address[m].short_name;</p><p>                                       }</p><p>                             }</p><p>                   }</p><p>         } else {</p><p>                   gr.lat_long_error = "true"; </p><p>                   mess += "Lat/long not found. Problem with returned JSON. "; </p><p>         }</p><p>         var sys_id = gr.insert();</p><p>         if(sys_id != null) {</p><p>                   users.location=sys_id;</p><p>                   users.update();</p><p>                   mess += "Added location to user record."; </p><p>                   gs.log(mess);</p><p>                   return true;</p><p>         } else {</p><p>                   gs.log(mess + "Could not add location to user record!");</p><p>                   return false;</p><p>         }                             </p><p>}</p>