---
title: "Change Requests  Affected Users and Groups"
date: 2014-07-11T03:06:00.000Z
authors: ["yjaques"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=c19ceae1dbd0dbc01dcaf3231f9619e5"
---
<p>One thing that I've always found problematic with Change Requests in Service Now is that there is no easy way to analyze the actual impact on users and groups. The Affected and Impacted Services/CIs tabs are great, but any relationship to users is sadly lacking. To remedy this we've added a field or two and done a bit of scripting so that now Change Requests display affected user groups. What are the steps?</p><p></p><p>1. We added a column to the Applications table called "User Group" that references the User Group table. We have import sets that pull users from application databases and maintain the user groups for each application so we can easily associate Applications and the set of users that use them.</p><p></p><p>2. We added a string field to the Change Request table called "Affected Users" and we display it in the Change Request View.</p><p></p><p>3. We have a Business Rule that is fired when a Change Request is inserted in the table (i.e. when someone raises a change request). The Business Rule grabs the CI from the Change Request and iterates through the Upstream relationships looking for User Groups. Whenever it finds one it adds it to a key value array and counts the members. When it's done iterating it writes the array as a small ASCII text table to the Affected Users field of the Change Request. This way even before the request gets sent to our CAB the person raising the request can get an idea of how many groups and users will be impacted. Here's the script that goes into the business rule:</p><p></p><p>// Speed up calls to hasOwnProperty</p><p>var hasOwnProperty = Object.prototype.hasOwnProperty;</p><p></p><p></p><p>if (current != null) {</p><p>         var thisRequest = current.sys_id;</p><p>         var rootStr = '';</p><p>         var depthLim = 5;</p><p>         var req = new GlideRecord('change_request');         </p><p>         req.get(thisRequest);</p><p>         logFields(req, 0);</p><p>         â€‰</p><p>         //get the CI associated to this change request and use it to find other CIs that will be affected</p><p>         var rootCI = getCI(req.cmdb_ci);</p><p>         rootStr = rootCI.getDisplayValue() + ' (' + rootCI.category + '/' + rootCI.subcategory + ') Planned period: ' + req.start_date + ' - ' + req.end_date;</p><p>         </p><p>         //this object holds affected user group keys with user member counts that are then added to the change request comments to help approvers understand the situation.</p><p>         var affectedGroups = {};</p><p>         //process the root CI</p><p>         affectedGroups = processCI(rootCI, 0,affectedGroups);         </p><p>         //start iterating the tree of relationships</p><p>         affectedGroups = findUpstream(req.cmdb_ci, 1, affectedGroups);</p><p>         </p><p>         //count affected users and groups along the way and write that back into the request</p><p>         if (! isEmpty(affectedGroups)) {</p><p>                   gs.log("Preparing to update Change request with affected user info.........................................................");</p><p>                   var userTotal = 0;</p><p>                   req.u_affected_users+='The following user groups will be affected by this change request:\n\nGroup\t\tUserCount\n====================\n';</p><p>                   for (var key in affectedGroups) {</p><p>                             gs.log(key+'='+affectedGroups[key]);</p><p>                             req.u_affected_users += key+'\t\t'+affectedGroups[key]+"\n";</p><p>                             userTotal += affectedGroups[key];</p><p>                   }</p><p>                   req.u_affected_users += "----------------------------------------\nTotal\t\t\t"+userTotal;</p><p>                   req.update();</p><p>         }                             </p><p>}</p><p></p><p></p><p>//ServiceNow doesn't support ECMA5 so need this function to be sure the object is not empty</p><p>function isEmpty(obj) {</p><p>         // null and undefined are "empty"</p><p>         if (obj == null) return true;</p><p>         // Assume if it has a length property with a non-zero value</p><p>         // that that property is correct.</p><p>         if (obj.length &gt; 0)       return false;</p><p>         if (obj.length === 0)   return true;</p><p>         // Otherwise, does it have any properties of its own?</p><p>         // Note that this doesn't handle</p><p>         // toString and valueOf enumeration bugs in IE &lt; 9</p><p>         for (var key in obj) {</p><p>                   if (hasOwnProperty.call(obj, key)) return false;</p><p>         }</p><p>         return true;</p><p>}</p><p></p><p></p><p>// find the related items of the affected item</p><p>function findUpstream(itemSysID, depth, affectedGroups) {</p><p>         //only go to a certain depth       </p><p>         if (depth &lt; depthLim) {</p><p>                   //get all the glide records of the related items</p><p>                   var rel = new GlideRecord('cmdb_rel_ci');</p><p>                   rel.addQuery('child', itemSysID);</p><p>                   rel.query();</p><p>                   while (rel.next()) {</p><p>                             //the parent value of the glide record is the actual related CI sys_id so use that to get the actual CI object</p><p>                             affectedGroups = processCI(getCI(rel.parent), depth, affectedGroups);</p><p>                             //iterate the tree</p><p>                             affectedGroups = findUpstream(rel.parent, depth + 1, affectedGroups);</p><p>                   }                                       </p><p>         }</p><p>         return affectedGroups;</p><p>}</p><p></p><p></p><p>//gets the ci record from a sys_id</p><p>function getCI(itemSysID) {</p><p>         var ci = new GlideRecord('cmdb_ci');</p><p>         ci.get(itemSysID);</p><p>         return ci;</p><p>}</p><p></p><p></p><p>function processCI(ci, depth, affectedGroups) {</p><p>         logFields(ci, depth);</p><p>         //check for a u_user_group. Note the ref_ notation that allows to get the field from the extended table that is not present in the base table</p><p>         var userGroup = ci.ref_cmdb_ci_appl.u_user_group;</p><p>         if (userGroup) {</p><p>                   var userGroupName = userGroup.getDisplayValue();</p><p>                   gs.log('Found user group: ' + userGroupName);</p><p>                   //add it to the affected groups with count as long as not exists already</p><p>                   if(affectedGroups[userGroupName]   === undefined) {</p><p>                             var members = new GlideRecord('sys_user_grmember');</p><p>                             members.addQuery('group', userGroup);</p><p>                             members.query();</p><p>                             affectedGroups[userGroupName] = members.getRowCount();</p><p>                   }</p><p>         }</p><p>         return affectedGroups;</p><p>}</p><p></p><p></p><p>function logFields(ci, depth) {</p><p>         var tabs = '       ';</p><p>         for (i = 0; i &lt; depth; i++) {</p><p>                   tabs += tabs;</p><p>         }</p><p>         if(gs) {</p><p>                   gs.addInfoMessage('==========================================');</p><p>                   gs.addInfoMessage(rootStr);</p><p>                   gs.addInfoMessage(tabs + 'Configuration Item: ' + ci.getDisplayValue());</p><p>         } else {</p><p>                   log.info( 'Configuration Item: ' + ci.getDisplayValue());</p><p>         }</p><p>         //get all the fields and print them</p><p>         var fields = ci.getFields();</p><p>         if(gs) {</p><p>                   gs.addInfoMessage(tabs + 'Field values:');</p><p>         } </p><p>         for (var i = 0; i &lt; fields.size(); i++) {</p><p>                   var glideElement = fields.get(i);</p><p>                   if (glideElement.hasValue()) {</p><p>                             if(gs) {</p><p>                                       gs.addInfoMessage(tabs + glideElement.getName() + ':               ' + glideElement);</p><p>                             } else {</p><p>                                       log.info(glideElement.getName() + ':               ' + glideElement);</p><p>                             }</p><p>                   }</p><p>         }</p><p>         </p><p>}</p>