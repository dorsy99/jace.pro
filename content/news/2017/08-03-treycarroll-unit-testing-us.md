---
title: "Unit Testing using mocks"
date: 2017-08-02T08:25:25.000Z
authors: ["treycarroll"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=ed6dea29dbd0dbc01dcaf3231f96190f"
---
<p>I know that we're all excited to start using the Automated Test Framework, but there is still a place for unit testing in ServiceNow development.   Specifically, verifying the correctness of functions in Script Includes is worthwhile.   (And a must for any team following a Test-Driven Development methodology such as XP.)</p><p></p><p>Unit Testing involves verifying the correctness of the implementation of a function by crafting inputs and validating outputs.     Take a simple example:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15016397678223470 jive_text_macro" data-renderedposition="102.4000015258789_8_1178_176" jivemacro_uid="_15016397678223470"><p>var Calculator = Class.create();</p><p>Calculator.prototype = {</p><p>       initialize: function() {</p><p>       },</p><p></p><p>       sum: function(addend1, addend2){</p><p>               return addend1 + addend2;</p><p>       },</p><p></p><p>       type: 'Calculator'</p><p>};</p></pre><p></p><p>How would we verify that the implementation of the sum function is correct?     Here is a simple unit test for the sum function:</p><p></p><p>Fix script to verify that sum function correctly adds 2 positive numbers:</p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_1501640427567931" data-renderedposition="361.6000061035156_8_1178_256" jivemacro_uid="_1501640427567931"><p>// Arrange </p><p>var calc = new Calculator();</p><p>var parameter1 = 2;</p><p>var parameter2 = 2;</p><p>var expectedResult = 4;</p><p></p><p>//Act</p><p>var actualResult = calc.sum(parameter1, parameter2);</p><p></p><p>//Assert</p><p>gs.print("Two + Two should equal Four.")</p><p>if(actualResult == expectedResult){</p><p>     gs.print("Pass");</p><p>} else{ </p><p>     gs.print("Fail");</p><p>}</p></pre><p></p><p>We could add more tests for further cases e.g. adding two negative numbers, one positive and one negative number, adding with a zero parameter, etc.   Just in case you think that this example is so simple that nothing could go wrong, consider what would happen if we did the following:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15016406373617360 jive_text_macro" data-renderedposition="700.7999877929688_8_1178_16" jivemacro_uid="_15016406373617360"><p>var actualResult = calc.sum("2", "2");</p></pre><p></p><p>Failing tests cause us to think more deeply, and often to refactor our implementation and to reconsider our design "contract".     We might add code to check the types of our parameters and specify preconditions regarding expectations.   We might specify that the function throw a particular kind of exception when those conditions are not met.   In this case, it makes sense to add a precondition that both parameters must be of type number.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15016822975917807 jive_text_macro" data-renderedposition="820.7999877929688_8_1178_272" jivemacro_uid="_15016822975917807"><p>var Calculator = Class.create();</p><p>Calculator.prototype = {</p><p>       initialize: function() {</p><p>       },</p><p></p><p>       sum: function(addend1, addend2){</p><p>               var addendOneType = typeof addend1;</p><p>               var addendTwoType = typeof addend2;</p><p>                 if( addendOneType == 'number'   &amp;&amp; addendTwoType == 'number' ) {</p><p>                         return addend1 + addend2;</p><p>               } else {</p><p>                       throw "Exception: both parameters of sum function must be numbers.   Param1 type:" + addendOneType + " Param2 type: " + addendTwoType;</p><p>                 }</p><p>       },</p><p></p><p>       type: 'Calculator'</p><p>};</p></pre><p></p><p>Now we add an additional test to ensure that we throw an error for non-numeric parameters:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15016819270107158 jive_text_macro" data-renderedposition="1155.2000732421875_8_1178_320" jivemacro_uid="_15016819270107158"><p>// Arrange </p><p>var calc = new Calculator();</p><p>var parameter1 = "2";</p><p>var parameter2 = 2;</p><p>var expectedResult = "Exception";</p><p></p><p>//Act</p><p>try{</p><p>     var actualResult = calc.sum(parameter1, parameter2);</p><p>} catch(e){</p><p>     actualResult = "Exception:"+ e.message;</p><p>}</p><p></p><p>//Assert</p><p>gs.print("String Two + number Two should throw an Exception.")</p><p>if(actualResult.indexOf(expectedResult) &gt; -1){ //The string "Exception" was found in the actual result.</p><p>       gs.print("Pass");</p><p> } else { </p><p>       gs.print("Fail");</p><p>}</p></pre><p></p><p>But realistically, most of our Script Includes are going to perform calculations and operations based on GlideRecord inputs.   How could we unit test such functions?</p><p></p><p>In order to facilitate Unit Testing we use a design pattern called Dependency Injection (DI) or Inversion of Control (IOC).   This means that where our function needs an object as an input for an operation, that object should be passed in as a parameter instead of instantiating it directly in the function.   Let's take a look:</p><p></p><p>This implementation does not use DI/IOC, does not facilitate testability:</p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15016415132262627 jive_text_macro" data-renderedposition="1620.800048828125_8_1178_240" jivemacro_uid="_15016415132262627"><p>var u_Example = Class.create();</p><p>   u_Example.prototype = {</p><p>   initialize: function() {</p><p>   },</p><p></p><p>   sameLastName:function(userId1, userId2){</p><p>         var grUser1 = new GlideRecord("sys_user");</p><p>         var grUser2 = new GlideRecord("sys_user");</p><p>         if (grUser1.get(userId1) &amp;&amp; grUser2.get(userId2) ) {</p><p>                 return grUser1.last_name == grUser2.last_name;</p><p>         }</p><p>   },</p><p></p><p>type: 'u_Example'</p><p>};</p></pre><p></p><p>This implementation of sameLastName passes in the GlideRecords, following the DI/IOC pattern:</p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_15016417259088794" data-renderedposition="1902.4000244140625_8_1178_48" jivemacro_uid="_15016417259088794"><p>sameLastName:function(grUser1, grUser2){</p><p>       return grUser1.last_name == grUser2.last_name;</p><p>},</p></pre><p></p><p>Of course we could "new up" a couple of actual GlideRecords pointing to a real user record for our test, but using mocks is more convenient (and makes the test lightning fast since it doesn't involve actually going to the database).</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_15016421037585091" data-renderedposition="2033.5999755859375_8_1178_320" jivemacro_uid="_15016421037585091"><p>// Arrange </p><p>var obj = new u_Example();</p><p>var mockUser1 = {</p><p>     last_name:"Smith"</p><p>};</p><p>var mockUser2 = {</p><p>     last_name:"Patel"</p><p>};</p><p>var expectedResult = false;</p><p></p><p>//Act</p><p>var actualResult = obj.sameLastName(mockUser1, mockUser2);</p><p></p><p>//Assert</p><p>gs.print("sameLastName() should return false when passed Smith and Patel.");</p><p>if(actualResult == expectedResult){</p><p>     gs.print("Pass");</p><p>} else{ </p><p>     gs.print("Fail");</p><p>}</p></pre><p></p><p>But, in practice, Script Includes often involve accessing nested properties from GlideRecords for tables with reference fields.   Can mocks address such complexity?   Absolutely.   Consider the following mock that starts with a sysapproval_approver record:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_15016423905605989 jive_macro_code jive_text_macro" data-renderedposition="2436.800048828125_8_1178_208" jivemacro_uid="_15016423905605989"><p>//This is a real-world mock that I use to test a Script Include that supports a Business Rule on the sysapproval_approver table</p><p>var mock1 = {</p><p>   approver:'e5aadc386f319500b8d923fc5d3ee406',</p><p>   sysapproval:{</p><p>         cat_item:{</p><p>             u_approval_escalation:false,</p><p>             u_allow_requestor_approval: true</p><p>         },</p><p>       sys_class_name:'sc_req_item',</p><p>       u_requested_for:'e5aadc386f319500b8d923fc5d3ee406',</p><p>       toString: function(){return 'c9ba4b4f1385b600febc79d96144b0de';}</p><p>   },</p><p>};</p></pre><p></p><p>You may notice that these can get somewhat complex.     As the object's property tree grows, it becomes more difficult to do a quick visual inspection to confirm correctness.   After spending too much time trouble-shooting small mistakes on my mocks, I decided that I needed to make mock-building faster and less error-prone.   That was the impetus behind the creation of this helper class:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15016429505746129 jive_text_macro" data-renderedposition="2748.800048828125_8_1178_1904" jivemacro_uid="_15016429505746129" modifiedtitle="true"><p>var GMF_MockBuilder = Class.create();</p><p>GMF_MockBuilder.prototype = {</p><p>initialize: function() {</p><p>},</p><p></p><p>// @param table is the name of the table</p><p>// @param aryFields is an array of objects where the properties are:</p><p>// For a simple field type</p><p>//       1) a fieldName key   (string)</p><p>//       2) a fieldValue key (string) </p><p>// For reference-type fields</p><p>//       1) a fieldName key (string)</p><p>//       2) a ref key (boolean)</p><p>//       3) a table key (string) - the referenced table name</p><p>//       4) a fieldsArray key - (array) - the fields to add from the referenced table.   Works recursively for nested tables.</p><p>make: function(table, aryFields ){</p><p>         var mock = {};</p><p>         try{</p><p></p><p>         //loop over all of the field in the field array param</p><p>         for (var k=0; k &lt; aryFields.length; k++) {</p><p></p><p>         var fieldName = aryFields[k].fieldName;</p><p></p><p>         var fieldValue = aryFields[k].fieldValue;</p><p></p><p>         // look for a column entry for that field name in the sys_dictionary table</p><p>         var gr = new GlideRecord("sys_dictionary");</p><p>         gr.addQuery("name", table);</p><p>         gr.addQuery("element", fieldName);</p><p>         gr.query();</p><p>         if ( gr.next() ) {                   </p><p>                   var addReference = aryFields[k].addReference;</p><p>                   if( addReference == true) {</p><p>                             if(gr['internal_type'] == 'reference'){</p><p>                                       mock[fieldName] = this.make(aryFields[k].table, aryFields[k].fieldsArray);</p><p>                             } else {</p><p>                                       throw "Error creating mock object.   Marked non-reference field as reference type: " + fieldName ;</p><p>                             }</p><p>                   } else {</p><p>                             mock[fieldName] = fieldValue;</p><p>                   }</p><p>                   if(gr.display == true){</p><p>                             mock.toString = function(){ return fieldValue + '';};</p><p>                   }</p><p>         } else {</p><p>                   throw "Error creating mock object.   Field " + fieldName + " does not exist.";</p><p>         }</p><p>         }</p><p></p><p>   } catch(e) {</p><p>         if(gs.hasRole('admin')){</p><p>                   gs.addErrorMessage(e.message);</p><p>         }</p><p>         gs.logError(e.message, 'SI: GMF_MockBuilder');</p><p>}</p><p> return mock;</p><p>},</p><p></p><p>//@param table is the name of the table</p><p>//@param sys_id is the id for the record we want to start pulling values from</p><p>//@param fields array is an array of objects where the keys are</p><p>// For non-reference-type fields:</p><p>//       1) a fieldName key (string)</p><p>// For reference-type fields:</p><p>//       1) a fieldName key (string)</p><p>//       2) a ref key (boolean)   - Always true when present. Marks the field as a reference which should be followed.</p><p>//       3) a fieldsArray key (array) - A nested fieldsArray for the fields we want to pick up off of the referenced record.</p><p>makeFromRecord: function( table, sys_id, fieldsArray ){</p><p>         gs.print('In makeFromRecord table:' + table + 'sys_id:'+sys_id + ' fieldsArray:'+fieldsArray.toString());</p><p></p><p>         var mock =   {};</p><p>         //Look up the record in question</p><p>         var grRec = new GlideRecord(table);</p><p>         if ( grRec.get(sys_id) ) {</p><p>                   var actualTableName = grRec.sys_class_name || table;</p><p>         </p><p>                   //If this table has extending tables, go down to the real table and re-fetch the record.   (necessary to get child-specific fields)</p><p>                   if(new TableUtils(table).hasExtensions()){</p><p>                             grRec = new GlideRecord(actualTableName);</p><p>                             grRec.get(sys_id);</p><p>                   }</p><p>                   //Loop over the fieldsArray</p><p>                   for ( var i=0; i&lt; fieldsArray.length; i++ ) {</p><p>                             var fieldName = fieldsArray[i].fieldName;</p><p>                             var followReference = fieldsArray[i].ref;</p><p></p><p>                             //Reference type field.   Recursively add child objects</p><p>                             if( followReference == true ){</p><p>                                       var grDict = new GlideRecord("sys_dictionary");</p><p>                                       grDict.addQuery("name", actualTableName);</p><p>                                       grDict.addQuery("element", fieldName);</p><p>                                       grDict.addQuery("internal_type", 'reference');</p><p>                                       grDict.query();</p><p>                                       if (grDict.next()) {</p><p>                                                 var referencedTable = grDict.reference;</p><p>                                                 var referencedRecId = grRec[fieldName].sys_id;</p><p></p><p>                                                 mock[fieldName] = this.makeFromRecord(referencedTable, referencedRecId, fieldsArray[i].fieldsArray);                                               </p><p>                                       } else {</p><p>                                                 throw "Could not find dictionary entry for reference field:" + fieldName + " for table " + actualTableName;</p><p>                                       }</p><p>                               } else { // Non-reference field.</p><p>                                       if( grRec.getValue(fieldName+'')){</p><p>                                                 mock[fieldName] = grRec.getValue(fieldName+'');</p><p>                                       } else {</p><p>                                                 throw "Attempted to add bad field name. Table: " + table + '|' + sys_id + " Field:" + fieldName;</p><p>                                       }</p><p>                               }</p><p>                   }<span style="color: rgba(0, 0, 0, 0); font-family: Consolas, 'Courier New', Courier, mono, serif; font-size: 12px;">//for</span></p><p>         } else {</p><p>                   throw "Could not locate record in table:" + table + " with id:" + sys_id;</p><p>         }</p><p>         return mock;</p><p>         },</p><p></p><p></p><p>         type: 'GMF_MockBuilder'</p><p>};</p></pre><p></p><p>The make() function is for building your own record field by field (including inserting field values manually).   It has the advantage of checking your properties against the actual dictionary record to make sure that it exists.   (Those types of errors can be enormous time wasters.)</p><p></p><p>Here is an example of the use of the make() function:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_15016436691589154" data-renderedposition="4777.60009765625_8_1178_448" jivemacro_uid="_15016436691589154"><p>var fieldsArray = [];</p><p>fieldsArray.push({</p><p>         fieldName:'first_name',</p><p>         fieldValue:'Fred'</p><p>});</p><p>fieldsArray.push({</p><p>         fieldName:'last_name',</p><p>         fieldValue:'Smith'</p><p>});</p><p>fieldsArray.push({</p><p>         fieldName:'manager',</p><p>         addReference: true,</p><p>         table:'sys_user',</p><p>         fieldsArray:[{</p><p>                   fieldName:'first_name',</p><p>                   fieldValue:'Jeff'</p><p>         }]</p><p>});</p><p>fieldsArray.push({</p><p>         fieldName:'location',</p><p>         addReference: true,</p><p>         table:'cmn_location',</p><p>         fieldsArray:[{</p><p>                   fieldName:'name',</p><p>                   fieldValue:'Philadelphia - 711'</p><p>         }]</p><p>});</p><p>var mock = new GMF_MockBuilder().make('sys_user', fieldsArray);</p></pre><p></p><p>By contrast, the makeFromRecord() function pulls the values from real records found in the database.   You just supply the field names and whether or not the field is a reference that will need to be followed to further fields for the mock.</p><p></p><p>Here is an example of the use of the makeFromRecord() function:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15016438145398693 jive_text_macro" data-renderedposition="5350.39990234375_8_1178_208" jivemacro_uid="_15016438145398693"><p>var fieldsArray2 = [];</p><p>fieldsArray2.push({fieldName:'approver'});</p><p>// The object has nested fieldArray objects when following reference fields</p><p>fieldsArray2.push({ fieldName:'sysapproval', ref:true, fieldsArray:[</p><p>     {fieldName:'sys_class_name'}, </p><p>     {fieldName:'u_requested_for'}, </p><p>     {fieldName:'cat_item', ref:true, fieldsArray:[</p><p>               {fieldName:'u_allow_requestor_approval'},</p><p>               {fieldName:'u_approval_escalation'}</p><p>     ]}</p><p>]});</p><p>//"Feed" the function the table name and id of a record, then use the fieldsArray parameter to tell it which fields to add to the mock, including fields on referenced fields.</p><p>var mock2 = new GMF_MockBuilder().makeFromRecord('sysapproval_approver', 'd7edc38713c57a00c90132228144b0cc', fieldsArray2);</p></pre><p></p><p>All you have to do is point makeFromRecord() at a particular record and it will build out your object pulling in the values even from nested references.   That's pretty cool.</p><p></p><p>I sometimes print these out in a fix script and then copy them into my actual test script.     If you're using makeFromRecord() in a sub-prod instance (where a clone can wipe out your records), or if your team-mates might monkey with your test fixtures you should do this:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_15016439638816056" data-renderedposition="5683.2001953125_8_1178_16" jivemacro_uid="_15016439638816056"><p>gs.print( new global.JSON().encode(mock) );</p></pre><p></p><p>The copied and pasted result would look something like this:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_15016440891943865" data-renderedposition="5761.60009765625_8_1178_16" jivemacro_uid="_15016440891943865"><p>var persistentMock = {"approver":"e5aadc386f319500b8d923fc5d3ee406","sysapproval":{"cat_item":{"u_allow_requestor_approval":"1","u_approval_escalation":"0"},"sys_class_name":"sc_req_item","u_requested_for":"faba90786f319500b8d923fc5d3ee453"}};</p></pre><p></p><p>Notice that JSON.encode uses zeros and ones instead of trues and falses.   As long as your code treats the values in a boolean expression they will work fine.</p>