---
title: "Nested GlideRecords Are Killing Your App Performance"
date: 2017-01-19T02:00:16.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=557c62e1dbd0dbc01dcaf3231f96191d"
---
<p>Via: <a title="odecreative.io/servicenow/nested-gliderecords-are-killing-your-app-performance" href="https://codecreative.io/servicenow/nested-gliderecords-are-killing-your-app-performance">Code Creative</a></p><p></p><p>In a troubleshooting conversation with a couple of my teammates, I realized that I take GlideRecord (and its partner GlideAggregate) for granted.   When you make that simple gr.query() call, what happens?   What SQL does it run?   What does the real underlying table structure look like?   Are there indexes?   Are additional queries run when you dot walk?   Does any of this hit a cache?   How does the cache work?   Where are the optimizations under the hood?</p><p></p><p>The truth is, most of us have no idea what happens and most of the time that is really awesome!   If the queries run fast and returns accurate data we usually don't care how ServiceNow made it happen.</p><p></p><p>But when performance issues start to pile up on that scripted REST endpoint and all you're doing is generating JSON from GlideRecords... well, what you don't know could be killing your instance.   The <strong>Nested GlideRecord</strong> silently drags down your app's response times, killing usability and the first step to fix it is to learn how to identify it.</p><p></p><h2>The Basic Pattern</h2><p></p><p>A Nested GlideRecord is when you run a GlideRecord query within the while loop of another GlideRecord query, like this:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14847693052902791 jive_text_macro" data-renderedposition="354_8_1116_144" jivemacro_uid="_14847693052902791"><code>var gr1 = new GlideRecord('any_table');<br/>gr1.query();<br/>while (gr1.next()) {<br/>   var gr2 = new GlideRecord('any_table');<br/>   gr2.query();<br/>   while (gr2.next()) {<br/>     // Do something here<br/>   }<br/>}</code></pre><p></p><p>Now, take a look at that script.   How many times does that script query the database?   The correct answer:   I have no idea and neither do you.   We don't know how GlideRecord works exactly.   What we do know is that in the worst case it will run one query for gr1.query() and an additional query for each record in gr1 (gr2.query() inside the while loop).</p><p></p><p>The defining feature of this performance killer is using many smaller queries when one larger query could retrieve the same data.</p><p></p><h2>A Crude Scenario</h2><p></p><p>So lets take a look at a somewhat real world script to get an idea of why this is such a problem.   Lets try to find and output a list of duplicate user records.   We'll keep it simple and assume the first record found is the original.   To do this, we need to:</p><p></p><ol><li>Get a list of usernames with a count greater than 0</li><li>Find all user records with those usernames</li><li>Update all but the first with a duplicate flag</li></ol><p></p><p>For this test, I will compare 2 approaches:   Nested GlideRecord and an Array Flattened GlideRecord.</p><p>Here is a crude Nested GlideRecord approach:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14847693887869387 jive_text_macro" data-renderedposition="896.1875_8_1116_256" jivemacro_uid="_14847693887869387"><code>var count = new GlideAggregate('sys_user');<br/>count.addQuery('email', '!=', '');<br/>count.groupBy('email');<br/>count.addAggregate('COUNT');<br/>count.query();<br/>while (count.next()) {<br/>   if ((count.getAggregate('COUNT') * 1) &gt; 0) {<br/>     var user = new GlideRecord('sys_user');<br/>   user.addQuery('email', count.email + '');<br/>   user.query();<br/>   user.next(); // skip the first<br/>     while (user.next()) {<br/>   gs.print(user.sys_id);<br/>     }<br/>   }<br/>}</code></pre><p></p><p>And the Array Flattened GlideRecord:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_14847694369537671 jive_macro_code jive_text_macro" data-renderedposition="1215.1875_8_1116_400" jivemacro_uid="_14847694369537671"><code>var users = [];<br/><br/>var count = new GlideAggregate('sys_user');<br/>count.addQuery('email', '!=', '');<br/>count.groupBy('email');<br/>count.addAggregate('COUNT');<br/>count.query();<br/>while (count.next()) {<br/>   if ((count.getAggregate('COUNT') * 1) &gt; 0) {<br/>   users.push(count.email + '');<br/>   }<br/>}<br/><br/>var user = new GlideRecord('sys_user');<br/>var prevUser = '';<br/>user.addQuery('email', 'IN', users.join(','));<br/>user.orderBy('email');<br/>user.query();<br/>while (user.next()) {<br/>   if (prevUser == user.email + '') {<br/>   gs.print(user.email);<br/>   }<br/>   // Else, skip the original user<br/>   prevUser = user.email + '';<br/>}</code></pre><p></p><p>Running these two scripts in the background, I was able to achieve some poor man's stats after a few manual runs with 1144 user records and 572 duplicates:</p><p></p><ul><li>Nested GlideRecord: ~0.795 seconds to execute</li><li>Array Flattened GlideRecord: ~0.145 seconds to execute</li></ul><p></p><p>Now this is a pretty extreme example that will more likely be executed as background script or scheduled job rather than a user facing transaction.   But that performance difference between the nested and flattened scripts starts to add up when multiplied by the number of users hitting your site and the depth and frequency of nested GlideRecords in your scripts.   Pretty soon, you might find your database running a query every 60 seconds (yep, that actually happened on a different client).</p><p></p><h2>Dot Walking Has The Same Results</h2><p></p><p>The scary part about this pattern is that it easily hides itself.   Dot walking, for example, works like magic to retrieve related data.   Under the hood, it runs a query at least once to retrieve the reference (I assume the reference is cached for subsequent calls in a given script if not the entire transaction but I'm not sure).</p><p></p><p>So the following script could inadvertently cause the same issue as the previous example (and in the originally mentioned REST script, I believe this was a contributing factor):</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_14847695274306556 jive_macro_code jive_text_macro" data-renderedposition="1989.578125_8_1116_80" jivemacro_uid="_14847695274306556"><code>var gr = new GlideRecord('sys_user');<br/>gr.query();<br/>while (gr.next()) {<br/>   var department = gr.department.name; // Reference Field!<br/>}</code></pre><p></p><p>That Department is a reference field, so ServiceNow has to run a separate GlideRecord query behind the scenes to retrieve the data for that department.   All magic comes at a price, deary!</p><p></p><h2>Or How About ACL's</h2><p></p><p>Running a GlideRecord query in an ACL yields the same effect.   In this case, its subtle but still there.   If you run a query on the incident table for example, an ACL will be applied to (and the script run for) each record in the resulting set.   For each and every record in your resulting set, a narrowly defined GlideRecord query will execute to find out if the user can see the record!   (This by the way was one of the primary causes behind the 60 second queries).</p><p></p><h2>Bottom Line</h2><p></p><p>Here's the too long didn't read:   Avoid using 20 narrowly defined GlideRecords when with a little work you can combine it into a single broader GlideRecord.   Watch out for the same pattern in ACLs, dot walking, and other ServiceNow scripts.   This pattern likes to hide itself.   Another time, we'll take a look at some strategies to fix this.</p>