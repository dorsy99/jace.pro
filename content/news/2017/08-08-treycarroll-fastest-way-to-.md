---
title: "Fastest way to find out if there is at least one result"
date: 2017-08-07T19:09:32.000Z
authors: ["treycarroll"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=a2bc2e25dbd0dbc01dcaf3231f9619df"
---
<p>A workflow should not be allowed to start until there is at least one supporting task in a related list.</p><p>A Major Incident should not be allowed to close if there is not at least on VIP on the watchlist.</p><p>A notification should fire if there is not at least one active user in a group.</p><p></p><p>We often find ourselves given requirements that mean we need to find out if there is at least one record that matches a condition.   But there are several ways to accomplish this.</p><p></p><p>You may have already heard that gs.getRowCount() is inferior due to the fact that it iterates the entire record set in order to count the elements.     But writing the code for the Aggregate is just more verbose, and therefore more effort.</p><p></p><p>Consider</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_15021132683307781" data-renderedposition="236.8000030517578_8_1192_128" jivemacro_uid="_15021132683307781"><p>function getRowCount(){</p><p>         var gr = new GlideRecord("sys_user");</p><p>         gr.addQuery("active", "true");</p><p>         gr.query();</p><p>         if(gr.getRowCount() &gt; 0){</p><p>                   // Do something awesome</p><p>         }</p><p>}</p></pre><p></p><p>Versus</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15021132743435355 jive_text_macro" data-renderedposition="427.20001220703125_8_1192_160" jivemacro_uid="_15021132743435355"><p>function getAggregateCount(){</p><p>         var gr = new GlideAggregate('sys_user');</p><p>         gr.addAggregate('COUNT');</p><p>         gr.addQuery('active', 'true');</p><p>         gr.query();</p><p></p><p>         if (gr.next() &amp;&amp; gr.getAggregate('COUNT') &gt; 0)   {</p><p>                   // Do something awesome faster</p><p>         }</p><p>}</p></pre><p></p><p>How much faster is the aggregate method?</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15021135266456757 jive_text_macro" data-renderedposition="649.6000366210938_8_1192_208" jivemacro_uid="_15021135266456757"><p>howLong(getRowCount);</p><p>howLong(getAggregateCount);</p><p></p><p>function howLong(func){</p><p>         var cal1 = Packages.java.util.Calendar.getInstance();</p><p>         var startMillis = cal1.getTimeInMillis();</p><p></p><p>         func.call();</p><p></p><p>         var cal2 = Packages.java.util.Calendar.getInstance();</p><p>         var endMillis = cal2.getTimeInMillis();</p><p>         gs.print('Millis for Query:'+(endMillis - startMillis ));</p><p>}</p></pre><p></p><p></p><p><img   alt="Efficiency 1.png" class="image-1 jive-image" src="cab86775dbd41fc068c1fb651f9619b8.iix" style="height: auto;"/></p><p></p><p>The GlideAggregate gets the job done in almost 1/4 of the time.   Wow.   That's compelling.   We really ought to use the GlideAggregate COUNT over getRowCount().</p><p></p><p><span style="color: #eb7a3d;">Just watch out for one thing:   You have to call next() in order for getAggregate('COUNT') to work!</span></p><p></p><p>However, this got me thinking.     By writing these conditions...</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15021139532957347 jive_text_macro" data-renderedposition="1276_8_1192_48" jivemacro_uid="_15021139532957347"><p>if ( gs.getRowCount() &gt; 0 ) { }</p><p>//OR </p><p>if (gr.next() &amp;&amp; gr.getAggregate('COUNT') &gt; 0)   { }</p></pre><p></p><p>We're really on trying to figure out if there is at least one row — right?</p><p></p><p>So, what about counting the rows after limiting the result set to a single row.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15021140636406804 jive_text_macro" data-renderedposition="1428_8_1192_144" jivemacro_uid="_15021140636406804"><p>function getOneRow(){</p><p>         var gr = new GlideRecord("sys_user");</p><p>         gr.addQuery("active", "true");</p><p>         gr.setLimit(1);</p><p>         gr.query();</p><p>         if(gr.getRowCount() &gt; 0){</p><p>                   // Do something awesome at blinding speed</p><p>         }</p><p>}</p></pre><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_15021141325558752 jive_macro_code jive_text_macro" data-renderedposition="1592.800048828125_8_1192_32" jivemacro_uid="_15021141325558752"><p>//Drum roll please</p><p>howLong(getOneRow);</p></pre><p></p><p><img   alt="Efficiency 2.png" class="image-2 jive-image" src="10d05102dbd4130468c1fb651f9619ea.iix" style="height: auto;"/></p><p></p><p>So that's 1/11th of the time that it took without the setLimit(1) statement.     But, surprisingly, it beat the getAggregate('COUNT') method by a factor of 3.</p><p></p><p>Another factor to consider is that for this example performance has been measured using the sys_user table, which has relatively few entries.   Execution time for getRowCount() is going to grow proportionally with the number of results; so performance using getRowCount() with a table with a large number of records is going to be much worse.</p><p></p><p>So the next time I need you need know if there is at least one record that matches a particular condition, try using getRowCount() with a setLimit(1) statement.</p><p></p><p><a title="ctomasi" __default_attr="2218" __jive_macro_name="user" _jive_internal="true" class="jive_macro jive_macro_user" data-orig-content="ctomasi" data-renderedposition="2046.4000244140625_8_66_16" href="/community?id=community_user_profile&user=7ae05a61db981fc09c9ffb651f9619a2">ctomasi</a> Thanks for challenging me on that sloppy answer.     <span __jive_emoticon_name="happy" __jive_macro_name="emoticon" class="jive_emote jive_macro" data-renderedposition="2043.2000732421875_397.57501220703125_16_16" src="/8.0.4.21bdc7e/images/emoticons/happy.png"></span></p><p></p><p>Now my question to any MSSQL database gurus out there:     What are the database impacts of each of these approaches?       I wouldn't want to count something as a performance win if it was just pushing the work into the database where it was still a performance bottleneck for the instance!</p>