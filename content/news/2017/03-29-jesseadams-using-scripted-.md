---
title: "Using scripted search sources to search external websites and applications"
date: 2017-03-28T05:09:50.000Z
authors: ["jesseadams"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=a3fde62ddbd0dbc01dcaf3231f961989"
---
<p>In my previous post, I introduced you to <a title="" _jive_internal="true" href="/community?id=community_blog&sys_id=de5ce6a1dbd0dbc01dcaf3231f96194a">Search Sources in Service Portal</a>. Search Sources are new to Istanbul in the Service Portal application. We talked about the components that make a search source work and walked through the basics of configuring a search source for a portal. In this post we're going to look at scripted search sources and learn how to use them to search an external application or website from inside your portal. This is a very powerful feature because it can allow you to create a single portal. Users can visit the portal to look for answers from any resource used by your organization that you have access to via a REST api.</p><p></p><h1>Script Search Sources to search external websites and apps</h1><p>To enable Search Sources to crawl external sites, you'll need to have read <a title="" _jive_internal="true" href="/community?id=community_blog&sys_id=de5ce6a1dbd0dbc01dcaf3231f96194a">part 1</a> so that you're up to speed on the basics. You'll also need some external resource that you have access to via REST, basic knowledge of <a title="ngularjs.org/" href="https://angularjs.org/">AngularJS</a>, and an understanding of <a title="ocs.servicenow.com/bundle/istanbul-servicenow-platform/page/build/service-portal/concept/c_WidgetCreation.html" href="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/build/service-portal/concept/c_WidgetCreation.html">creating pages and widgets in Service Portal</a>.</p><p></p><p>Now, we're going to be doing some custom scripting here so it is important to note that this is not a solution that is officially supported by ServiceNow. My goal with this post is to provide an example to help you get started in creating your own search sources and to share some of the things I learned while configuring one of these in my own instance. This is not intended to be a solution to all your searching needs, just a springboard into your quest to find the solution to all of your searching needs.</p><pre __default_attr="danger" __jive_macro_name="alert" alert="danger" class="jive_text_macro jive_macro_alert" data-renderedposition="278.3522644042969_7.997159004211426_1134_43"><p>I repeat, this customization is <strong>not</strong> officially supported by ServiceNow</p></pre><p>There are a couple of questions we need to ask before we begin:</p><ol><li>Do we want to link to the external content in its native application/site? Or do we want to bring the content in and display it in ServiceNow?</li><li>Where are we pulling the data from?</li></ol><p></p><p>For our example, we're going to search the knowledge base from another ServiceNow instance and display it inside our portal as if it were native content.</p><p></p><p>The first steps here are really the same as what we did in part 1. The big differences between what we did in part 1 and what we are doing in part 2, is the search page template, the data fetch script, and the page and widget that will display our external content.</p><p></p><h2>Obtain the data that the search source will crawl</h2><p>Let's start with the data fetch script. Once you click the "Is scripted source" checkbox on the search source form this field is displayed. This is where you'll setup the search request for your external site. For this example, we're going to use the ServiceNow <a title="ocs.servicenow.com/bundle/istanbul-servicenow-platform/page/integrate/inbound-rest/concept/c_TableAPI.html" href="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/integrate/inbound-rest/concept/c_TableAPI.html">table api</a>. This part will vary greatly depending on the application you're querying.</p><p></p><p>We'll start from this basic template and add in the necessary fields as we go:</p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14903806393485016 jive_text_macro" data-renderedposition="645.2840576171875_7.997159004211426_1134_77" jivemacro_uid="_14903806393485016"><p>(function(query) {</p><p>   var results = [];</p><p>   /* Calculate your results here. */</p><p>   return results;</p><p>})(query);</p></pre><p></p><p>This defines the search function that is executed by the instance. In order for this to work we'll need the URL for our request endpoint, and a sn_ws.RESTMessage object. I'm using a <a title="ocs.servicenow.com/bundle/istanbul-servicenow-platform/page/app-store/dev_portal/API_reference/RESTMessageV2/reference/r_RecordlessRESTMessageV2Example.html" href="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/app-store/dev_portal/API_reference/RESTMessageV2/reference/r_RecordlessRESTMessageV2Example.html">recordless REST message</a> but this could be modified to use a pre-configured <a title="ocs.servicenow.com/bundle/istanbul-servicenow-platform/page/integrate/outbound-rest/concept/c_OutboundRESTWebService.html" href="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/integrate/outbound-rest/concept/c_OutboundRESTWebService.html">outbound REST message</a> record if needed. Setting up the request should look like this:</p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_1490380813478594" data-renderedposition="785.2840576171875_7.997159004211426_1134_139" jivemacro_uid="_1490380813478594"><span>var url= "</span><a title="" _jive_internal="true" href="https://myInstance.service-now.com/api/now/table/kb_knowledge?sysparm_query=GOTO123TEXTQUERY321%3D" rel="nofollow" target="_blank">https://myInstance.service-now.com/api/now/table/kb_knowledge?sysparm_query=GOTO123TEXTQUERY321%3D</a><span>" + encodeURI(query) + "&amp;sysparm_fields=sys_id%2Cnumber%2Cshort_description%2Ccategory%2Ctext";<br/></span><p>var ws = new sn_ws.RESTMessageV2();</p><p>     ws.setBasicAuth("search_user", "search");</p><p>   ws.setHttpMethod("get");</p><p>   ws.setEndpoint(url);</p><p></p><p></p><p>       var jsonOutput = ws.execute();</p><p></p></pre><p>Here we're using <a title="ocs.servicenow.com/bundle/istanbul-servicenow-platform/page/app-store/dev_portal/API_reference/RESTMessageV2/reference/r_RMV2-setBasicAuth_S_S.html" href="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/app-store/dev_portal/API_reference/RESTMessageV2/reference/r_RMV2-setBasicAuth_S_S.html">basic authentication</a> for our call. We're passing in the username and password for a user on that instance in order to gain access to the knowledge records. There are probably better and more secure ways to handle the authentication but I'm not going to get in the weeds on that. I'm really trying to keep things simple here that we can focus on the basics of how to set this up. If you want to try a different approach for authentication, you might start here: <a href="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/integrate/outbound-rest/task/t_CreateABasicAuthProfile.html" title="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/integrate/outbound-rest/task/t_CreateABasicAuthProfile.html">Create a basic auth profile..</a></p><p></p><p>Once we have our request setup we need to define how we're going to handle the response data. I'm specifying the fields to be returned in my query like this:</p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_14903808829658697" data-renderedposition="1028.92041015625_7.997159004211426_1134_15" jivemacro_uid="_14903808829658697"><p>"&amp;sysparm_fields=sys_id%2Cnumber%2Cshort_description%2Ccategory%2Ctext";</p></pre><p></p><p>Next, we need to decode the JSON object we'll get in response. Once we decode the JSON object, then we iterate through each result and set some fields</p><ol><li><span style="color: #303030;">result.url — if you were linking to the external site rather than opening the record in ServiceNow this would be where the link leads to.</span></li><li><span style="color: #303030;">Result.target — this is the target for the link. Here we're using _blank to open in a new window</span></li><li><span style="color: #303030;">Result.primary — this sets what our primary display field will be.</span></li></ol><p></p><p><span style="color: #303030;">The code to do that will look like this:</span></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_14903809240954287 jive_macro_code jive_text_macro" data-renderedposition="1201.9317626953125_7.997159004211426_1134_139" jivemacro_uid="_14903809240954287"><p>if (jsonOutput) {</p><p>var response = new JSON().decode(jsonOutput.getBody());</p><p>results = response.result;</p><p>results.forEach(function(result) {</p><p>           result.url = result.svn_url;</p><p>           result.target = "_blank";</p><p>           result.primary = result.short_description;</p><p>       });</p><p>}</p></pre><p></p><p>Here is the finished product for the data source:</p><p><img   alt="data source1.jpg" class="image-10 jive-image" src="dce24c8adb1c5704ed6af3231f961930.iix" style="width: 620px; height: 200px; display: block; margin-left: auto; margin-right: auto;"/></p><p></p><p><strong>Displaying the search results:</strong></p><p>Next, we'll setup the search page template. We really only need to tweak this a little bit in order to open the search results in a page that is designed to handle our external content. In fact, all we really need to do it modify the link. The default template link looks like this:</p><p></p><pre __default_attr="xml" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14903810066367617 jive_text_macro" data-renderedposition="1711.363525390625_7.997159004211426_1134_15" jivemacro_uid="_14903810066367617"><span style="color: #485563; font-family: Menlo; font-size: 12px;">&lt;a href="?id=form&amp;sys_id={{item.sys_id}}&amp;table={{item.table}}" class="h4 text-primary m-b-sm block"&gt;</span></pre><p></p><p>We just need to set this up to open a different portal page, and pass in whatever parameters that page will need to get and display the article. We're going to call this page ext_knowledge and pass a parameter "record" which should be the sys_id of our external article. We'll also add a target from the variable we set in our results object earlier.</p><p></p><pre __default_attr="xml" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_14903812082738771" data-renderedposition="1810.4544677734375_7.997159004211426_1134_15" jivemacro_uid="_14903812082738771"><span style="color: black;">&lt;a href="?id=ext_knowledge&amp;record={{item.sys_id}}" target="{{item.target}}" class="h4 text-primary m-b-sm block"&gt;</span></pre><p></p><p>Again, you could choose the simpler path here and just make this link to the external application or site this item came from but I find the idea of displaying this content as if it is native to our instance to be interesting and that might provide a better user experience so we'll go that route here. So, the final product for the search source record looks like this:</p><p><img   alt="search source portal1.jpg" class="image-9 jive-image" src="9d142042db9457041dcaf3231f9619a4.iix" style="width: 620px; height: 137px; display: block; margin-left: auto; margin-right: auto;"/></p><p></p><h2>Displaying the searched content on the Service Portal</h2><p>So far things have been pretty straightforward. You need an API to search some external site. You need to decide what data to bring over and setup the data fetch script and you need to make a small modification to the search page template. Displaying the content in my portal is where I really ran into a couple of gotchas that proved a little tricky. We'll do this by creating a new widget called External Knowledge and adding it to the ext_knowledge page that we referred to earlier in our search page template.</p><p></p><p><strong>The issue I ran into displaying this content</strong></p><ul><li>First, you can't simply pass the article text via the URL and display it.. you have to actually get the record again.</li><li>Second, the content won't be rendered as HTML by default. You have to use a little angular magic to allow that.</li></ul><p></p><h3>Get the record using a Server Script</h3><p>We'll deal with our first issue in the server script for the widget. First, define a function called getRecord(). That is going to be mostly identical to the data fetch script from before but with a few changes.</p><ol><li>Because we're not doing a search, the URL should change to this:<pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_1490381412600483 jive_text_macro" data-renderedposition="2365.3408203125_37.99715805053711_1104_15" jivemacro_uid="_1490381412600483"><span style="color: black;"><span>var url= "</span><a title="" _jive_internal="true" href="https://myInstance.service-now.com/api/now/table/kb_knowledge/" rel="nofollow" target="_blank">https://myInstance.service-now.com/api/now/table/kb_knowledge/</a><span>"+rec +"?sysparm_fields=short_description%2Ctext%2Cnumber%2Ccategory";</span></span></pre></li><li>You'll notice we are using the variable rec instead of query in our query string.</li><li>We don't need the url and target variables from before so when we handle the response data the only variable we're setting is result.primary. Then, we just define record variable and get the value from the URL parameter and pass that into our getRecord function. The server script ends up something like this:</li></ol><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_1490381277281223" data-renderedposition="2451.91748046875_7.997159004211426_1134_386" jivemacro_uid="_1490381277281223"><p>(function() {</p><p>   data.record = $sp.getParameter('record');</p><p>   getRecord(data.record);</p><p>   function getRecord(rec){</p><p>       var results = [];</p><p>       /* Calculate your results here. */</p><p><span>       var url= "</span><a title="" _jive_internal="true" href="https://myInstance.service-now.com/api/now/table/kb_knowledge/" rel="nofollow" target="_blank">https://myInstance.service-now.com/api/now/table/kb_knowledge/</a><span>"+rec +"?sysparm_fields=short_description%2Ctext%2Cnumber%2Ccategory";</span></p><p>var ws = new sn_ws.RESTMessageV2();</p><p>     ws.setBasicAuth("search_user", "search");</p><p>   ws.setHttpMethod("get");</p><p>   ws.setEndpoint(url);</p><p></p><p></p><p>       var jsonOutput = ws.execute();</p><p></p><p>       if (jsonOutput) {</p><p>           var response = new JSON().decode(jsonOutput.getBody());</p><p>           results = response.result;</p><p>           results.forEach(function(result) {</p><p>               result.primary = result.short_description;</p><p>           });</p><p>       }</p><p>       data.article = results;</p><p>   }</p><p>})();</p></pre><p></p><p>Basically all this does is make a REST call to get the record and store the result data in data.record. This will make it available to our controller via the $scope.</p><p></p><h3>Use AngularJS to create a HTML Template</h3><p>Our HTML template is very simple here. We want to show the article title and render the HTML content from the text field in a similar manner to how we display knowledge articles that are in our instance. This takes 4 lines:</p><pre __default_attr="xml" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14903813131762579 jive_text_macro" data-renderedposition="2966.462890625_7.997159004211426_1134_77" jivemacro_uid="_14903813131762579"><p>&lt;div&gt;</p><p>&lt;!-- your widget template --&gt;</p><p>&lt;h1&gt;{{::c.data.article.primary}}&lt;/h1&gt;</p><p>&lt;div class="kb_article" ng-bind-html="::data.article.text" style="overflow-x:auto;"&gt;&lt;/div&gt;</p><p>&lt;/div&gt;</p></pre><p></p><p>The most important thing to note here is that we're using ng-bind instead of the usual curly braces to bind our article text here. This is basically the angular magic I mentioned earlier. Once we use ng-bind we can add a single line of code to the client controller to allow the HTML content to be rendered as HTML and then we're done.</p><p></p><h3>Allowing HTML content via the Client Controller</h3><p>As I said, aside from the boilerplate code declaring the controller function and the c variable we have one line of code here:</p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14903813593452233 jive_text_macro" data-renderedposition="3171.91748046875_7.997159004211426_1134_15" jivemacro_uid="_14903813593452233"><span style="color: black;">$scope.data.article.text = $sce.trustAsHtml($scope.data.article.text);</span></pre><p>This tells angular that $scope.data.article.text is HTML content and it is okay to render it as such.</p><p></p><p>Now when we search in the portal, our results will look like this:</p><p><img   alt="portal search sources1.jpg" class="image-6 jive-image" src="a9a22771db9c9f04e9737a9e0f961963.iix" style="width: 620px; height: 187px; display: block; margin-left: auto; margin-right: auto;"/></p><p>When we open one of the search results, it looks like this:</p><p><img   alt="portal search sources2.jpg" class="image-7 jive-image" src="cf4509cedb1497049c9ffb651f9619c7.iix" style="width: 620px; height: 296px; display: block; margin-left: auto; margin-right: auto;"/></p><pre __default_attr="warning" __jive_macro_name="alert" alert="warning" class="jive_text_macro jive_macro_alert" data-renderedposition="3803.94873046875_7.997159004211426_1134_43"><p>Again, USE AT YOUR OWN RISK! This is not a ServiceNow official customization.</p></pre><p></p><p>Again, I have to re-iterate that this is use at your own risk and is not supported by ServiceNow. Hopefully it is a good enough example to help you get started using search sources but keep in mind that my goal here is to share what I learned by setting one of these up myself and my hope is to help you avoid spending time trying to solve the same problems I ran into; not to give you the holy grail of searching. So let's recap what we went over here:</p><ul><li>We configured a scripted search source using the ServiceNow table api to crawl a knowledge base from another ServiceNow instance.</li><li>We decoded the JSON response to set some fields that the search widget expects to be set.</li><li>We created a widget that we could use to display the article content in the portal as if it were native content and the adjusted the search page template to link to a page using that widget.   (again, keep in mind you could just link to the external site if you want to keep things simple)</li><li>We looked at using ng-bind along with angular's trustAsHTML method to display HTML content.</li></ul><p></p><p>This can be adapted to work for any REST endpoint you have access to and could really enhance the search on your portal by allowing you to combine all of your resources into a single portal. For more information on search sources please refer to our documentation: <a href="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/build/service-portal/concept/search-service-portal.html" title="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/build/service-portal/concept/search-service-portal.html">Configure search in Service Portal</a>   and for more information on the ServiceNow table apis used in this demo see this article: <a href="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/integrate/inbound-rest/concept/c_TableAPI.html" title="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/integrate/inbound-rest/concept/c_TableAPI.html">Table API</a>.</p>