---
title: "Realworld ServiceNow Exception Handling"
date: 2017-08-21T23:30:00.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=a33e62addbd0dbc01dcaf3231f961952"
---
<p>Question: What's worse than code that blows up?</p><p>Answer:     Code that blows up silently.</p><p></p><p>There are lots of pithy quotes and proverbs about assumptions, but I have a favorite:</p><p></p><p>         ASSuME: Assumptions make an a** out of you and me.</p><p></p><p>When we make assumptions about things like things like data quality, our code can wind up at a dead-end.</p><p></p><p>For example, if you were tasked with writing a ServiceNow function to find the ID of the first VP above an employee, you might assume that you could use the following:</p><p></p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15030902218088800 jive_text_macro" data-renderedposition="258.90625_7.997159004211426_1176_185" jivemacro_uid="_15030902218088800"><p>// @return string sys_id for CIO</p><p>// @param   GlideRecord pointing to a user</p><p>function getC<span style="color: rgba(0, 0, 0, 0); font-family: Consolas, 'Courier New', Courier, mono, serif; font-size: 12px;">ioUserId(<span style="color: rgba(0, 0, 0, 0); font-family: Consolas, 'Courier New', Courier, mono, serif; font-size: 12px;">grItEmployee){</span></span></p><p></p><p>           var manager = grItEmployee.manager;</p><p></p><p>           if( /VP/.test(manager.title )){</p><p>                       return manager.sys_id;</p><p>           } else {</p><p>                       return <span style="color: rgba(0, 0, 0, 0); font-family: Consolas, 'Courier New', Courier, mono, serif; font-size: 12px;">getC</span><span style="color: rgba(0, 0, 0, 0); font-family: Consolas, 'Courier New', Courier, mono, serif; font-size: 12px;">ioUserId</span>(manager);</p><p>           }</p><p>}</p></pre><p></p><p>But that means that every employee in the chain must have a manager, or else the function will go into infinite recursion.   That bad assumption (that every ServiceNow user has a manager) is a fatal flaw for this piece of code.</p><p></p><p>Sometimes the code can fail in a foreseeable way.   We can plan for such failures by wrapping our code in a try/catch block;</p><p></p><p>Naive approach (counter example):</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15030912950311447 jive_text_macro" data-renderedposition="611.6334838867188_7.997159004211426_1176_77" jivemacro_uid="_15030912950311447"><p>function getApprover(){</p><p>         return null;</p><p>}</p><p> var approver = getApprover();</p><p> var fn = approver.first_name;</p></pre><p></p><p></p><p><img   class="image-2 jive-image" src="cc7a3c8adb1497041dcaf3231f961900.iix" style="max-width: 1200px; max-height: 900px;"/></p><p></p><p>Notice that this issue causes the script to error out and halts all code execution.     If this were to happen in a Workflow activity, then the activity would turn red and the entire item's Workflow would be dead.</p><p></p><p>But If instead we were to wrap the code in a try/catch block, then we can cause the code to fail gracefully, and even retry using another method.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15030918635452771 jive_text_macro" data-renderedposition="1227.9970703125_7.997159004211426_1176_170" jivemacro_uid="_15030918635452771"><p>var fn;</p><p>var approver;</p><p>try{ </p><p>         approver = getApprover();</p><p>         fn = approver.first_name;</p><p>} catch(e){         </p><p>         if(/null/.test( e.message )){ // Error message contains 'null'</p><p>                     approver = getApproverADifferentWay()</p><p>                     fn = approver.first_name;</p><p>         }</p><p>}</p></pre><p></p><p></p><p>Take another example involving a Regular Expression.     If the execution does not yield any match, then our attempt to retrieve the first match is going to fail.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_15022264228645528" data-renderedposition="1481.6334228515625_7.997159004211426_1176_139" jivemacro_uid="_15022264228645528"><p>try{ </p><p>         // Put code here in case something goes wrong.</p><p>         var re = new RegExp('(bar)');</p><p>         var someStringToTest = 'foo_baz';</p><p>         var m = re.exec(someStringToTest);</p><p>         gs.print(m[1]);</p><p>} catch(e){         </p><p>         gs.error(e.message);</p><p>}</p></pre><p></p><p>Since the regex matches zero times, the assumption that there would be something in the array of matches turned out to be a dangerous one.</p><p><img   class="image-1 jive-image" src="5e587ffddb5cdf04e9737a9e0f961970.iix" style="max-width: 1200px; max-height: 900px;"/></p><p></p><p>In this case, we don't have a retry; but the catch block gives us a nice way to quickly know what went wrong by logging the error.</p><p></p><p>I take this so far as to break things up into multiple try / catches within the same function, so that I can identify exactly what I was trying to do when the error was thrown. There is nothing more frustrating that receiving "could not access property 'z' from null" or "'undefined' is not an object" error in a lengthy function.</p><p></p><p>Log: Script x broke when you tried to access a property on something that doesn't exist."</p><p>Me:   "Great.   Now all I have to do is figure out which dot (on the myriad of possibilities) is actually trying to dereference an object that is undefined.</p><p></p><p>But if we surround different sections of our code with individual try / catch blocks, our code can actually tell us exactly what went wrong.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_1503334302997658 jive_macro_code jive_text_macro" data-renderedposition="2202.54248046875_7.997159004211426_1176_232" jivemacro_uid="_1503334302997658"><p>function x(){             </p><p>         var anAppleObject = new Orchard(1).pickAnApple();</p><p>         var anOrangeObject = new Orchard(2).pickAnOrange();</p><p>         try{</p><p>                   anAppleObject.bite();</p><p>         } catch(e){</p><p>                   gs.addErrorMessage('Exception throw while biting apple:'+e.message);</p><p>         }</p><p></p><p>         try{</p><p>                   anOrangeObject.bite();</p><p>         } catch(e){</p><p>                   gs.addErrorMessage('Exception throw while biting orange:'+e.message);</p><p>         }</p><p>}</p></pre><p></p><p>It's a silly example, but it makes the point.     If one of the objects turns out to be undefined, you'll know which one right away.</p><p></p><p>Wrapping all code in try/catch blocks is a foundational best practice that greatly decreases time to troubleshoot issues.     The practice also seems to facilitate better code by forcing us to consider what could go wrong, and what the right response to an error should be.     In our organization, code that is not wrapped in a try/catch block will not pass a code review.     The payoff to the simple discipline of surrounding all of your code with these try/catch constructs cannot be overstated.     Yes, you can still track down the error without this, but the ability to track down precisely what went wrong quickly is greatly enhanced when you log errors strategically.</p><p></p><p>Once you make the decision to embrace a proactive error-handling stance, there are still some practical considerations.     "How do I embrace this practice without making it too cumbersome?"     Syntax Editor Macros to the rescue.</p><p></p><p>I have 2 Syntax Editor Macros so that quickly insert try/catch blocks into any place where I'm writing a script inside of ServiceNow.</p><p></p><p>Using try/catch is super simple for server-side code:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15022268640623778 jive_text_macro" data-renderedposition="2747.9970703125_7.997159004211426_1176_139" jivemacro_uid="_15022268640623778"><p>// stry: stands for server-side try</p><p>try{ </p><p>         // Put code here in case something goes wrong.</p><p>} catch(e){</p><p>           if(gs.isInteractive() &amp;&amp; gs.hasRole('admin')){</p><p>                     gs.addInfoMessage('Name of module where error happened:'+ e.message);</p><p>           }</p><p>         gs.error(e.message);</p><p>}</p></pre><p></p><p>It's a little more involved on the client, because we must invoke a GlideAjax call in order to get the message into the system log:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_15022271000261516" data-renderedposition="2949.815185546875_7.997159004211426_1176_263" jivemacro_uid="_15022271000261516"><p>// ctry: stands for client-side try</p><p>try{ </p><p>         // Put code here in case something goes wrong.</p><p>} catch(e){</p><p>           if(g_user.hasRole('admin')){</p><p>                     alert('Name of module where error happened:'+ e.message);</p><p>           }</p><p>         <span style="color: rgba(0, 0, 0, 0); font-family: Consolas, 'Courier New', Courier, mono, serif; font-size: 12px;">logError</span>(e.message, '&lt;script&gt;');</p><p>}</p><p></p><p>function logError(message, source) {</p><p>         var errorUtil = new GlideAjax('GMF_ClientLogUtil');</p><p>         errorUtil.addParam('sysparm_name', 'error');</p><p>         errorUtil.addParam('sysparm_errorMessage', message);</p><p>         errorUtil.addParam('sysparm_errorSource', source);</p><p>         errorUtil.getXML();//Add a callback if you want to verify lo</p><p>}</p></pre><p></p><p>GMF_ClientLogUtil is a very simple client callable GlideAjax script include:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15022274327503021 jive_text_macro" data-renderedposition="3275.269775390625_7.997159004211426_1176_309" jivemacro_uid="_15022274327503021"><p>var GMF_ClientLogUtil = Class.create();</p><p>GMF_ClientLogUtil.prototype = Object.extendsObject(AbstractAjaxProcessor, {</p><p></p><p>       //Log the error using server side error logging</p><p>       error: function () {</p><p>                   var errorMessage = this.getParameter('sysparm_errorMessage');</p><p>                   var errorSource = this.getParameter('sysparm_errorSource');</p><p>                   gs.error(errorMessage,errorSource);</p><p>       },</p><p></p><p>       info: function(){</p><p>                   var message = this.getParameter('sysparm_message');                   </p><p>                   gs.info(message);</p><p>       },</p><p></p><p>       warn: function(){</p><p>                   var message = this.getParameter('sysparm_message');                   </p><p>                   gs.warn(message);</p><p>       }</p><p>});</p></pre><p></p><p></p><p>So, having gone to all of this trouble, I find it very frustrating that ServiceNow does not always throw an Exception when it ought to.     I had a piece of code (nicely wrapped in try/catch blocks) silently fail recently.   When I went to the error log I found nothing.   Eventually, I looked at all system entries and found a "warning" that my function had exceeded the maximum capacity for the array data type.   Hmmm...   That seems more like an error to me.</p><p></p><p>I have occasionally bumped into these types of omissions in the platform.     But the one that really bothers me is this: A GlideRecord object's addQuery() method throws no error even when we pass a bad column name.     Given the egregious consequences that can result from such a silent error, I find this really unacceptable.   (I worked on a team where a global ServiceNow project was threatened by a silent column-name typo.)     So the GlideRecord class has a serious deficiency.   We simply must know about errors involving GlideRecords.</p><p></p><p>This need led me to create the u_GlideRecord class (see attachment).</p><p></p><p><img   class="image-5 jive-image" src="0867dc0edb189fc03eb27a9e0f9619e6.iix" style="max-width: 1200px; max-height: 900px;"/></p><p></p><p></p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15033379299633637 jive_text_macro" data-renderedposition="4704.36083984375_7.997159004211426_1176_185" jivemacro_uid="_15033379299633637"><p>// Using u_GlideRecord throws an exception when we pass a bad column name</p><p>try{</p><p>         var gr = new u_GlideRecord("sc_task");</p><p>         gr.addQuery( 'snort_description', 'Complete prescribed work' );   // Should be short not sNort</p><p>         gr.setLimit(1);</p><p>         gr.query();</p><p>         while ( gr.next() ) {</p><p>                   gs.print( gr.number );</p><p>         }</p><p>} catch(e){</p><p>         gs.print(e.message);</p><p>}</p></pre><p></p><p></p><p><img  class="image-6 jive-image" src="9637f735db90d3041dcaf3231f96193f.iix" style="max-width: 1200px; max-height: 900px;"/></p>