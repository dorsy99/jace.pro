---
title: "Tips and Tricks Recursively Speaking"
date: 2010-07-27T18:31:32.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=2fcce265dbd0dbc01dcaf3231f961953"
---
<p><img __jive_id="4902" alt="" class="jive-image" src="Screen%20shot%202011-04-13%20at%2011.52.20%20AM.png" style="width: auto; height: 159px;" />What's this "recursion" I keep hearing people talk about? That's a question I got the other day. <a title=".wikipedia.org/wiki/Recursion" href="http://en.wikipedia.org/wiki/Recursion">Recursion</a> is a concept that has (unfairly, I think) gotten a reputation for being difficult to understand. It's really not hard, it's just a little different than what you'd normally see.<br /><br />Here's an example of the same function written two ways: first with a loop, then using recursion. In this case, we have a web page with a choice list showing several local cities. We don't want to show any favoritism (nor, apparently, do we want to be usable), so we'll randomly reorder the list of cities each time it's shown:<!--break--><pre style="margin-left:20px;line-height:1;"><br />var cities = ['San Diego', 'Solana Beach', 'Del Mar', 'La Jolla', 'Jamul', 'Chulajuana', 'Sorrento Valley'];<br />cities = randomize_loop(cities);<br />gs.log(cities);<br />cities = randomize_recursive(cities);<br />gs.log(cities);<br /><br /><br />function randomize_loop(arr) {<br />   var answer = [];<br />   while (arr.length &gt; 0)<br />      answer.push(grab(arr));<br />   return answer;<br />}<br /><br />function randomize_recursive(arr) {<br />   if (arr.length == 0)<br />      return [];<br /><br />   var item = grab(arr);<br />   var answer = randomize_recursive(arr);<br />   answer.push(item);<br />   return answer;<br />}<br /><br />function grab(arr) {<br />   var rm = arr.splice(random_int(arr.length), 1);<br />   return rm[0];<br />}<br /><br />function random_int(bound) {<br />   return Math.floor(Math.random() * bound);<br />}</pre><br />In this example, the recursive function is actually slightly longer than the loop-based function — more commonly, the recursive approach results in shorter code.<br /><br />The loop function iterates through grabbing elements randomly from the input array until there are no more elements to grab. Each element grabbed is pushed onto an answer arrary, and that answer array is returned. Simple enough.<br /><br />The recursive function first just returns with an empty array if its input array is empty. This isn't just an optimization; this is how the answer array gets created. If the input array has at least one element, then the recursive function grabs a random element from it. After that is where the recursion takes place: it then invokes <i>itself</i> with the shortened input array. Then it pushes the item that it grabbed onto the answer from the recursive invocation and returns with it.<br /><br />The test code above has seven elements in the input array. When we first call the recursive function, it will grab a random item and invoke itself with the six remaining item. This invocation will again grab a random item, and then invoke itself with the five remaining items. This is almost exactly what happens in the case of the loop function — but without the loop! This recursive behavior continues until finally on the seventh invocation it grabs the last remaining item and invokes itself with <i>no</i> remaining items. This time the function simply returns with an empty array. At that time, the code after the seventh recursive invocation is returned to (the line "answer.push(item);"), and the item it grabbed is pushed onto the answer array. This behavior continues through all the invocations, in reverse order, as the call stack is unwound back to the original invocation, which then returns to the original caller with the answer.<br /><br />When should you use recursion? If you understand recursion well, you'll find there are times when using a recursive approach results in much simpler code. I generally start thinking about recursive approaches when I find myself with complicated loops, or loops within loops. The (unfortunate) fact that so many people don't understand recursion, or are uncomfortable with it, means that you may want to stay away from it unless the benefits are too compelling to ignore...</p>