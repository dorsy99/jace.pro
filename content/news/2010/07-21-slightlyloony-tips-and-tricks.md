---
title: "Tips and Tricks More Equal"
date: 2010-07-20T17:57:25.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=20ac6225dbd0dbc01dcaf3231f9619c4"
---
<p><img __jive_id="4897" alt="" class="jive-image" src="gear.png" style="width: auto; height: 139px;" />What do you suppose will be logged when you run the code below?<br /><pre style="margin-left:20px;line-height:1;"><br />test(5, '05', 'numeric 5', 'string "05"');<br />test('5', '05', 'string "5"', 'string "05"');<br />test(5, 5, 'numeric 5', 'numeric 5');<br /><br />function test(a, b, label_a, label_b) {<br />   var equal = (a == b) ? 'equal' : 'unequal';<br />   gs.log('Operands ' + label_a + ' and ' + label_b + ' are ' + equal + '.');<br />}<br /></pre><br />Were you surprised? Here's what's going on:<br /><!--break--><br />JavaScript defines <i>equality</i> (what you're testing with the "==" operator) roughly as "two things that have the same value". This can lead to unexpected results if you forget about Javascript's loose typing system and the consequent <i>type coercsion</i>. For example, consider what happens when JavaScript evaluates a statement like this:<br /><pre style="margin-left:20px;line-height:1;"><br />5 == '05'<br /></pre><br />The JavaScript interpreter will see that the two operands are of different types (numeric and string, respectively) and it will <i>coerce</i> one of the operands into the type of the other (see <a title="de.google.com/p/gpsee/wiki/JavaScript_FAQ" href="http://code.google.com/p/gpsee/wiki/JavaScript_FAQ">"Coercion" for more details</a>). In this case, it will coerce the string into a number, so the comparison is actually done with a numeric 5 compared to a numeric 5 and the result is true (since 5 <i>does</i> equal 5!).<br /><br />Now check out this piece of code, and note the use of the "===" (what the heck is that?) operator:<br /><pre style="margin-left:20px;line-height:1;"><br />test(5, '05', 'numeric 5', 'string "05"');<br />test('5', '05', 'string "5"', 'string "05"');<br />test(5, 5, 'numeric 5', 'numeric 5');<br /><br />function test(a, b, label_a, label_b) {<br />   var equal = (a == b) ? 'equal' : 'unequal';<br />   var identical = (a === b) ? 'identical' : 'different';<br />   gs.log('Operands ' + label_a + ' and ' + label_b + ' are ' + equal + ' and ' + identical + '.');<br />}<br /></pre><br />The "===" is called the <i>identity</i> operator. While the "==" operator tests for <i>equal</i> values, the "===" operator tests for <i>identical</i> values. Two values are identical if and only if both their type and their value is the same. One could say that identical values are <i>more equal</i> than merely equal values!<br /><br />The identity operator is occasionally useful with primitive values, and much more frequently useful with JavaScript objects (whether built-in or ones you build yourself). That's because objects are only identical if they are the <i>same</i> instance of the object. Consider:<br /><pre style="margin-left:20px;line-height:1;"><br />var x = {x:5};<br />var y = {x:5};<br />test(x, y, 'x', 'y');<br />test(x, x, 'x', 'x');<br />y = x;<br />test(x, y, 'x', 'y');<br /><br />function test(a, b, label_a, label_b) {<br />   var equal = (a == b) ? 'equal' : 'unequal';<br />   var identical = (a === b) ? 'identical' : 'different';<br />   gs.log('Operands ' + label_a + ' and ' + label_b + ' are ' + equal + ' and ' + identical + '.');<br />}<br /></pre><br />The first test of x and y shows the two are different, even though they have identical definitions. That's because they are two different instances of the same object that happen to have the same property and value. Note also that these show up as unequal. Surely they should evaluate to equal, since they have the same contents? Actually the equality comparison is undefined for objects in general (in JavaScript), so the value returned by the "==" operator should be treated as unknown, and you shouldn't write code that depends on it.<br /><br />In the second test (comparing x with x), the results show the two are identical, as well they should be: x and x both refer to the same object instance, of course. But did the result of the third test surprise you? x and y are now identical because by assigning x to y, we've made both x and y refer to the same object instance...</p>