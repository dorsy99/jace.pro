---
title: "Tips and Tricks Sorting Strings NonLexicographically"
date: 2010-07-23T17:58:58.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=dcfc62a5dbd0dbc01dcaf3231f961927"
---
<p><img __jive_id="6782" alt="Picture 1_0.png" class="jive-image" style="width: imagecache/Small/SlightlyLoony/Picture 1_0.png; height: auto;" />"All right," said a reader who had read my post of a few days ago on sorting. "Suppose I need to sort something like this mess, the way a human would want it sorted?"<br /><div style="margin-left:20px;"><br />May 12, 2009<br />March 3, 10<br />Jan 09, 99<br />dec 25, 09<br />JAN 30, 2010<br /></div><br />You didn't <i>really</i> think I'd let a little thing like a non-lexicographical sort stop me, did you?<!--break--><br /><br />There are several ways to approach this problem. The approach I chose here was to transform the values being compared into a normalized numeric string that <i>would</i> sort correctly in lexicographical order. Below I've shown the normalized string first, followed by the original input string:<br /><div style="margin-left:20px;"><br />20090512&nbsp;&nbsp;&nbsp;&nbsp;May 12, 2009<br />20100303&nbsp;&nbsp;&nbsp;&nbsp;March 3, 10<br />20090109&nbsp;&nbsp;&nbsp;&nbsp;Jan 09, 99<br />20091225&nbsp;&nbsp;&nbsp;&nbsp;dec 25, 09<br />20100130&nbsp;&nbsp;&nbsp;&nbsp;JAN 30, 2010<br /></div><br />So if I transform the strings on the left into the strings on the right, and then sort <i>those</i> lexicographically, then everything will be peachy keen and wonderful. That's what this code does:<br /><pre style="margin-left:20px;line-height:1;"><br />// add some handy-dandy methods to the String class<br />String.prototype.right =<br />function(n) {<br />   return this.substring(Math.max(0, this.length - n));<br />};<br /><br />String.prototype.left =<br />function(n) {<br />   return this.substring(0, n);<br />}<br /><br />// test code<br />var data = ['May 12, 2009', 'March 3, 10', 'Jan 09, 99', 'dec 25, 09', 'JAN 30, 2010'];<br />data.sort(date_sort);<br />for (var i = 0; i &lt; data.length; i++)<br />   gs.log(data<i>);<br /><br />// sort function<br />function date_sort(a, b) {<br />   var months = {jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12};<br />   var na = normalize(a);<br />   var nb = normalize(b);<br />   return (na == nb) ? 0 : ((na &gt; nb) ? 1 : -1);<br /><br />   function normalize(x) {<br />      var parts = /([a-zA-Z]+) (\d+), (\d+)/.exec(x);<br />      var monthName = parts[1].toLowerCase().left(3);<br />      var month = pad0(months[monthName], 2);<br />      var day = pad0(parts[2], 2);<br />      var year = parts[3] - 0;<br />      if (year &lt; 100)<br />         year = (year &lt; 50) ? (2000 + year) : (1900 + year);<br />      year = pad0(year, 4);<br />      return year + month + day;<br />   }<br /><br />   function pad0(x, n) {<br />      var y = '0000' + x;<br />      return y.right(n);<br />   }<br />}</i></pre><i><br />Most of the work is done in the normalize function, which does the transformation described above. First a regular expression parses the input value into a month, day, and year. Then each part is transformed into either a 4 digit or a 2 digit number (adding leading zeros if necessary). Finally all the parts are concatenated to produce the result.<br /><br />If you've been torturing yourself by reading my recent series of posts, most of this code should look at least vaguely familiar, and you should be able to figure out what it's doing. A couple of bits might need some explanation, though:<br /></i><ul><li style="list-style: none"><i><br /></i></li><li><i>In the line var year = parts[3] - 0; the subtraction of zero is a trick to force the result to be a numeric value. I do this so that on the next line I can do a comparison to a numeric value, and be sure that the comparison will be done numerically, and not lexicographically (by coercing the value 100 to a string).</i></li><li>The line <i>return (na == nb) ? 0 : ((na &gt; nb) ? 1 : -1);</i> is a nested ternary expression. It's just a more compact way of writing this:<br /><pre style="margin-left:20px;line-height:1;"><br />if (na == nb)<br />   return 0;<br />else {<br />   if (na &gt; nb)<br />      return 1;<br />   else<br />      return -1;<br />}<br /></pre></li></ul></p>