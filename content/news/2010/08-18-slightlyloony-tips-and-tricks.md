---
title: "Tips and Tricks Representing Things in JavaScript"
date: 2010-08-17T18:22:04.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=518d2669dbd0dbc01dcaf3231f9619b2"
---
<p><img  alt="" class="jive-image" src="82470d86dbd0130468c1fb651f9619ba.iix" style="width: auto; height: 100px;" />A few days ago I was talking with someone I'll call Joe about one of our Discovery scripts. Joe was trying to figure out something we were doing in the script, and I finally figured out what was giving him trouble: he'd never run into the notion of using a JavaScript object to represent something. In the specific case he was puzzling over, we used JavaScript objects to represent network adapters — but it could have been anything at all.<br /><br />For example, suppose you were writing a script that needed to refer to a few hundred locations, many thousands of times. You <i>could</i> do this with queries to the database, but the performance would be slower than you'd like — so you'd like to have this list in memory. Let's further suppose that your script needs to find locations by (presumably unique) name or by (not necessarily unique) zip code. How could you do this?<br /><!--break--><br />Here's some code that will do the trick:<br /><pre style="margin-left:20px;line-height:1;"><br />var locations = getLocations();<br /><br />var sd = locations.byName['San Diego'];<br />gs.log('San Diego: ' + sd.street + ', ' + sd.city + '  ' + sd.zip);<br /><br />var zip92075 = locations.byZip['92075'];<br />for (var i = 0; i &lt; zip92075.length; i++) {<br />   var item = zip92075<i>;<br />   gs.log(item.name + ': ' + item.street + ', ' + item.city + '  ' + item.zip);<br />}<br /><br /><br />// build the locations object...<br />function getLocations() {<br />   var answer = {};<br />   answer.locations = [];<br />   answer.byName = {};<br />   answer.byZip = {};<br />  <br />    var gr = new GlideRecord('cmn_location');<br />   gr.query();<br />   while (gr.next()) {<br />      // make our object representing a location...<br />      var location     = {};<br />      location.name    = '' + gr.name;<br />      location.street  = '' + gr.street;<br />      location.city    = '' + gr.city;<br />      location.zip     = '' + gr.zip;<br />      location.country = '' + gr.country;<br />      location.company = '' + gr.company;<br /><br />      // store our new location in a list...<br />      answer.locations.push(location);<br /><br />      // add it to our map of locations by (unique) name...<br />      answer.byName[location.name] = location;<br />     <br />       // add it to our map of locations by (not unique) zip code...<br />      if (!answer.byZip[location.zip])<br />         answer.byZip[location.zip] = [];<br />      answer.byZip[location.zip].push(location);<br />   }<br />   return answer;<br />}</i></pre><i><br />When I run this script on my instance, here's the result:<br /></i><pre style="margin-left:20px;line-height:1;"><i><br />San Diego: 100 Park Boulevard, San Diego  92101<br />San Diego North: 937 Lomas Santa Fe Drive, San Diego  92075<br />San Diego West: 123 West Plaza, Solana Beach  92075<br /></i></pre><i><br /> So what's going on here?<br /><br />The first ten lines or so of the script just invokes the getLocations() function and demonstrates that the result does, in fact, do what we need. All the interesting stuff is in that function.<br /><br />The first thing the function does is to create an answer object — the value that will be returned by the function. In that answer object, we create three properties:<br /></i><ul><li><b>locations</b>: a simple array of locations (more on these later)</li><li><b>byName</b>: an object whose properties are named for the names of locations, and the values are the locations by that name</li><li><b>byZip</b>: an object whose properties are named for the zip codes of locations, and the values are arrays of locations at that zip code</li></ul><br />Then the function queries the location table and iterates through the results. In the <i>for</i> loop, the first thing it does is to create an object representing the location in the current row. Each property in this object is named for some aspect of a location that we want to store and use (name, street, zip, etc.). Then it takes the shiny new <i>location</i> object and does three things with it:<br /><ol><li><b>add to list</b>: pushes the new <i>location</i> onto the end of the list of <i>locations</i></li><li><b>add to byName object</b>: stores the new <i>location</i> to the property in <i>byName</i> named as the location name</li><li><b>add to byZip object</b>: first checks to see if it needs to create a property for this location's zip code (and if so, creates the property with an empty array as a value), then pushes the new <i>location</i> onto the end of that array</li></ol><br />These general techniques can be used to represent absolutely <i>anything</i> in a generic JavaScript object. Even if what you need to represent is hierarchical (such as representing computers and their associated network adapters), it's still easy: you can have an object that represents a computer, and within that object have a property (named, say, <i>nics</i>) that contains an array of objects representing network adapters. By putting pieces like this — each individually rather simple — together, you can create arbitrarily complex objects to hold anything you need to hold, in a way that's easy and fast to get to...<br /><br />Oh, and if you're wondering <a title="w.ritholtz.com/blog/2009/09/sculpture-what-you-see-might-not-be-real/" href="http://www.ritholtz.com/blog/2009/09/sculpture-what-you-see-might-not-be-real/">what's up with that sculpture</a>...</p>