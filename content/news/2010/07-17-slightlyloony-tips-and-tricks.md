---
title: "Tips and Tricks Those Cloying Closures"
date: 2010-07-16T18:12:56.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=8c0e2a2ddbd0dbc01dcaf3231f961941"
---
<p><img  alt="" class="jive-image" src="8255f842db989344e9737a9e0f96191b.iix" style="width: auto; height: 113px;" />You may sometimes find yourself writing code over and over again with only minor variations. The <i>pattern</i> of these blocks of code (often a function) is the same, but some small particulars may vary. The brute-force approach is to simply bite the bullet and write separate functions to handle each variation, as in this (unreasonably) simple example where we write functions to return particular powers of a number:<br /><pre style="margin-left:20px;line-height:1;"><br />gs.log('The square of 5 is: ' + square(5));<br />gs.log('The cube of 5 is: ' + cube(5));<br /><br />function square(n) {<br />   return Math.pow(n, 2);<br />}<br /><br />function cube(n) {<br />   return Math.pow(n, 3);<br />}<br /></pre><br />There's another way to do this sort of thing in JavaScript â€” in effect, a way to <a href="http://en.wikipedia.org/wiki/Function_composition_%28computer_science%29"><i>compose</i></a> functions by using <a href="http://en.wikipedia.org/wiki/Closure_%28computer_science%29"><i>closures</i></a> and a <a href="http://en.wikipedia.org/wiki/Factory_function"><i>factory function</i></a>. Here's the example above, reworked to use this technique:<br /><!--break--><br /><pre style="margin-left:20px;line-height:1;"><br />var square = makePowerFunction(2);<br />var cube = makePowerFunction(3);<br /><br />gs.log('The square of 5 is: ' + square(5));<br />gs.log('The cube of 5 is: ' + cube(5));<br /><br /><br />function makePowerFunction(exp) {<br />   var e = exp;<br />   return pow;<br /><br />   function pow(n) {<br />      return Math.pow(n, e);<br />   }<br />}<br /></pre><br />If you've never run into closures before, this code may make your head explode (especially when you try it and discover that it actually works). Here's the bit of magic that's happening under the covers: when makePowerFunction() returns pow(), it's <i>also</i> returning the complete context that pow() was operating in at the time its value was returned. So when we execute makePowerFunction(2), the "2" is assigned to the variable "e", and then when the function pow() is returned, that value is in its context. Then later in the code when it executes square(5), that context is still being held (in the "square") variable that holds that particular version of the "pow()". The same sort of thing happens with the variable "cube", except that in that case the value is "3".<br /><br />I'm about to hit you with a more complex example, so stare at that code and think about it until it makes sense. It may help to repeatedly smack yourself on the head with a hard object...<br /><br />So here's a slightly more realistic example of where you might want to use this approach. A pattern you may see frequently in your JavaScript code is that you need to query a particular table for records where a given field matches a given value. Here's a factory function for such a situation and a couple examples of its use: <br /><pre style="margin-left:20px;line-height:1;"><br />var queryUser = queryFactory('sys_user', 'name');<br />var queryComputer = queryFactory('cmdb_ci_computer', 'name');<br /><br />var x = queryUser('SlightlyLoony');<br />gs.log('Have user SlightlyLoony: ' + x.next());<br /><br />var y = queryComputer('sandb01');<br />if (y.next())<br />   gs.log('Computer sandb01 is at IP: ' + y.ip_address);<br /><br />function queryFactory(table, field) {<br />   var t = table;<br />   var f = field;<br />   return query;<br /><br />   function query(value) {<br />      var gr = new GlideRecord(t);<br />      gr.addQuery(f, value);<br />      gr.query();<br />      return gr;<br />   }<br />}</pre><br />Now we've got a somewhat more complex query() function, but outside of the queryFactory() function the code is very simple. The first two lines use the queryFactory to make a couple of handy query functions, then we use those query functions to get the information we want. <i>That</i> code is considerably simpler than what we'd have if we repeated the code in the query() function for each use we made of it.<br /><br />This feature (closures) can be quite a good way to simplify your JavaScript code, if you use it prudently. One specific thing I'd recommend is that you be very careful that your factory function names indicate what's going on. Putting "factory" in the name is a simple way to do this...</p>