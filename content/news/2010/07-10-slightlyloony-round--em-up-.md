---
title: "Round Em Up"
date: 2010-07-09T18:06:10.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=b64d6229dbd0dbc01dcaf3231f9619cd"
---
<p><img  alt="" class="jive-image" src="a0c02502db9c13043eb27a9e0f9619f5.iix" style="width: auto; height: 113px;" />Sometimes you'd rather show "265" on the screen instead of "265.39128376465" — perhaps because it's just easier to understand, or perhaps because the calculation that yielded that very precise looking number really isn't all that precise in the first place, and you don't want to mislead the user. The usual way to deal with this issue is by "rounding", and you've probably been doing this since grade school. Even so, you may not realize just how complex a subject rounding actually is — so we're going to take this opportunity to make what you thought was a very simple subject into something far more complex and confusing than you ever thought it could be!<!--break--><br /><br />Most commonly when we think of rounding, we think of rounding to the nearest integer value, like in the example above. Most of us learned in school that if the value is exactly halfway between the two nearest integers, then we round up. For example, we'd round 2.5 <i>up</i> to 3. But this simple method that we were taught isn't always what we want. For starters, it's not always the case that we want to round to the nearest integer. For example, if we were dealing with eggs (21 eggs rounds to 2 dozen, or 24, eggs), we might want to round to the nearest dozen — or if we were dealing with money, we might want to round to the nearest penny (or hundredth of a dollar). On top of that, we might not actually want to round to the <i>nearest</i> value, but rather to the <i>next largest</i> value. Back to those eggs: if we computed the need for 14 eggs in a recipe, and we're trying to print a shopping list, then we don't want to round 14 eggs to the <i>nearest</i> one dozen, 'cause we'd come up two eggs short — instead, we want to round <i>up</i> to 2 dozen eggs.<br /><br />So there are two ways that rounding can vary: the <i>interval</i> (to use a fancy mathematical term) that we're rounding to (such as integer, dozen, 0.01, etc.), and the <i>mode</i> (nearest, up, etc.). <br /><br />Let's take the interval first, because it's the easiest to deal with. The following little function will round a given value to any interval using the given rounding function. The rounding function must round the given value to one of the adjacent integers. Notice there is some test code included that uses the rounding function built into JavaScript's standard Math class. This rounding function works exactly the same way you were taught in school:<br /><pre style="margin-left:20px;line-height:1;"><br />// test our function...<br />gs.log(round(4, 5, Math.round));<br />gs.log(round(2, 5, Math.round));<br />gs.log(round(2.5, 5, Math.round));<br />gs.log(round(2.4999999, 5, Math.round));<br />gs.log(round(24.456, 0.01, Math.round));<br />gs.log(round(24.454, 0.01, Math.round));<br /><br />// the generalized rounding function...<br />function round(value, interval, func) {<br />   var v = value / interval;<br />   var rv = func(v);<br />   return rv * interval;<br />}<br /></pre><br />Try running this in <b>Scriptsâ†’Background</b>. Study the results until they make sense to you.<br /><br />Now let's throw another twist into this, by using different rounding modes. In the code below, I've added a couple additional rounding mode functions and some more test code. The roundUp() function implements rounding up, as discussed above. The roundBanker() function does something a bit different, and it needs some explanation...<br /><br />Way back when, somewhere in Europe a banker was computing interest on bank account balances and noticed that he was being cheated by the kind of rounding we all were taught. The problem was caused by values that were the same distance from the two nearest values they could be rounded to. For example, suppose our medieval banker was dealing with dollars and cents. He might compute the interest to be paid to a depositor as 3.565 dollars. If he's rounding to the nearest cent, using the normal rounding method, he'd round <i>up</i> to 3.57, because 3.565 is exactly equidistant between 3.56 and 3.57, and the rule is if halfway, round up. To the banker, that's just plain unfair! So our medieval banker came up with something called "banker's rounding" to solve the problem: when a value is exactly halfway, round to the nearest <i>even</i> value. By doing this, then roughly half the time you'd round up, and the other half you'd round down. The banker is now happy; the rule is fair.<br /><br />Here's the code:<br /><pre style="margin-left:20px;line-height:1;"><br />// test our function...<br />gs.log(round(4, 5, Math.round));<br />gs.log(round(2, 5, Math.round));<br />gs.log(round(2.5, 5, Math.round));<br />gs.log(round(2.4999999, 5, Math.round));<br />gs.log(round(24.456, 0.01, Math.round));<br />gs.log(round(24.454, 0.01, Math.round));<br />gs.log(round(24.001, 1, roundUp));<br />gs.log(round(33, 2, roundBanker));<br />gs.log(round(34, 2, roundBanker));<br /><br />// the generalized rounding function...<br />function round(value, interval, func) {<br />   var v = value / interval;<br />   var rv = func(v);<br />   return rv * interval;<br />}<br /><br />// round up function<br />function roundUp(value) {<br />   return Math.ceil(value);<br />}<br /><br />// banker's rounding function<br />function roundBanker(value) {<br />   var i = Math.floor(value);<br />   var frac = value - i;<br />   if (frac != 0.5)<br />      return Math.round(value);<br />   return (i &amp; 1 == 0) ? i + 1 : i;<br />}<br /></pre><br />There's much more on <a title=".wikipedia.org/wiki/Rounding#Round_half_to_even" href="http://en.wikipedia.org/wiki/Rounding#Round_half_to_even">Wikipedia</a>.</p>