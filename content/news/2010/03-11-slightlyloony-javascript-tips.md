---
title: "JavaScript Tips and Tricks The Two Flavors of Undefined"
date: 2010-03-10T19:45:21.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=ee7ca2e1dbd0dbc01dcaf3231f9619be"
---
<p><img  alt="" class="jive-image" src="6fe13f35db58df04e9737a9e0f96196c.iix" style="width: auto; height: 176px;" />In JavaScript, "undefined" means two distinctly different things:<br /><ol><li>A property that doesn't exist.</li><li>A property that has the "undefined" value assigned to it.</li></ol><br />Huh? Aren't those two ways of saying the same thing? Well…not <i>exactly</i>, and the differences can lead to some unexpected results. Consider this example:<br /><!--break--><br /><pre style="margin-left:20px;line-height:1;"><br />var x = {};<br />x.s = 'cowabunga';<br />x.t = undefined;<br /><br />gs.log('Typeof...');<br />gs.log('x.s: ' + typeof x.s);<br />gs.log('x.t: ' + typeof x.t);<br />gs.log('x.y: ' + typeof x.y);<br />gs.log('');<br /><br />gs.log('Direct reading...');<br />gs.log('x.s: ' + x.s);<br />gs.log('x.t: ' + x.t);<br />gs.log('x.y: ' + x.y);<br />gs.log('');<br /><br />gs.log('Enumeration...');<br />for (var n in x)<br />   gs.log('x.' + n + ': ' + x[n]);<br /><br /></pre><br />If you run this program on a Service-now.com instance, you'll get these results:<br /><pre style="margin-left:20px;line-height:1;"><br />Typeof...<br />x.s: string<br />x.t: undefined<br />x.y: undefined<br /><br />Direct reading...<br />x.s: cowabunga<br />x.t: undefined<br />x.y: undefined<br /><br />Enumeration...<br />x.s: cowabunga<br />x.t: undefined<br /></pre><br />Notice that x.t shows up in the enumeration, and x.y doesn't? That's because x.t actually has a value — the special built-in value "undefined", which was assigned to it in the third line of the program — but x.y was never assigned at all, so it was never initialized at all.<br /><br />There's a slightly subtle difference in how various JavaScript platforms handle these two flavors of undefined. On a Service-now.com instance (i.e., server-side JavaScript), this enumeration difference is almost the only difference you'll see. The exception is for properties on the global object. If you run the program below, you'll get a runtime error on the third line, complaining that y is not defined:<br /><pre style="margin-left:20px;line-height:1;"><br />var x = undefined;<br />gs.log('x: ' + x);<br />gs.log('y: ' + y);<br /></pre><br />But there was no such complaint in the first program, where we tried to read x.y — in that case the value "undefined" was returned and there was no error.<br /><br />Browser environments (i.e., client-side JavaScript) most commonly get runtime errors <i>anytime</i> you try to read a property that's never been assigned, but they vary. For example, some flavors of Internet Explorer produce runtime errors for unassigned properties on built-in classes (such as the DOM), but not on pure JavaScript objects.<br /><br />So the safest thing to do, and a practice I'd recommend, is to write your JavaScript (even for server-side) as though references to unassigned properties would produce an exception. Do this, and you'll never get a nasty surprise...</p>