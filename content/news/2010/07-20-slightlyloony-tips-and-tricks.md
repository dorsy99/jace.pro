---
title: "Tips and Tricks Argumentative Functions"
date: 2010-07-19T18:26:55.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=a56ceaa1dbd0dbc01dcaf3231f9619fc"
---
<p><img  alt="" class="jive-image" src="c13037bddb5c93049c9ffb651f961905.iix" style="width: auto; height: 100px;" />If you've done any programming at all in JavaScript, then you're familiar with <a href="http://en.wikipedia.org/wiki/Function_%28computer_science%29"><i>functions</i></a> (I hope!). Normally a function looks something like this nice little message formatting function:<br /><pre style="margin-left:20px;line-height:1;"><br />var x = say('${1} had a ${2} just ${3}.', 'SlightlyLoony', 'nice glass of wine', 'last night');<br />gs.log(x);<br /><br />function say(msg, parm1, parm2, parm3) {<br />   var x = msg.replace(/\$\{1\}/g, parm1);<br />   x = x.replace(/\$\{2\}/g, parm2);<br />   x = x.replace(/\$\{3\}/g, parm3);<br />   return x;<br />}</pre><br />But what if we wanted a more flexible message formatter? In particular, one that would take <i>any</i> number of parameters, not just three?<br /><!--break--><br />The function below does exactly that:<br /><pre style="margin-left:20px;line-height:1;"><br />var x = say('${1} had a ${2} just ${3}.', 'SlightlyLoony', 'nice glass of wine', 'last night');<br />gs.log(x);<br /><br />function say() {<br />   return arguments[0].replace(/\$\{([0-9]+)\}/g, replacer);<br /><br />   function replacer(pat, mat) {<br />      return say.arguments[mat];<br />   }<br />}</pre><br />There are two things in here that may be new to you:<br /><ol><li><i><u>The "arguments" variable</u></i>: When any function is invoked, whatever arguments were passed in are available in the <i>arguments</i> array variable. The length of the arguments array tells you how many arguments were passed (this could be different on different function invocations). It doesn't matter if parameters are declared in the function definition; the arguments variable will be filled in exactly the same way regardless. The <i>say()</i> function assumes that the first argument (argument[0]) is the message pattern string, and that any subsequent arguments are parameters that might be used to replace elements in the message pattern string. The replace function invocation says "replace anything that looks like <i>${n}</i> with the result of the <i>replacer</i> function (which is defined immediately below).</li><li><i><u>The replacement function</u></i>: The <i>replacer</i> function is invoked each time the replace method finds a string to replace. This function could have any name, of course. When the replacement function is invoked, the first parameter is the matched string (such as "${1}" in our example), and the following parameters are the contents of any capture groups (the things inside parentheses) in the matching regular expression. In the example there's only one capture group, which captures the number inside the <i>${n}</i> pattern. The replacer function uses this value (<i>mat</i> in our example) as an index into the parameters to the <i>say()</i> function (note how we used <i>say.arguments</i> to get the arguments variable of the surrounding function rather than of our replacer function). So this replacement function simply returns the replacement parameter that matches the number in the message pattern string.</li></ol><br />And <i>voila!</i> With really very little code, we have a completely general message formatting function that can take any number of parameters.<br /><br />Functions with a variable number of argument useful in lots of places. The classic example is the general purpose <i>sum()</i> function:<br /><pre style="margin-left:20px;line-height:1;"><br />var x = sum(15, 67, 345, 22, 9352,1756);<br />gs.log('And the answer is: ' + x);<br /><br />function sum() {<br />   var answer = 0;<br />   for (var i = 0; i &lt; arguments.length; i++)<br />      answer += arguments<i>;<br />   return answer;<br />}</i></pre><i><br /><br />Add these to your bag of tricks!</i></p>