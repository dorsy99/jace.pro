---
title: "Fun With Queries"
date: 2013-07-25T23:25:04.000Z
authors: ["sabell2012"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=c77ce2e1dbd0dbc01dcaf3231f96195b"
---
<p>So, I wanted to create a glide query that would give me a count of all records with sys_updated_on or sys_created_on between two dates.<br /><br />Table: cmdb_ci_computer<br />Query type: Aggregate - COUNT<br /><br />There are a couple of approaches that can be used here:<br /><br />1. GlideAggregate query<br />2. Encoded query<br /><br />I really, really wanted to do this in a single GlideAggregate query. Something fancy. So began my experimentation.<br /><br /><!--break--><br />1. Design the query in SQL.<br /><br />NOTE: With GlideRecord or GlideAggregate you get a built-in benefit in that all inherited table's fields are present for execution of the query. With gs.sql queries you don't get that nicety and have to do the join yourself. Thus my models required a join to cmdb_ci to pull in the sys_updated_on and sys_created_on dates.<br /><br />First my preferred model:<br /><br />SELECT COUNT(*)<br />FROM cmdb_ci_computer co<br />JOIN cmdb_ci ci ON co.sys_id = ci.sys_id<br />WHERE (ci.sys_updated_on BETWEEN '2013-02-04 19:00:00' AND '2013-02-05 19:00:00')<br />OR (ci.sys_created_on BETWEEN '2013-02-04 19:00:00' AND '2013-02-05 19:00:00')<br /><br />Second, an expanded model since GlideRecord nor GlideAggregate cannot do BETWEEN:<br /><br />SELECT COUNT(*)<br />FROM cmdb_ci_computer co<br />JOIN cmdb_ci ci ON co.sys_id = ci.sys_id<br />WHERE (ci.sys_updated_on &gt;= '2013-02-04 19:00:00' AND ci.sys_updated_on &lt;= '2013-02-05 19:00:00')<br />OR (ci.sys_created_on &gt;= '2013-02-04 19:00:00' AND ci.sys_created_on &lt;= '2013-02-05 19:00:00')<br /><br /><br />2. Now off to model the query in System Definition / Scripts - Background<br /><br />This is the best place to play with queries (or just about any script). You get immediate feedback and if you spend the extra time the code can be literally cut-and-paste into your final solution location.<br /><br />3. First I tried to get everything into a GlideAggregate. I was shooting for an elegant solution...right?<br /><br />Try 1:<br /><br />var startDate = "2013-02-04 19:00:00";<br />var endDate = "2013-02-05 19:00:00";<br /><br />var grComp = new GlideAggregate("cmdb_ci_computer");<br />grComp.addQuery("sys_updated_on", "&gt;=", startDate);<br />grComp.addQuery("sys_updated_on", "&lt;=", endDate);<br /><br />// Now add in the second part of the query<br />var grORComp = grComp.addORQuery("sys_created_on", "&gt;=", startDate);<br />grORComp.addCondition("sys_created_on", "&lt;=", endDate);<br /><br />grComp.addAggregate('COUNT');<br />grComp.query();<br /><br />if (grComp.next()) {<br /> gs.print("Count=" + grComp.getAggregate('COUNT'));<br />}<br /><br /><br />Viewing the results:<br /><br />SELECT count(*) AS recordcount FROM (cmdb_ci_computer cmdb_ci_computer0 INNER JOIN cmdb_ci cmdb_ci0 ON cmdb_ci_computer0.`sys_id` = cmdb_ci0.`sys_id` ) WHERE cmdb_ci0.`sys_updated_on` &gt;= '2013-02-04 19:00:00' AND cmdb_ci0.`sys_updated_on` &lt;= '2013-02-05 19:00:00'<br /><br />*** Script: Count=3<br /><br />So, nuts, it ignored the addOrQuery altogether! Next I substituted an addQuery for the addCondition and that was ignored as well.<br /><br /><br />Okay, so try 2:<br /><br />When in doubt break it apart (brute force...there goes the elegence):<br /><br />var startDate = '2013-02-04 19:00:00';<br />var endDate = '2013-02-05 19:00:00';<br /><br />var count = new GlideAggregate('cmdb_ci_computer');<br />count.addQuery('sys_updated_on', "&gt;=", startDate);<br />count.addQuery('sys_updated_on', "&lt;=", endDate);<br />count.addAggregate('COUNT');<br />count.query();<br /> <br />var countCreated = new GlideAggregate('cmdb_ci_computer');<br />countCreated.addQuery('sys_created_on', "&gt;=", startDate);<br />countCreated.addQuery('sys_created_on', "&lt;=", endDate);<br />countCreated.addAggregate('COUNT');<br />countCreated.query();<br /> <br />var recordCount = 0;<br />if (count.next()) {<br /> gs.print("sys_updated_on=" + count.getAggregate('COUNT'));<br /> recordCount += parseInt(count.getAggregate('COUNT'));<br />}<br /> <br />if (countCreated.next()) {<br /> gs.print("sys_created_on=" + countCreated.getAggregate('COUNT'));<br /> recordCount += parseInt(countCreated.getAggregate('COUNT'));<br />}<br /> <br />gs.print("TOTAL COUNT=" + recordCount);<br /><br />Results:<br /><br />SELECT count(*) AS recordcount FROM (cmdb_ci_computer cmdb_ci_computer0 INNER JOIN cmdb_ci cmdb_ci0 ON cmdb_ci_computer0.`sys_id` = cmdb_ci0.`sys_id` ) WHERE cmdb_ci0.`sys_updated_on` &gt;= '2013-02-04 19:00:00' AND cmdb_ci0.`sys_updated_on` &lt;= '2013-02-05 19:00:00'<br /><br />SELECT count(*) AS recordcount FROM (cmdb_ci_computer cmdb_ci_computer0 INNER JOIN cmdb_ci cmdb_ci0 ON cmdb_ci_computer0.`sys_id` = cmdb_ci0.`sys_id` ) WHERE cmdb_ci0.`sys_created_on` &gt;= '2013-02-04 19:00:00' AND cmdb_ci0.`sys_created_on` &lt;= '2013-02-05 19:00:00'<br /><br />*** Script: sys_updated_on=3<br />*** Script: sys_created_on=4<br />*** Script: TOTAL COUNT=7<br /><br />And that worked ok. I got my record count, but had to play the brute force game to get it!<br /><br /><br />4. Next try an encoded query<br /><br />You can hand roll this, or a much easier way is to go through a list view filter. Much simpler in execution and lines-of-code, but harder to maintain. <br /><br />The following wiki article is a good starting point (See section 2. Generating Encoded Query Strings through a Filter):<br /><br />https://wiki.servicenow.com/index.php?title=Embedded:Encoded_Query_Strings#Generating_Encoded_Query_Strings_through_a_Filter<br /><br />After setting everything up in my list view for cmdb_ci_computer I ended up with this encoded query:<br /><br />sys_updated_onBETWEENjavascript:gs.dateGenerate('2013-02-04','19:00:00')@javascript:gs.dateGenerate('2013-02-05','19:00:00')^ORsys_created_onBETWEENjavascript:gs.dateGenerate('2013-02-04','19:00:00')@javascript:gs.dateGenerate('2013-02-05','19:00:00')<br /><br />So, rewriting my GlideAggregate query a bit; I end up with:<br /><br />var startDate = "2013-02-04 19:00:00";<br />var endDate = "2013-02-05 19:00:00";<br /><br />var encodedString = "sys_updated_onBETWEENjavascript:gs.dateGenerate('" + startDate + "')@javascript:gs.dateGenerate('" + endDate + "')^ORsys_created_onBETWEENjavascript:gs.dateGenerate('" + startDate + "')@javascript:gs.dateGenerate('" + endDate + "')";<br /><br />gs.print(encodedString);<br /><br />var grComp = new GlideAggregate("cmdb_ci_computer");<br />grComp.addEncodedQuery(encodedString);<br />grComp.addAggregate('COUNT');<br />grComp.query();<br /><br />if (grComp.next()) {<br /> gs.print("Count=" + grComp.getAggregate('COUNT'));<br />}<br /><br />Results:<br /><br />SELECT count(*) AS recordcount FROM (cmdb_ci_computer cmdb_ci_computer0 INNER JOIN cmdb_ci cmdb_ci0 ON cmdb_ci_computer0.`sys_id` = cmdb_ci0.`sys_id` ) WHERE ((cmdb_ci0.`sys_updated_on` &gt;= '2013-02-05 01:00:00' AND cmdb_ci0.`sys_updated_on` &lt;= '2013-02-06 01:00:00') OR (cmdb_ci0.`sys_created_on` &gt;= '2013-02-05 01:00:00' AND cmdb_ci0.`sys_created_on` &lt;= '2013-02-06 01:00:00'))<br /><br />*** Script: Count=5<br /><br />And what is this??? My count is off by two! Close examination of the results shows that the time was ignored and a new time was substituted! Now that is a problem. I toyed around with this for a bit trying various possibilities...all hand rolled, and found that this appears to be a bug with gs.dateGenerate! Arrrgh!<br /><br />Okay, undaunted, I rolled my own encoded query and this is what I came up with:<br /><br />sys_updated_on&gt;=2013-02-04 19:00:00^2013-02-05 19:00:00^ORsys_created_on&gt;=2013-02-04 19:00:00^2013-02-05 19:00:00<br /><br />So modified my code accordingly and broke it apart (easier to maintain/read/understand):<br /><br />var startDate = "2013-02-04 19:00:00";<br />var endDate = "2013-02-05 19:00:00";<br /><br />var encodedString = "sys_updated_on&gt;=" + startDate + "^sys_updated_on&lt;=" + endDate;<br />encodedString += "^ORsys_created_on&gt;=" + startDate + "^sys_created_on&lt;=" + endDate;<br /><br />var grComp = new GlideAggregate("cmdb_ci_computer");<br />grComp.addEncodedQuery(encodedString);<br />grComp.addAggregate('COUNT');<br />grComp.query();<br /><br />if (grComp.next()) {<br /> gs.print("Count=" + grComp.getAggregate('COUNT'));<br />}<br /><br />Results:<br /><br />SELECT count(*) AS recordcount FROM (cmdb_ci_computer cmdb_ci_computer0 INNER JOIN cmdb_ci cmdb_ci0 ON cmdb_ci_computer0.`sys_id` = cmdb_ci0.`sys_id` ) WHERE cmdb_ci0.`sys_updated_on` &gt;= '2013-02-04 19:00:00' AND (cmdb_ci0.`sys_updated_on` &lt;= '2013-02-05 19:00:00' OR cmdb_ci0.`sys_created_on` &gt;= '2013-02-04 19:00:00') AND cmdb_ci0.`sys_created_on` &lt;= '2013-02-05 19:00:00'<br /><br />*** Script: Count=7<br /><br />Woohoo! That worked! So I now had two working methods. And wonder-of-wonders the encoded version turns out to be pretty easy to maintain. Hey! I got my elegant solution!<br /><br />BTW, I found a sparse number of examples on query string queries, so ended up writing my own dictionary...a start of one anyway (which I will publish after I have polished on it a bit). <br /><br />Enjoy!<br /><br />Steven.</p>