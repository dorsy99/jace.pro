---
title: "Lets make GlideAjax a little more dynamic"
date: 2016-07-10T20:27:54.000Z
authors: ["Göran Lundqvist"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=884d6ee5dbd0dbc01dcaf3231f9619c0"
---
<p>For some time ago I sat and were fouling around with how to populate fields on a catalog item. The thing is that we have our standard changes as catalog items. And depending if it was a call, incident, request etc. that was the source for creating this standard change, different fields should tag along to the standard change and populate some variables on the form. For this I would like to only have one client script handling this and make it as dynamic and easy to add/remove fields which should tag along. I wanted only one place to add that information and not need to head to both my script include and the client script to do so.</p><p></p><p>So this is what I came up with:</p><p></p><p>First this the for example one UI action I use to get into the catalog from a record. In this case incident:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_1468153360426252 jive_text_macro" data-renderedposition="197_8_1192_208" jivemacro_uid="_1468153360426252"><p>//Update saves incident before going to the catalog homepage</p><p>current.update();</p><p>gs.addInfoMessage('You will need to navigate back to incident ' + current.number + ' upon completion');</p><p></p><p>//Getting the table the record is from and the sysID and separating them with a "," so I can easy split them up later</p><p>var info = current.sys_class_name + ',' + current.sys_id;</p><p>var url = "catalog_home.do?sysparm_view=catalog_default&amp;sysparm_processing_hint=" + info;</p><p></p><p>//And into the catalog we go</p><p>action.setRedirectURL(url);</p><p></p><p></p><p></p></pre><p></p><p></p><p>Now, a little heads up. As you can see on the code above, I'm using the parameter "sysparm_processing_hint". This is a parameter that follow with us the whole way when we click through our catalog. I haven't found any other use for it and no documentation for it. But I needed something to tag along the info of the source. But know about the danger it might have using stuff like this. Making my own custom "sysparm_info_to_me" would sadly only tag along to the catalog, but then disappear directly when I clicked on a category or an item.</p><p></p><p>So, we get to the item and the onLoad Catalog client script kicks in. first part of the client script looks like this:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_1468158729343577" data-renderedposition="573_8_1192_368" jivemacro_uid="_1468158729343577"><p>function onLoad()</p><p>{</p><p>   //Get the parameter if the std. change is created from an record.</p><p></p><p></p><p>//Parameter contains both the tablename and sys_id of the record. Seperated with a ,</p><p>   var infosource = getParmVal('sysparm_processing_hint');</p><p></p><p></p><p>//If the parameter exists send it to a script include which returns which fields to populate and with what data</p><p>   if (infosource) {</p><p>   g_form.setValue('sysparmprocessinghint',infosource);</p><p>   var ga = new GlideAjax('getSourceInfo');</p><p>   ga.addParam('sysparm_name','getInfo');</p><p>   ga.addParam('sysparm_process', infosource);</p><p>   ga.getXML(handleAnswer);</p><p>   }</p><p></p><p></p><p></p><p></p><p></p><p></p></pre><p></p><p>Pretty much the standard GlideAjax call. In the beginning you can see that we get the parameter and if that exist we do the call and also send that info with as the parameter sysparm_process. And when we get the result back, the function "handleAnswer" takes care of that. We will get back to it later, but lets us look at the script include.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14681627791074343 jive_text_macro" data-renderedposition="1025_8_1192_736" jivemacro_uid="_14681627791074343"><p>var getSourceInfo = Class.create();</p><p>getSourceInfo.prototype = Object.extendsObject(AbstractAjaxProcessor, {</p><p></p><p>   //Return fields to catalog item form</p><p></p><p>   getInfo: function() {</p><p></p><p>   var fromSysparm = this.getParameter('sysparm_process');</p><p>//Splits the data from the parameter. it looks like TABLE_NAME,SYS_ID</p><p>   var infoSource = fromSysparm.split(',');</p><p>   var toReturn = {};</p><p>//Getting the record from correct table</p><p>   var gr = new GlideRecord(infoSource[0]);</p><p>   gr.get(infoSource[1]);</p><p></p><p></p><p>//Going through the tables is can be and depending on the table, putting in different properties in the object.</p><p>   if (infoSource[0] == 'sc_req_item'){</p><p>   toReturn.requested_for = gr.request.requested_for.toString();</p><p>   toReturn.comments = gr.description.toString();</p><p>   if(gr.u_contact_person != '')</p><p>   toReturn.requested_by = gr.u_contact_person.toString();</p><p>   if(gr.u_alternative_mailaddress != '')</p><p>   toReturn.alternative_address = gr.u_alternative_mailaddress.toString();</p><p></p><p>   }</p><p>   else if(infoSource[0] == 'incident'){</p><p></p><p>   toReturn.requested_for = gr.assigned_to.toString();</p><p>   }</p><p>   else if(infoSource[0] == 'new_call'){</p><p>   toReturn.requested_for = gr.caller.toString();</p><p>   toReturn.comments = gr.description.toString();</p><p>   toReturn.short_description = gr.short_description.toString();</p><p>   if(gr.u_alternative_mailaddress != '')</p><p>   toReturn.alternative_address = gr.u_alternative_mailaddress.toString();</p><p>   }</p><p></p><p>//Returning the object as a JSON</p><p>   return JSON.stringify(toReturn);</p><p>   },</p><p>   type: 'getSourceInfo'</p><p>});</p><p></p><p></p><p></p></pre><p></p><p>So the Script include takes the tablename and sys_id and fetches the record. then depending on which table it's, it put different properties into the object "toReturn" which in the end is the object that the script include returns. To get this all to work, it's VERY important that the objects properties has the same name as the variable/field it is going to populate in the client script.</p><p></p><p>Now lets see what the Catalog client script does with the data the script include returns. It uses the function "handleAnswer" to do this:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_14681637426866658 jive_macro_code jive_text_macro" data-renderedposition="1887_8_1192_192" jivemacro_uid="_14681637426866658"><p>function handleAnswer(response){</p><p></p><p>   var answer = response.responseXML.documentElement.getAttribute("answer");</p><p>//Convert the answer to a JSON since it was stringified to a JSON in the script include</p><p>   var doJson = JSON.parse(answer);</p><p>//this gets all the properties(Which name is identically to the variable their are going to put data in)</p><p>//Then the forEach put each value into the correct field.</p><p>   Object.getOwnPropertyNames(doJson).forEach(function(val,idx, array){</p><p>   g_form.setValue(val,doJson[val]);</p><p></p><p>   });</p><p>}</p></pre><p></p><p>Here I parse the answer back to a JSON object and then I use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">Object.getOwnPropertyNames() - JavaScript | MDN</a> to get all the property names and loop through them and set the correct values. This way, if I want to add another variable to populate, I can just add it in the script include and it will automagically fill in on the form with the client script.</p>