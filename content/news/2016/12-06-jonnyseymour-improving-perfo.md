---
title: "Improving performance when importing data with more than one field as coalesce key"
date: 2016-12-05T11:00:27.000Z
authors: ["jonnyseymour"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=a87dae29dbd0dbc01dcaf3231f9619a9"
---
<p>If you are planning to import thousands of records into your instance and you have a complex coalesce key to update data, this post is for you. Easy import, data load, and import sets are wonderfully designed to <a title="" _jive_internal="true" href="https://docs.servicenow.com/bundle/geneva-servicenow-platform/page/administer/import_sets/task/t_ImportDataUsingImportSets.html" rel="nofollow" target="_blank">import data into your instance.</a></p><p></p><p>ServiceNow uses two steps to import data:</p><ol><li>Loading</li><li>Transforming</li></ol><p></p><p>Data import is crafted to a very high specification, where the loading happens on the <a title="" _jive_internal="true" href="https://docs.servicenow.com/bundle/geneva-servicenow-platform/page/administer/import_sets/concept/c_DataSources.html" rel="nofollow" target="_blank">Data Sources</a> while the transforming happens on the <a title="" _jive_internal="true" href="https://docs.servicenow.com/bundle/geneva-servicenow-platform/page/script/server_scripting/concept/c_CreatingNewTransformMaps.html" rel="nofollow" target="_blank">Transformation maps</a>. Each execution is controlled by an <a title="" _jive_internal="true" href="https://docs.servicenow.com/bundle/geneva-servicenow-platform/page/administer/import_sets/task/t_ImportDataUsingImportSets.html" rel="nofollow" target="_blank">Import set</a> that displays the history of the data imported. Transformations maps can have <a title="ocs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/import-sets/concept/c_ImportSetCoalesce.html" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/import-sets/concept/c_ImportSetCoalesce.html">coalesce field</a> (keys to avoid duplicates) to allow them to update records.</p><p></p><p>I will focus on showing an example of a transformation map with a "complex key" (more than one field as coalesce) to update the target records which also avoid duplicates from reference fields (see below) and make one just one query (instead of multiple internal queries if selecting multiple coalesce fields).</p><p></p><p><img   alt="choose_a_door.png" class="image-35 jive-image" height="161" src="8d52673ddb5c9f04e9737a9e0f96192a.iix" style="width: 238px; height: 161.364px; display: block; margin-left: auto; margin-right: auto;" width="238"/></p><p></p><p>On a transformation map, one, or several, 'coalesce' fields define when a record is updated. Whilst the transformation maps are flexible and configurable, when using complex "keys" some transformations are better with a "field map script" as coalesce (aka "<a title="ocs.servicenow.com/bundle/geneva-servicenow-platform/page/administer/managing_data/reference/r_CoalesceOptions.html" href="https://docs.servicenow.com/bundle/geneva-servicenow-platform/page/administer/managing_data/reference/r_CoalesceOptions.html">conditional coalesce</a>").</p><p></p><h3>A few notes on coalesce fields:</h3><ul><li>Coalesce field searches benefit from indexes on the target data field they are mapped to.</li><li>sys_id is indexed on all tables, making searches faster if they are used for mappings.</li><li>Using a <a title="ocs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/field-administration/concept/c_ReferenceField.html" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/field-administration/concept/c_ReferenceField.html">reference field</a> as coalesce can cause duplicates if the referenced data has duplicates (see below).</li><li>Setting multiple fields as coalesce, they could cause multiple queries for each of the coalesce fields on the target data, increasing import times.</li></ul><p></p><p>On my example, I will use the alm_stock_rule table. To the untrained eye, you would think it contains only strings, and integers.</p><p><img   alt="alm_stock_rule.png" class="image-21 jive-image" src="e31ec10edb189f048c8ef4621f9619af.iix" style="width: 620px; height: 88px; display: block; margin-left: auto; margin-right: auto;"/></p><p>A closer look at the alm_stock_rule table show the fields <strong>Model</strong>, <strong>Parent stockroom</strong>, and <strong>Stockroom</strong> are references to another table data (<a title="ocs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/field-administration/concept/c_ReferenceField.html" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/field-administration/concept/c_ReferenceField.html">Reference fields</a>). Reference fields store a sys_id for each referenced record in the database, but the sys_id is not shown. The reference field shows the <a title="ocs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/field-administration/concept/c_DisplayValues.html" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/field-administration/concept/c_DisplayValues.html">display value.</a></p><pre __default_attr="warning" __jive_macro_name="alert" alert="warning" class="jive_text_macro jive_macro_alert" data-renderedposition="901.2666625976562_8_1102_64"><p>(empty) or blank does not means the reference field is empty. It could be that the reference field display value is (empty) or blank. Always validate this by reviewing if it contains a sys_id value or not on the record itself e.g. Review the XML data of the record.</p></pre><p><img   alt="stock rule table.png" class="image-22 jive-image" src="d7592c8edb54dfc03eb27a9e0f961996.iix" style="width: 620px; height: 392px; display: block; margin-left: auto; margin-right: auto;"/></p><p></p><h2>Coalesce using one-to-one field mapping on the transformation map</h2><p>On reference fields, you can import data using the sys_id of the target 'referenced' data. However, most times, you would like to import data into "alm_stock_rule", using the display value instead to match the existing records.</p><p><img   alt="import data.jpg" class="image-23 jive-image" src="4dc680c6db9cd3041dcaf3231f96191a.iix" style="width: 620px; height: 325px; display: block; margin-left: auto; margin-right: auto;"/></p><p></p><p>For this example, we would use "Stockroom", "Model", "Parent stockroom", "restocking option" as key for updates.</p><p></p><p>On this <a title="ocs.servicenow.com/bundle/helsinki-servicenow-platform/page/script/server-scripting/task/t_CreateATransformMap.html" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/script/server-scripting/task/t_CreateATransformMap.html">transformation map</a>, we would define the "Stockroom", "Model", "Parent stockroom", "restocking option" fields with coalesce <strong>"true"</strong></p><p><img   alt="transform map.png" class="image-24 jive-image" src="ac64e339db541fc03eb27a9e0f9619e8.iix" style="width: 620px; height: 189px; display: block; margin-left: auto; margin-right: auto;"/></p><p><img   alt="duplicated reference.jpg" class="image-25 jive-image" src="350c0d8adbd497049c9ffb651f961975.iix" style="width: 620px; height: 262px; display: block; margin-left: auto; margin-right: auto;"/>Here is a list of pros and cons I've generated on using one-to-one field mapping on the transformation map for the coalesce fields:</p><p></p><table border="1" cellpadding="0" style="border: 1pt solid windowtext; width: 100%;"><tbody><tr><td style="border: solid windowtext 1.0pt; background: #BDD6EE; padding: .75pt .75pt .75pt .75pt;" valign="top" width="203"><p><strong>PROS</strong></p></td><td style="border: solid windowtext 1.0pt; background: #BDD6EE; padding: .75pt .75pt .75pt .75pt;" valign="top" width="23"><p></p></td><td style="border: solid windowtext 1.0pt; background: #BDD6EE; padding: .75pt .75pt .75pt .75pt;" valign="top" width="219"><p><strong>CONS</strong></p></td></tr><tr><td style="border: solid windowtext 1.0pt; padding: .75pt .75pt .75pt .75pt;" valign="top" width="203"><p>It is very configurable per field</p></td><td style="border: solid windowtext 1.0pt; padding: .75pt .75pt .75pt .75pt;" valign="top" width="23"><p></p></td><td style="border: solid windowtext 1.0pt; padding: .75pt .75pt .75pt .75pt;" valign="top" width="219"><p>You have no control on the final searches performed to match the coalesce fields values to the target data. This means that more than one search could be triggered. Worst case scenario is that more than one per each coalesce fields may be triggered.</p></td></tr><tr><td style="border: solid windowtext 1.0pt; background: #DEEAF6; padding: .75pt .75pt .75pt .75pt;" valign="top" width="203"><p>It is easy to understand</p></td><td style="border: solid windowtext 1.0pt; background: #DEEAF6; padding: .75pt .75pt .75pt .75pt;" valign="top" width="23"><p></p></td><td style="border: solid windowtext 1.0pt; background: #DEEAF6; padding: .75pt .75pt .75pt .75pt;" valign="top" width="219"><p>If some of the coalesce fields source data is empty, it can trigger a query for (field=NULL) and the remaining <a _jive_internal="true" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/import-sets/concept/c_ImportSetCoalesce.html"><span style="color: windowtext;">coalesce fields</span></a> which is unlikely to follow the indexes</p></td></tr><tr><td style="border: solid windowtext 1.0pt; padding: .75pt .75pt .75pt .75pt;" valign="top" width="203"><p>No scripting is required</p></td><td style="border: solid windowtext 1.0pt; padding: .75pt .75pt .75pt .75pt;" valign="top" width="23"><p></p></td><td style="border: solid windowtext 1.0pt; padding: .75pt .75pt .75pt .75pt;" valign="top" width="219"><p>It depends on the field mapping options available</p></td></tr><tr><td style="border: solid windowtext 1.0pt; background: #DEEAF6; padding: .75pt .75pt .75pt .75pt;" valign="top" width="203"><p>You can map more than the display value of the reference field by using "referenced value field name"</p></td><td style="border: solid windowtext 1.0pt; background: #DEEAF6; padding: .75pt .75pt .75pt .75pt;" valign="top" width="23"><p></p></td><td style="border: solid windowtext 1.0pt; background: #DEEAF6; padding: .75pt .75pt .75pt .75pt;" valign="top" width="219"><p>If some of the coalesce fields data holds very limited values (e.g. choice field) and the target table is very large, the query could be slow. e.g. you add impact as part of you coalesce fields, and your target table is incident. There is a case where query could be "select ... from incident where impact = 1" which could be a large query if you have a large incident table.</p></td></tr><tr><td style="border: solid windowtext 1.0pt; padding: .75pt .75pt .75pt .75pt;" valign="top" width="203"><p>It is easier see which fields on the target table requires indexes (if the data is unique enough)</p></td><td style="border: solid windowtext 1.0pt; padding: .75pt .75pt .75pt .75pt;" valign="top" width="23"><p></p></td><td style="border: solid windowtext 1.0pt; padding: .75pt .75pt .75pt .75pt;" valign="top" width="219"><p>It could cause duplicates if reference fields are used as coalesce (see below)</p></td></tr></tbody></table><p></p><pre __default_attr="info" __jive_macro_name="alert" alert="info" class="jive_text_macro jive_macro_alert" data-renderedposition="2788.2666015625_8_1102_43"><p>Duplicate records could appear if reference fields are used as coalesce.</p></pre><p></p><h3>Notes on coalesce on reference fields</h3><p>In this example, the model we are importing is "APC 42U 3100 SP2 NetShelter." I have created two records on the model referenced table (it is not the target table itself but the 'Product Model' table which is referenced by 'model'). As this happens, the coalesce fields will match two, then the import will create a new unwanted record instead of updating it. This is a common problem as not all tables holds unique values.</p><p><img   alt="import data coalesce.jpg" class="image-26 jive-image" src="1f4a80cadbdc5fc03eb27a9e0f9619d0.iix" style="width: 620px; height: 333px; display: block; margin-left: auto; margin-right: auto;"/></p><p>On the import set, those records will show as <strong>State = Inserted</strong> when it should show ignored or updated</p><p><img   alt="duplicate model.jpg" class="image-27 jive-image" src="37e42771db90dfc0b322f4621f9619de.iix" style="width: 620px; height: 227px; display: block; margin-left: auto; margin-right: auto;"/></p><pre __default_attr="warning" __jive_macro_name="alert" alert="warning" class="jive_text_macro jive_macro_alert" data-renderedposition="3584.7666015625_8_1102_43"><p>Using a <a title="ocs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/field-administration/concept/c_ReferenceField.html" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/field-administration/concept/c_ReferenceField.html">reference field</a> as <a title="ocs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/import-sets/concept/c_ImportSetCoalesce.html" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/import-sets/concept/c_ImportSetCoalesce.html">coalesce </a>can cause duplicates if the referenced data has duplicates</p></pre><p><img   alt="reference coalesce.jpg" class="image-28 jive-image" src="ec2e0942db14d304b322f4621f961992.iix" style="width: 620px; height: 97px; display: block; margin-left: auto; margin-right: auto;"/></p><p></p><h2>Coalesce on field map scripts</h2><p>An alternative coalesce would be a "Script" mapping to the target "sys_id".</p><p>For this example, I will explain a technique of creating a simple <a title="ocs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/import-sets/concept/c_ImportSetCoalesce.html" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/import-sets/concept/c_ImportSetCoalesce.html">coalesce field</a> by field map script to the sys_id of the target. As sys_id have an index already, so the last search with the script result as <a title="ocs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/import-sets/concept/c_ImportSetCoalesce.html" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/import-sets/concept/c_ImportSetCoalesce.html">coalesce</a> is minimal. You would like to do this to have more flexibility on the final search generated to update your data.</p><p></p><p>When using a field map script, the previous example <a title="ocs.servicenow.com/bundle/helsinki-servicenow-platform/page/script/server-scripting/task/t_CreateATransformMap.html" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/script/server-scripting/task/t_CreateATransformMap.html">transformation map</a> would look as follow:</p><p><img   alt="field map script.jpg" class="image-29 jive-image" src="4c69e48adb909304b322f4621f961965.iix" style="width: 620px; height: 177px; display: block; margin-left: auto; margin-right: auto;"/></p><p>Then set the field map script to match the sys_id on the target and make it the ONLY with <a href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/administer/import-sets/concept/c_ImportSetCoalesce.html"><strong>coalesce = true</strong></a>.</p><p><img   alt="coalesce true.png" class="image-30 jive-image" src="8ac6ccc2dbd8db048c8ef4621f961918.iix" style="width: 620px; height: 343px; display: block; margin-left: auto; margin-right: auto;"/></p><p>On the field map script, add the script to find the correct target record:</p><p><img   alt="target record.png" class="image-31 jive-image" src="85646b71db1493041dcaf3231f96191e.iix" style="width: 620px; height: 173px; display: block; margin-left: auto; margin-right: auto;"/></p><p></p><p>Here is the script I used to find the target record:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_15067998534216095 jive_text_macro" data-renderedposition="4777.2666015625_8_1102_688" jivemacro_uid="_15067998534216095"><p>answer = function(a) {   <br/>         var list_to_compare=[["u_stockroom","stockroom.display_name"],   <br/>                   ["u_parent_stockroom","parent_stockroom.display_name"],   <br/>                   ["u_restocking_option","restocking_option"],   <br/>                   ["u_model","model.display_name"]];   <br/>         return findmatch(list_to_compare, source, map.target_table,false,true);   <br/> }(source);   </p><p></p><p>/* Function findmatch is use on transformation maps to find a match with multiple coalesce fields</p><p></p><p>vlist: list of fields to compare, Array = [[ "source_field","target_field"],...]   Target field allows dot walk. <br/>vsource: source record,   <br/>vtarget: target record,   <br/>nomatchcreate: true will create record if there is no match)   <br/>debugon: true will log the information about the matching results <br/> <br/>Returns sys_id of the target record, or null if error or if nomatchcreate = false and no match is found. <br/> <br/>Coalesce empty fields need to be OFF, so null answer (e.g on error), insert is cancelled <br/>*/   <br/>function findmatch(vlist, vsource, vtarget, nomatchcreate, debugon) {<br/>try {<br/>       vtarget = new GlideRecord(vtarget + "");<br/>       // Check the source fields coalesce has a value to add to the query <br/>       for (var h = vlist.length, c = 0; c &lt; h; c++) <br/>               vsource[vlist[c][0]].hasValue() &amp;&amp; <br/>               vsource.isValidField(vlist[c][0]) &amp;&amp; <br/>               vtarget.addQuery(vlist[c][1], "=", vsource[vlist[c][0]].getDisplayValue());</p><p></p><p>       vtarget.setLimit(1);<br/>       vtarget.query();<br/>       var d;<br/>       vtarget.next() ? <br/>                 // if we find a match, we return the sys_id, otherwise, if nomatchcreate = false returns null <br/>               (d = vtarget.sys_id, debugon &amp;&amp; (log.info("source: " + vsource.sys_id + " - record match: " + d), vsource.sys_import_state_comment = "record match: " + d)) : <br/>               // If no match is found it validates whether a new sys_id is required<br/>               nomatchcreate ? <br/>                       d = gs.generateGUID() :<br/>                       (d = null, debugon &amp;&amp; (log.info("source: " + vsource.sys_id + " - record match: None"), vsource.sys_import_state_comment = "record match: None"));<br/>       return d<br/>} catch (f) {<br/>       return log.error("script error: " + f), vsource.sys_import_state_comment = "ERROR: " + f, null<br/>}};</p></pre><p></p><p>The script gives you flexibility to set the search that better meet your business requirements.</p><pre __default_attr="warning" __jive_macro_name="alert" alert="warning" class="jive_text_macro jive_macro_alert" data-renderedposition="5521.2666015625_8_1102_64"><p>Ensure you set "coalesce empty field" unchecked (OFF), because if an error happens on the query or field script, it will return null, then it will ignore the record coalesce field is matching null</p></pre><p></p><p>You can see this example is center the updates on only one query that depends on the values available.</p><p>After opening the data source and clicking on "Load All Records", then transforming them, the import set data will show as follow:</p><p><img   alt="load all records.png" class="image-32 jive-image" src="e60cc5c2db54130468c1fb651f96196d.iix" style="width: 620px; height: 215px; display: block; margin-left: auto; margin-right: auto;"/></p><p>On the import set, the import set rows tab will show the records would match the correct value this time.</p><p><img   alt="import set records.jpg" class="image-33 jive-image" src="e0b66002db14dfc03eb27a9e0f9619c3.iix" style="width: 620px; height: 243px; display: block; margin-left: auto; margin-right: auto;"/></p><p>The imported data will insert the new record, and update the existing one, even when the referenced model has duplicated data, the field map script will match the right record.</p><p><img   alt="duplicated data.png" class="image-34 jive-image" src="2e2508c2db9c5704ed6af3231f961900.iix" style="width: 620px; height: 261px; display: block; margin-left: auto; margin-right: auto;"/></p><p>Using the field map script, we know it will only execute ONE search on the target form, and allow you to define any query that identify uniquely your target record, giving you flexibility and increasing performance on updates.</p><p></p><p>I've tested using Helsinki, using Google chrome as the browser.</p><p></p><p></p><h4>For more information on transforming your data see:</h4><p>Video demos:</p><ul><li><a title="utu.be/ffmQg8aOXEo" href="http://youtu.be/ffmQg8aOXEo">Troubleshooting Truncated Data</a></li><li><a title="utu.be/AXpfvXo1JN8" href="http://youtu.be/AXpfvXo1JN8">Troubleshooting Missing Data in Date Fields</a></li><li><a title="utu.be/jZna_EtZFZ4" href="http://youtu.be/jZna_EtZFZ4">Troubleshooting ServiceNow Export Limits</a></li></ul><p></p><p>Importing and Exporting data:</p><ul><li><a title="" _jive_internal="true" href="/community?id=community_blog&sys_id=fa6d2e29dbd0dbc01dcaf3231f96199a">Transforming your data: "Load All Records" vs. "Test Load 20 Records"</a></li><li><a title="" _jive_internal="true" href="/community?id=community_question&sys_id=ff684beddb1cdbc01dcaf3231f961999">Exporting Large Data Sets?</a></li><li><a title="" _jive_internal="true" href="/community?id=community_blog&sys_id=200d2aa5dbd0dbc01dcaf3231f96194a">Increasing the Export Limit</a></li><li><a title="" _jive_internal="true" href="/community?id=community_blog&sys_id=0c2de2e5dbd0dbc01dcaf3231f961930">Exporting large data sets into Excel</a></li><li><a title="" _jive_internal="true" href="/community?id=community_blog&sys_id=259dea69dbd0dbc01dcaf3231f961968">How to make sure your import/export ship has sailed</a></li><li><a title="i.service-now.com/kb_view_customer.do?sysparm_article=KB0538434" href="https://hi.service-now.com/kb_view_customer.do?sysparm_article=KB0538434">Troubleshooting an import that fails</a></li><li><a title="i.service-now.com/kb_view.do?sysparm_article=KB0538436" href="https://hi.service-now.com/kb_view.do?sysparm_article=KB0538436">Troubleshooting an import that is taking a long time to complete</a></li><li><a title="i.service-now.com/kb_view.do?sysparm_article=KB0538437" href="https://hi.service-now.com/kb_view.do?sysparm_article=KB0538437">Troubleshooting an import that does not complete or is missing data</a></li><li><a title="i.service-now.com/kb_view.do?sysparm_article=KB0538458" href="https://hi.service-now.com/kb_view.do?sysparm_article=KB0538458">Troubleshooting export issues</a></li><li><a title="i.service-now.com/kb_view.do?sysparm_article=KB0538459" href="https://hi.service-now.com/kb_view.do?sysparm_article=KB0538459">Troubleshooting issues with transform maps</a></li><li><a title="ki.servicenow.com/index.php?title=Import_Sets" href="http://wiki.servicenow.com/index.php?title=Import_Sets">Import Sets</a></li><li><a title="ki.servicenow.com/index.php?title=Importing_Data_Using_Import_Sets" href="http://wiki.servicenow.com/index.php?title=Importing_Data_Using_Import_Sets">Importing Data Using Import Sets</a></li><li><a title="ki.servicenow.com/index.php?title=Scheduling_Data_Imports" href="http://wiki.servicenow.com/index.php?title=Scheduling_Data_Imports">Scheduling Data Imports</a></li><li><a title="ki.servicenow.com/index.php?title=Troubleshooting_Import_Set_Performance" href="http://wiki.servicenow.com/index.php?title=Troubleshooting_Import_Set_Performance">Troubleshooting Import Set Performance</a></li><li><a title="i.service-now.com/kb_view.do?sysparm_article=KB0541631" href="https://hi.service-now.com/kb_view.do?sysparm_article=KB0541631">Import &amp; Export Resources</a></li><li><a title="Tips to improve the run time of imports" __default_attr="4917" __jive_macro_name="blogpost" class="jive_macro jive_macro_blogpost" data-orig-content="Tips to improve the run time of imports" data-renderedposition="7141.2666015625_38_262_17" href="/community?id=community_blog&sys_id=7adc2a65dbd0dbc01dcaf3231f9619a9">Tips to improve the run time of imports</a></li></ul><p></p><p>Transforming your data:</p><p><a title="Validating the order of execution for transform map scripts" __default_attr="5350" __jive_macro_name="blogpost" class="jive_macro jive_macro_blogpost" data-orig-content="Validating the order of execution for transform map scripts" data-renderedposition="7207.06689453125_8_383_17" href="/community?id=community_blog&sys_id=69ada2a9dbd0dbc01dcaf3231f961996">Validating the order of execution for transform map scripts</a></p>