---
title: "Clientside GlideRecord replacement for Scoped Applications sort of"
date: 2016-05-26T03:41:30.000Z
authors: ["coryseering"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=272e6a6ddbd0dbc01dcaf3231f9619cd"
---
<p>In my previous blog post <a title="Scoped Applications and Client Scripts: A Primer" __default_attr="4742" __jive_macro_name="blogpost" class="jive_macro jive_macro_blogpost" data-orig-content="Scoped Applications and Client Scripts: A Primer" data-renderedposition="10_166.1875_327_16" href="/community?id=community_blog&sys_id=788c66e1dbd0dbc01dcaf3231f961969">Scoped Applications and Client Scripts: A Primer</a>   I point out some of the differences between the APIs available to a scoped client script and a global one. One of the APIs that is explicitly removed is client-side GlideRecord. There are a few reasons that access to this particular API has been removed. A few of the top reasons are:</p><ul><li>It results in large data transfers</li><li>Its almost exclusively used to get the value of a single field</li><li>Almost everyone uses it synchronously</li><li>It can hold open a database connection</li></ul><p></p><p>I wrote another post about <a title="Using utilities in Scoped Applications to replace inaccessible APIs" __default_attr="5351" __jive_macro_name="blogpost" class="jive_macro jive_macro_blogpost" data-orig-content="Using utilities in Scoped Applications to replace inaccessible APIs" data-renderedposition="170.984375_177.578125_432_16" href="/community?id=community_blog&sys_id=5f1ea26ddbd0dbc01dcaf3231f961909">Using utilities in Scoped Applications to replace inaccessible APIs</a> . The example in that case was replacing an auto-generated encoded query string which used an inaccessible API directly within the query. We can expand on that concept, this time on the client rather than the server.</p><p></p><h2>UI Script as a utility class</h2><p>Keeping within the spirit laid out in <a title="Background and Philosophy of Scoped Applications" __default_attr="4957" __jive_macro_name="blogpost" class="jive_macro jive_macro_blogpost" data-orig-content="Background and Philosophy of Scoped Applications" data-renderedposition="263.984375_227.109375_346_16" href="/community?id=community_blog&sys_id=801e6e2ddbd0dbc01dcaf3231f9619d8">Background and Philosophy of Scoped Applications</a>   we want a lightweight, asynchronous robust method for making REST calls. Also, we don't want to be limited to just the table APIs. We will create a single UI Script in this post, but this would work with multiple scripts as well.</p><p></p><p>Our client-side scripts (such as onChange and onLoad client scripts) can access the ScriptLoader class. This is an asynchronous JavaScript library that is used for just-in-time loading UI scripts. Thanks to the default structure of our UI Scripts, we can load a UI Script once and access it from multiple places. Additionally, the ScriptLoader knows what it has loaded already, so we can safely ask it to load our utilities multiple times and be sure that it will do so only once.</p><p></p><h3>Understanding the UI Script template</h3><p>To start with, we need a UI Script. When we create a UI Script in our application, we get a template that we can build on. A new UI Script would look like this:</p><p><img   alt="Screen Shot 2016-05-25 at 1.13.08 PM.PNG" class="image-1 jive-image" src="eaa6ff7ddb50d3041dcaf3231f9619a5.iix" style="width: 620px; height: 423px;"/></p><p></p><p>There are a lot of comments in the code, but it <em>looks</em> a lot more complicated than it is. Before we actually write our UI Script, let's break down what this template is telling us.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14642073425358928 jive_text_macro" data-renderedposition="963.984375_8_1192_16" jivemacro_uid="_14642073425358928"><p>var sn_ui_script_util = sn_ui_script_util || {};</p></pre><p></p><p>This line creates a variable named sn_ui_script_util, and sets its value to itself, or to an empty object. This is code that runs on the browser, so this is saying <em>If we already have an object in the page named after our scope, we're going to use that. Otherwise, let's create an empty object.</em></p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_14642074909785336" data-renderedposition="1063.984375_8_1192_32" jivemacro_uid="_14642074909785336"><p>sn_ui_script_util.Utilities = (function() {</p><p>   "use strict";</p></pre><p></p><p>These two lines add a "Utilities" property to our scope object, and set its value to the result of a function execution. The function itself must run in <a title="eveloper.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">strict mode</a>. This prevents us from accidentally creating global variables and gives us errors when we make mistakes.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14642077701649300 jive_text_macro" data-renderedposition="1179.984375_8_1192_272" jivemacro_uid="_14642077701649300"><p>/* set your private variables and functions here. For example: </p><p>   var privateVar = 0; </p><p>   function private_function() {</p><p>   return ++privateVar;</p><p>   }</p><p>*/</p><p></p><p></p><p>/* Share variables between multiple UI scripts by adding them to your scope object. For example: </p><p>   sn_ui_script_util.sharedVar = 0; </p><p></p><p></p><p> Then access them in your scripts the same way. For example: </p><p>   function get_shared() {</p><p>   return sn_ui_script_util.sharedVar;</p><p>   }</p><p>*/</p></pre><p></p><p>There are three different but connected things going on in the lines above. Firstly, we create a private variable that can only be accessed within this UI Script, and function that changes that variable. Nothing outside of the code written in this UI Script can read the value of that private variable, and nothing can change it.</p><p></p><p>Second, we create another variable, but this one is public. It exists on our scoped object, but it can be accessed by outside scripts. They can read and write to this shared variable, but it's not polluting the global namespace.</p><p></p><p>Lastly, we define a function that will return a reference to our shared variable. This is nothing new or groundbreaking, and since other scripts can access out variable directly, it's not strictly necessary. However, it is impolite to trample someone else's variables and properties, so if they give you a function to access them, you should use that function.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_14642081523549243 jive_macro_code jive_text_macro" data-renderedposition="1661.984375_8_1192_128" jivemacro_uid="_14642081523549243"><p>       return {</p><p>               /* set your public API here. For example:</p><p>               incrementAndReturnPrivateVar: function() {</p><p>                       return private_function();</p><p>               },</p><p>               */</p><p>               type:   "Utilities"</p><p>       };</p></pre><p></p><p></p><p>Here, we are defining the public API. In this example, we are saying that our API is one function named "incrementAndReturnProvateVar". Scripts can call this method and they will increment the value of the private variable we declared earlier, and see the result. We could also add our get_shared function if we wanted to.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14642086013369294 jive_text_macro" data-renderedposition="1894.984375_8_1192_16" jivemacro_uid="_14642086013369294"><p>})();</p></pre><p>Finally, we just close out our function definition, and execute it.</p><p></p><h3>Creating the utility</h3><p>So, with that framework, we can create our REST utility. I wrote this today and haven't put a lot of testing into it, but it should work as an example. Note that, while I'm happy to accept fixes and comments about things which might not work with it, I am not offering to support it. This is a demonstration, not a full-fledged solution.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_14642090368442226 jive_macro_code jive_text_macro" data-renderedposition="2039.984375_8_1192_2704" jivemacro_uid="_14642090368442226"><p>var sn_ui_script_util = sn_ui_script_util || {};</p><p></p><p>sn_ui_script_util.Utilities = (function () {</p><p>       "use strict";</p><p></p><p>       function xhrSupportsJSON() {</p><p></p><p>               if (typeof XMLHttpRequest == 'undefined') {</p><p>                       return false;</p><p>               }</p><p></p><p>               var xhr = new XMLHttpRequest();</p><p>               xhr.open('get', '/', true);</p><p></p><p>               try {</p><p>                       // some browsers throw when setting `responseType` to an unsupported value</p><p>                       xhr.responseType = 'json';</p><p>               } catch (error) {</p><p>                       return false;</p><p>               }</p><p></p><p>               return 'response' in xhr &amp;&amp; xhr.responseType == 'json';</p><p>       }</p><p></p><p>       function getXHR() {</p><p>               var xhr = typeof XMLHttpRequest != 'undefined' ?</p><p>                       new XMLHttpRequest() :</p><p>                       new ActiveXObject('Microsoft.XMLHTTP');</p><p>               return xhr;</p><p>       }</p><p></p><p>       function getParamString(params, q) {</p><p>               if (!q)</p><p>                       q = '';</p><p>               else</p><p>                       q = '?';</p><p></p><p>               var parts = [];</p><p>               for (var key in params) {</p><p>                       if (params.hasOwnProperty(key))</p><p>                               parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));</p><p>               }</p><p>               return parts.length ? q + parts.join('&amp;') : '';</p><p>       }</p><p></p><p>       function urlIsRelative(url) {</p><p>               return !url.startsWith('http');</p><p>       }</p><p></p><p>       return {</p><p></p><p>               rest: function (type) {</p><p>                       var params = {};</p><p>                       var headers = {};</p><p>                       var parts = [];</p><p>                       var successHandler = function (data) {</p><p>                               try {</p><p>                                       console.log("Success!");</p><p>                                       console.log(data);</p><p>                               } catch (e) {</p><p>                                       //boo</p><p>                               }</p><p>                       };</p><p></p><p>                       var errorHandler = function (data) {</p><p>                               try {</p><p>                                       console.log("Error!");</p><p>                                       console.log(data);</p><p>                               } catch (e) {</p><p>                                       //boo</p><p>                               }</p><p>                       };</p><p></p><p>                       var obj = {</p><p>                               get: function (url) {</p><p>                                       if (!url)</p><p>                                               errorHandler();</p><p></p><p>                                       url = url + getParamString(params, true);</p><p></p><p>                                       if (urlIsRelative(url))</p><p>                                               headers['X-UserToken'] = g_ck;</p><p></p><p>                                       var xhr = getXHR();</p><p>                                       var useJSON = type == 'json' &amp;&amp; xhrSupportsJSON();</p><p>                                       if (useJSON)</p><p>                                               xhr.responseType = 'json';</p><p></p><p>                                       xhr.open('get', url, true);</p><p>                                       for (var hdr in headers)</p><p>                                               if (headers.hasOwnProperty(hdr))</p><p>                                                       xhr.setRequestHeader(hdr, headers[hdr]);</p><p></p><p>                                       xhr.onreadystatechange = function () {</p><p>                                               var status;</p><p>                                               var data;</p><p></p><p>                                               if (xhr.readyState == 4) { // `DONE`</p><p>                                                       status = xhr.status;</p><p></p><p>                                                       if (status == 200) {</p><p>                                                               data = useJSON ? xhr.response : type == 'json' ? JSON.parse(xhr.responseText) : xhr.responseXML;</p><p>                                                               successHandler &amp;&amp; successHandler(data);</p><p>                                                       } else {</p><p>                                                               errorHandler &amp;&amp; errorHandler(status);</p><p>                                                       }</p><p>                                               }</p><p>                                       };</p><p></p><p>                                       xhr.send();</p><p>                               },</p><p></p><p>                               post: function (url) {</p><p>                                       if (!url)</p><p>                                               errorHandler();</p><p></p><p>                                       if (urlIsRelative(url))</p><p>                                               headers['X-UserToken'] = g_ck;</p><p></p><p>                                       var xhr = getXHR();</p><p>                                       var useJSON = type == 'json' &amp;&amp; xhrSupportsJSON();</p><p>                                       if (useJSON)</p><p>                                               xhr.responseType = 'json';</p><p></p><p>                                       xhr.open('POST', url, true);</p><p>                                       for (var hdr in headers)</p><p>                                               if (headers.hasOwnProperty(hdr))</p><p>                                                       xhr.setRequestHeader(hdr, headers[hdr]);</p><p></p><p>                                       xhr.onreadystatechange = function () {</p><p>                                               var status;</p><p>                                               var data;</p><p>                                               if (xhr.readyState == 4) { // `DONE`</p><p>                                                       status = xhr.status;</p><p></p><p>                                                       if (status == 200) {</p><p>                                                               data = useJSON ? xhr.response : type == 'json' ? JSON.parse(xhr.responseText) : xhr.responseXML;</p><p>                                                               successHandler &amp;&amp; successHandler(data);</p><p>                                                       } else {</p><p>                                                               errorHandler &amp;&amp; errorHandler(status);</p><p>                                                       }</p><p>                                               }</p><p>                                       };</p><p></p><p>                                       xhr.send(getParamString(params));</p><p>                               },</p><p></p><p>                               addParam: function (name, value) {</p><p>                                       params[name] = value;</p><p>                               },</p><p></p><p>                               addHeader: function (name, value) {</p><p>                                       headers[name] = value;</p><p>                               },</p><p></p><p>                               success: function (successCallback) {</p><p>                                       successHandler = successCallback;</p><p>                               },</p><p></p><p>                               error: function (errorCallback) {</p><p>                                       errorHandler = errorCallback;</p><p>                               }</p><p>                       }</p><p></p><p>                       return obj;</p><p>               },</p><p>               type: "Utilities"</p><p>       };</p><p>})();</p></pre><p></p><h3>What?</h3><p>OK, so that is a lot of code. But you should be able to break it down, using the explanation provided earlier. This is a UI Script with some private functions and variables, which returns a public API that has one method named 'rest'. When we call that, we get an object that allows us to make GET and POST requests, and to accept either XML or JSON. All the rest is just "the stuff that makes that work".</p><p></p><h3>Using our Utility</h3><p>Now that we have a utility defined, we want to make use of it. We have a fairly generic way to make REST requests, and we want to replace at least some of the functionality of client-side GlideRecord. Let's use a common example: get the value of a single field off a referenced record. Let's get the Department of an incident caller, and add that to the work notes of an incident. We'll do that onChange of the Caller field.</p><p></p><p><img   alt="Screen Shot 2016-05-25 at 3.29.33 PM.PNG" class="image-2 jive-image" src="48d6d50adbd4d304b322f4621f9619b3.iix" style="width: 620px; height: 488px;"/></p><p>Here is the code we are using:</p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14642154402071730 jive_text_macro" data-renderedposition="5513.984375_8_1192_320" jivemacro_uid="_14642154402071730"><p>function onChange(control, oldValue, newValue, isLoading, isTemplate) {</p><p>       if (isLoading || newValue === '') {</p><p>               return;</p><p>       }</p><p>       ScriptLoader.getScripts('sn_ui_script_util.Utilities.jsdbx', getDepartment);</p><p></p><p>       function getDepartment() {</p><p>               var req = sn_ui_script_util.Utilities.rest('json');</p><p>               req.addParam("sysparm_query", "sys_id=" + newValue);</p><p>               req.addParam("sysparm_fields", "department");</p><p>               req.addParam("sysparm_display_value", true);</p><p>               req.success(updateNotes);</p><p></p><p>               req.get("/api/now/table/sys_user");</p><p>       }</p><p></p><p>       function updateNotes(data) {</p><p>               g_form.setValue("work_notes", data.result[0].department.display_value);</p><p>       }</p><p>}</p></pre><p></p><p>We have the ScriptLoader fetching our utility script for us, and then calling our function to get the value of the caller's department. When that comes back, we'll update the worknotes field.</p><p>You can combine multiple UI Scripts under one namespace (your scope object on the client-side), and multiple scripts can call the ScriptLoader to load them. Think of it like saying "I require the REST utility, so if it isn't already loaded, go get it."</p><p></p><p>This is just one example of a way you can write your own utilities which are scope-safe, asynchronous, and take advantage of the power of ServiceNow's built-in REST API's. There is nothing stopping you from calling your own script REST endpoints, too. And with scoped apps and dependencies, you can keep all these nifty scripts and tools in one application, and simply depend on them for your other apps. It's a very handy way to write-once, use-everywhere.</p>