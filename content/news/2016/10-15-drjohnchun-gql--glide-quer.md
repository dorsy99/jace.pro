---
title: "GQL Glide Query Language Part  The Parser"
date: 2016-10-14T20:32:58.000Z
authors: ["drjohnchun"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=71ed6ee9dbd0dbc01dcaf3231f96197e"
---
<p><a title="" _jive_internal="true" href="/community?id=community_blog&sys_id=f04ee2addbd0dbc01dcaf3231f961902">Last time</a>, we looked at the GQL syntax and how to handle raw and display values of columns. This time, we'll look at the parser, which is closely tied to the GQL syntax, and see how GQL statements can be parsed into various parts for execution. We're not skipping the processor; we'll come back to it later.</p><p></p><p><strong>PARSER</strong></p><p></p><p>Let's go step by step and see how we can parse a GQL statement. The below example we saw last time may help you follow the steps:</p><p></p><pre __default_attr="sql" __jive_macro_name="code" class="_jivemacro_uid_14764575439382508 jive_macro_code jive_text_macro" data-renderedposition="142_8_981_160" jivemacro_uid="_14764575439382508"><p>SELECT   -- sample GQL statement</p><p>   number [Number]</p><p>   , short_description [Title]</p><p>   , dv_state [State]</p><p>   , caller_id.email [Caller Email]</p><p>   , caller_id.manager.email [Manager Email]</p><p>   , dv_cmdb_ci</p><p>FROM incident</p><p>WHERE active=true^priority&lt;2^EQ^ORDERBYpriority^ORDERBYDESCnumber</p><p>LIMIT 5,10</p></pre><p></p><p><strong>A. Remove comments</strong></p><p></p><p>A comment starts with two dashes "--" and ends with the end-of-line; all comments and their zero or more preceding white spaces will be removed first before further processing using</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_14763904935992492 jive_macro_code jive_text_macro" data-renderedposition="428_8_981_16" jivemacro_uid="_14763904935992492"><p>var no_comments = query.replace(/\s*--.*/g,'');</p></pre><p></p><p>This is not foolproof in case there are double dashes elsewhere not meant to be for comments (e.g., column headings), but let's keep it simple for now.</p><p></p><p><strong>B. Breakdown into parts</strong></p><p></p><p>A GQL statement has the following four main parts in the following order we defined last time:</p><p></p><ol><li><strong>SELECT</strong> - mandatory; always starts with this.</li><li><strong>FROM</strong> - mandatory</li><li><strong>WHERE</strong> - optional (also contains ORDERBY from encoded query strings)</li><li><strong>LIMIT</strong> - optional</li></ol><p></p><p>Let's try to pick out these four parts using a regular expression. Regular expression may not be the best tool for parsing, but it may work adequately for our simple logic.</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_14764033210918909 jive_macro_code jive_text_macro" data-renderedposition="772.984375_8_981_32" jivemacro_uid="_14764033210918909"><p>// parse "SELECT select_list FROM table WHERE encoded_query_string LIMIT [offset,] row_count" where WHERE and LIMIT are optional</p><p>var regexp = /SELECT\s*([^]+?)\s*FROM\s*(.+?)\s*(?:WHERE\s*([^]+?(?=\s*LIMIT)|[^]+?)\s*)?(?:LIMIT\s*([,\d\s]+?)\s*)?$/</p></pre><p></p><p>Here's what this does in more detail:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14763930443932386 jive_text_macro" data-renderedposition="867.984375_8_981_96" jivemacro_uid="_14763930443932386"><p><span style="color: rgba(0, 0, 0, 0); font-family: Consolas, 'Courier New', Courier, mono, serif; font-size: 12px;">var regexp = </span>/</p><p>SELECT\s*([^]+?)\s*   // look for SELECT and capture what follows <span>([^]+?) including white spaces [^]</span>, but ignore zero or more surrounding white spaces \s*</p><p>FROM\s*(.+?)\s*           // look for FROM and capture what follows except white spaces (table names don't have spaces)</p><p>(?:WHERE\s*([^]+?(?=\s*LIMIT)|[^]+?)\s*)?   // look for optional WHERE clause; if found, capture what follows until LIMIT is encountered or to end of line</p><p>(?:LIMIT\s*([,\d\s]+?)\s*)?   // look for optional LIMIT clause and capture numbers separated by a comma</p><p>$/   // continue to the end of the last line</p></pre><p></p><p>Let me clarify a few things since regular expressions, while compact and powerful, are not always self explanatory.</p><p></p><p>In Line 2, "<span style="font-family: 'courier new', courier;">[^]</span>" represents ALL characters, both white spaces and the rest, so the SELECT list can be written in single or multiple lines. This could also be written as "<span style="font-family: 'courier new', courier;">[\s\S]</span>" but "<span style="font-family: 'courier new', courier;">[^]</span>" is a shorthand (technically, the first caret inside square brackets indicates "exclude the following characters"; since there's no following characters in this case, it excludes none, leading to represent <em>all</em> characters). This leads us to use the lazy quantifier "?" in "<span style="font-family: 'courier new', courier;">([^]+?)</span>" to tell it to "match as few times as possible" and not to capture trailing white spaces; without "?", it gets greedy and keeps going until it sees "FROM" since "<span style="font-family: 'courier new', courier;">[^]</span>" means <em>all</em> characters.</p><p></p><p>Line 4 is a non-capture group, indicated by "<span style="font-family: 'courier new', courier;">(?:</span>" meaning "match what follows but don't capture." However, what's in the inner parentheses "<span style="font-family: 'courier new', courier;">([^]+?(?=\s*LIMIT)|[^]+)</span>" will still be captured and it'll capture the encoded query string that follows WHERE. The inner parentheses could've been simply "<span style="font-family: 'courier new', courier;">([^]+?)</span>" if we mandated that encoded query strings must be on a single line. Since we're not mandating it, we have to use the positive lookahead "<span style="font-family: 'courier new', courier;">(?=\s*LIMIT)</span>" to tell it to "stop when you see LIMIT". The second part in the inner parentheses "<span style="font-family: 'courier new', courier;">|[^]+?</span>" means to "go all the way to the end if you don't see LIMIT". Line 4 ends with "?" to match 0 or 1 time since the WHERE clause is optional.</p><p></p><p>Line 6 ends with an anchor, the end of last line "$", to tell lazy quantifiers not to be too lazy and go all the way to the end.</p><p></p><p>This works well for both single or multiple lines, and whether white spaces are removed or not. We'll add only a simple syntax checker later. A good way to test if a regular expression works as intended is to use an online tool like <a title="w.gethifi.com/tools/regex" href="http://www.gethifi.com/tools/regex">hifi RegExp Tool</a>; it shows the capture groups in different colors, which is useful for testing. Also, you can view a saved copy of this regex at <a href="https://regex101.com/r/ZRm0G1/1" title="https://regex101.com/r/ZRm0G1/1">regex101.com</a></p><p></p><p>When this regular expression is executed, it returns four capture groups corresponding to the four main parts of a GQL statement.</p><p></p><p><strong>C. SELECT</strong></p><p></p><p>The SELECT part consists of a list of one or more column names, with optional column headings enclosed in square brackets, separated by commas. We'll use</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14764031757171553 jive_text_macro" data-renderedposition="1551.984375_8_981_32" jivemacro_uid="_14764031757171553"><p>// split column list "column_1, column_2 [column_2_heading], column_3"</p><p>var columns = select.split(/\s*,\s*/);</p></pre><p></p><p>to get an array of columns. For each column, we'll check for column heading and, if it exists, parse it out using:</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14764028221834307 jive_text_macro" data-renderedposition="1646.984375_8_981_32" jivemacro_uid="_14764028221834307"><p>// parse out "column_name [column_heading]" where "[column_heading]" is optional</p><p><span style="color: rgba(0, 0, 0, 0); font-family: Consolas, 'Courier New', Courier, mono, serif; font-size: 12px;">var regexp = </span>/([.\w]+)\s*(?:\[(.+)\])?/</p></pre><p></p><p><strong>D. FROM</strong></p><p></p><p>The FROM part simply contains the table name, which we can pass on to either of</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_14764586298243458 jive_macro_code jive_text_macro" data-renderedposition="1783.984375_8_981_32" jivemacro_uid="_14764586298243458"><p>var gr = new GlideRecord(table);</p><p>var gr = new GlideRecordSecure(table)   // enforce ACL</p></pre><p></p><p>from <a title="ki.servicenow.com/?title=List_of_Scoped_Scriptable_Objects" href="http://wiki.servicenow.com/?title=List_of_Scoped_Scriptable_Objects">Scoped GlideRecord</a>.</p><p></p><p><strong>E. WHERE</strong></p><p></p><p>The optional WHERE part contains an encoded query string with filter and/or order conditions. We can pass this straight to</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_14764566038148482" data-renderedposition="1962.984375_8_981_16" jivemacro_uid="_14764566038148482"><p>gr.addEncodedQuery(encodedQuery);</p></pre><p></p><p>from <a title="ki.servicenow.com/?title=Scoped_GlideRecord_API_Reference#addEncodedQuery.28String_query.29" href="http://wiki.servicenow.com/?title=Scoped_GlideRecord_API_Reference#addEncodedQuery.28String_query.29">Scoped GlideRecord</a>.</p><p></p><p><strong>F. LIMIT</strong></p><p></p><p>The optional LIMIT part gives the offset, which is optional, and row_count. After parsing the integers using <span style="font-family: 'courier new', courier;">parseInt()</span>, we can pass these on to either of</p><p></p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code jive_text_macro _jivemacro_uid_14764569424164705" data-renderedposition="2125.984375_8_981_32" jivemacro_uid="_14764569424164705"><p>gr.chooseWindow(offset, offset + row_count);</p><p>gr.setLimit(row_count);</p></pre><p></p><p>from <a title="ki.servicenow.com/?title=Scoped_GlideRecord_API_Reference#chooseWindow.28Number_f.2C_Number_l.2C_Boolean_forceCount.29" href="http://wiki.servicenow.com/?title=Scoped_GlideRecord_API_Reference#chooseWindow.28Number_f.2C_Number_l.2C_Boolean_forceCount.29">Scoped GlideRecord</a>.</p><p></p><p><a title="" _jive_internal="true" href="/community?id=community_blog&sys_id=235e2eaddbd0dbc01dcaf3231f961929">Next time</a>, we'll continue with the rest of the design.</p><p></p><p><em>Please feel free to connect, follow, post feedback / questions / comments, share, like, bookmark, endorse.</em></p><p>John Chun, <span style="font-size: 8pt;">PhD PMP</span> <a href="http://linkedin.com/in/DrJohnChun"><img alt="see John's LinkedIn profile" class="image-2 jive-image" src="http://megaicons.net/static/img/icons_sizes/182/456/16/linkedin-icon.png" style="height: auto; vertical-align: -13px;" title="see John's LinkedIn profile"/></a></p><p><a href="http://snowaid.com/"><img alt="visit snowaid" class="image-1 jive-image" src="http://snowaid.com/images/signature.png" style="height: auto; margin-top: -9px;" title="visit snowaid"/></a></p>