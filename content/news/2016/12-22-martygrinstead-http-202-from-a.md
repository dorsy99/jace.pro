---
title: "HTTP  from an Inbound Web Service Call"
date: 2016-12-21T22:49:42.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=ee3eee6ddbd0dbc01dcaf3231f961949"
---
<p><a title="ocs.servicenow.com/bundle/istanbul-servicenow-platform/page/integrate/inbound-web-services/concept/c_InboundWebServices.html" href="https://docs.servicenow.com/bundle/istanbul-servicenow-platform/page/integrate/inbound-web-services/concept/c_InboundWebServices.html">Inbound web services</a> allow you to access and modify ServiceNow data using a client application.   When the client application calls the web service exposed by your ServiceNow instance, a return code (also called the "<a title="n.wikipedia.org/wiki/List_of_HTTP_status_codes" href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">status code</a>") will be provided in the response. The return code tells us how the request was handled. A status code in the 200 range (200, 201, 202) indicates a successful attempt to transmit the data from the client to the web server hosting the web service.</p><p></p><p>If you follow our <a title="ocs.servicenow.com/bundle/helsinki-servicenow-platform/page/integrate/web-services/reference/r_AvailableWebServices.html" href="https://docs.servicenow.com/bundle/helsinki-servicenow-platform/page/integrate/web-services/reference/r_AvailableWebServices.html">Web Services</a> Best Practices and configure your client to re-use the ServiceNow session, you may encounter a "202" return code in your client application.   This does not indicate something is wrong, but it is important, as a client developer, to understand what implication this has concerning the request that you just sent into ServiceNow.   Let's first look at exactly what a 202 really means:</p><p></p><p></p><table border="1"><tbody><tr><td><p style="font-size: 20px; margin-bottom: 8px; color: #333333; font-family: 'Source Code Pro'; text-align: center;"><span style="color: #d6156d;">202</span> ACCEPTED</p><p style="margin-bottom: 10px; font-size: 18px; color: #556270; font-family: 'Open Sans', sans-serif;">The request has been accepted for processing, but the processing has not been completed. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place.</p></td></tr></tbody></table><p></p><p></p><p>The web service call being made from your client code has made it into ServiceNow, but the code tells us that the request might, or might not, be acted upon.   The big question now is, "<strong>What will happen to my request if I get a 202 return code?</strong>".   That is the ultimate question that this investigation will answer.</p><h2></h2><p></p><h2>Causes of an HTTP 202 code</h2><p>The cause of an HTTP 202 happens when a web service reuses the same session and requests come in quicker than they can be processed. As a result, we have too many requests for the same session waiting. This leads to new requests being returned with the 202 return code.</p><p></p><p>I ran a very contrived test that was designed to confirm exactly what happens when one session is used to send in many requests more quickly than they could be processed, and we exceed the default tuning values.</p><p></p><p></p><h2>Testing the results of a request returning a 202 code</h2><p>In my Geneva instance (also confirmed in Istanbul), I created a scripted REST web service that has a built-in 45 second delay.   This REST service simply echoes the input value back to the client, and also updates a table with the input string and the timestamp that the web service was actually executed.   This allowed me to confirm what data was received by the web service and exactly when the script executed code and processed the data.</p><p></p><p>My Scripted REST code is:</p><pre __default_attr="java" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14819014103794053 jive_text_macro" data-renderedposition="757_8_1192_288" jivemacro_uid="_14819014103794053"><p>(function process(/*RESTAPIRequest*/ request, /*RESTAPIResponse*/ response) {</p><p>gs.sleep(45000);</p><p>var body = request.body.data,   echoString;</p><p></p><p></p><p>echoString =   body.inputString;</p><p></p><p>var gr = new GlideRecord("u_counter");</p><p>   gr.u_curtime = gs.nowDateTime();</p><p>   gr.u_inputstring = echoString;</p><p>   gr.insert();</p><p></p><p>return {</p><p>   "inputString": echoString</p><p>};</p><p></p><p></p><p>})(request, response);</p></pre><p></p><p>I also created a table called u_counter, which has 2 fields, u_curtime and u_inputstring.</p><p></p><h3><span style="font-size: 14pt;">Running the HTTP 202 test</span></h3><p>Since this was a REST service, I used <a title="url.haxx.se/docs/manpage.html" href="https://curl.haxx.se/docs/manpage.html">curl</a> to call the web service. Curl provides a way to capture the cookies returned with the request, and also a way to reuse those cookies.</p><p></p><p>Here's the code from my shell script:</p><pre __default_attr="javascript" __jive_macro_name="code" class="_jivemacro_uid_14811714704925497 jive_macro_code jive_text_macro" data-renderedposition="1198_8_1192_336" jivemacro_uid="_14811714704925497"><p>#!/bin/sh</p><p></p><p>run_curl_command()</p><p>{</p><p># This command will be called in a loop that uses the cookie values stored in the cookiefile.txt file</p><p><span>curl "</span><a title="" _jive_internal="true" href="https://" rel="nofollow" target="_blank">https://</a><span>&lt;Instance_Name&gt;.service-now.com/api/now/delay45" -v --request POST \</span></p><p>--header "Accept:application/json" --cookie cookiefile.txt   --header "Content-type:application/json" \</p><p> --data '{"inputString":"Loop Counter '"$i"'"}' </p><p>}</p><p></p><p># This command is called 1 time to seed the cookie jar with the cookie values required for session reuse.</p><p><span>curl "</span><a title="" _jive_internal="true" href="https://" rel="nofollow" target="_blank">https://</a><span>&lt;Instance_Name&gt;.service-now.com/api/now/delay45/DelayedEcho" -v --request POST \</span></p><p> --header "Accept:application/json" --cookie-jar cookiefile.txt   --header "Content-type:application/json" \</p><p>   --data '{"delayTime":"1" ,"inputString":"Kickoff Message"}' --user 'admin':'fake_admin_password' </p><p></p><p># Loop 99 times, each loop runs in the background, so we can fire all 99 loops without </p><p># waiting for the previous request to complete before starting the next</p><p>#     (basically, run 99 loops as quickly as we can, firing off 99 REST calls)</p><p>for i in {2..100}; do</p><p>             run_curl_command &amp;</p><p>done</p></pre><p>The script will call the web service once, passing in the credentials the first call, but will then store all of the response cookies (including the session details) in the cookie jar.   Then, we loop 99 times (for a total of 100 web service calls) that will pass in the existing cookies, and the loop counter, so we can track exactly how many of the 100 requests are processed, and with the loop counter being recorded, we can also see which calls actually complete.</p><p></p><p>We can see from the load balancer logs that, out of the 100 requests, we had 12 HTTP 200 and 88 HTTP 202 result codes returned. The number of 200's exactly matches the number of records that were updated in the table.</p><pre __default_attr="success" __jive_macro_name="alert" alert="success" class="jive_text_macro jive_macro_alert" data-renderedposition="1674_8_1192_44"><p><span style="color: #5ab45c;"><strong>When an HTTP 202 result code is returned, we do not process that request</strong>. </span></p></pre><p></p><p>When I pull a report from our Load Balancer (using Splunk), we can see the following details:</p><p><img   alt="http 202.jpg" class="image-3 jive-image" src="3cb4898adb149f048c8ef4621f961993.iix" style="width: 620px; height: 91px; display: block; margin-left: auto; margin-right: auto;"/></p><p>We can see that there were a total of 100 events captured, and the return codes show that we had 12 "HTTP 200" and 88 "HTTP 202" responses. Looking at the table that inserts all of the records that are processed through the scripted web service, we can see:</p><p><img   alt="http 202 events.jpg" class="image-4 jive-image" src="9036458adb10d304b322f4621f9619c4.iix" style="width: 620px; height: 240px; display: block; margin-left: auto; margin-right: auto;"/></p><p>12 records were inserted, and client requests received an HTTP 200.   All other requests were received by the web server, but did not get passed into the application code, and were never acted upon. This confirms that when a status code of 200 is returned, the data is processed by the web service.   It also confirms that when a 202 is returned, the data is not processed by the web service.</p><p></p><p>Client applications should monitor the result code, and if a 202 is found, the request should be re-submitted (if it is important that all data be processed), but instead of using the cookie jar to reuse the session, a new session should be created and cookies stored for later reuse. Depending on what is typical for your environment and data, a return code of 202 may indicate a performance issue with your instance, so you may need to evaluate the calls being made and compared the expected execution time with the actual time.</p>