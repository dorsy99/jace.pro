---
title: "Service Level Agreements  Overriding TaskSLAController Functions"
date: 2016-04-16T04:50:21.000Z
authors: ["edwajs"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=f40e6a2ddbd0dbc01dcaf3231f961935"
---
<p>When working with Service Level Agreements, you may run into situations where you have a business requirement which is not met by the base functionality of the <a title="i.service-now.com/kb_view.do?sysparm_article=KB0550781" href="https://hi.service-now.com/kb_view.do?sysparm_article=KB0550781">2011 SLA Engine</a>.   In this blog post I will show you how to achieve a desired functionality that is not possible with the base code. We'll satisfy a specific use case with a targeted/focused manner which will allow you to receive fixes and improvements to the base code, while at the same time, protecting your modifications.</p><p></p><p>Here are your options to proceed:</p><ol><li>Change the requirements so they can be met with the base functionality.</li><li>Use bolt-on business rules and other scripts to manipulate the data outside the engine to get the desired results</li><li>Modify the base code so it provides the desired functionality</li></ol><p></p><p>The problem with the third option is you will no longer get updates to the base code, because our upgrade process protects your customizations.   The correct method for implementing these changes is to create a script include to extend a base class, and create override functions only where needed to alter the functionality.   This allows you to receive updates to the base code, but protects your changes.</p><p></p><p><span style="line-height: 1.5;">In this post I am going to review a possible set of business requirements, discuss some design considerations, review the pros and cons for the using the base code, and provide an example of changing SLA function by providing overrides to base code, specifically TaskSLAController.</span></p><p></p><h2>Design Considerations:</h2><p>Let's address the following business requirements:</p><ol><li>An organization has a number of groups for incident assignment.</li><li>Any incident may be assigned or re-assigned back and forth between groups while it is being worked.</li><li>The organization needs to track the amount of time the incident is assigned to each group.</li></ol><p></p><p>If the requirement is only to measure the time spent in each different assignment group, the most efficient way to gather the data is going to be with <a title="ocs.servicenow.com/bundle/geneva-performance-analytics-and-reporting/page/use/advanced_reporting/concept/c_MetricDefinitionSupport.html" href="https://docs.servicenow.com/bundle/geneva-performance-analytics-and-reporting/page/use/advanced_reporting/concept/c_MetricDefinitionSupport.html">metrics.</a> The Metric plugin provides an easy way of defining metrics. When the metrics are defined, the data will be gathered, and instances of the metric will be calculated and stored to give you a better idea of incident handling.</p><p></p><p>Assume your organization is determined to implement these requirements as Service Level Agreements.   One possible way to implement this is using the base<a title="ki.servicenow.com/index.php?title=Getting_Started_with_SLAs#Moving_from_the_2010_Engine_to_the_2011_Engine" href="http://wiki.servicenow.com/index.php?title=Getting_Started_with_SLAs#Moving_from_the_2010_Engine_to_the_2011_Engine"> 2011 SLA engine</a> without any modifications:</p><ul><li>Create an SLA definition for each assignment group.</li><li>The Start condition needs to include each assignment_group.</li><li>Whenever the assignment_group changes, the existing SLA will be cancelled and a new SLA will be attached.</li></ul><p></p><h4>Advantages of this approach are:</h4><ul><li>It does not require modifications to the SLA Engine.</li><li>Reporting is based on the SLA Definitions referenced in the task_sla data.</li></ul><p></p><h4>Some drawbacks of this approach are:</h4><ul><li>There are multiple task_sla records for the same assignment group if the incident is reassigned back and forth frequently in its life cycle.</li><li>The more groups you have, the more SLA Definitions you need.<ul><li>A large number of SLA definitions is a maintenance issue.</li><li>A large number of SLA definitions on any particular table can have an adverse impact on performance.   Every associated insert/update of an incident requires the evaluation of each SLA definition, even though most of them do not apply.</li></ul></li><li>It is not possible to pause the task_sla records for a group if the assignment changes to a different group, and then unpause them and continue if the assignment changes back.   This is because of the need to code the assignment group in the Start condition.   The SLA will always be cancelled when the assignment group changes, as documented <a title="i.service-now.com/kb_view.do?sysparm_article=KB0547389" href="https://hi.service-now.com/kb_view.do?sysparm_article=KB0547389">here</a>.</li></ul><p></p><p>With a relatively minor set of customizations (a few simple business rules, a custom field on task_sla, a custom field on task) you can meet the above reporting requirements with a single SLA definition using a Reset condition.   This approach avoids the drawbacks due to large numbers of SLA definitions, but again, you cannot do the pause/unpause operation.   The individual SLAs will not be cancelled, however, because a Reset will cause the running SLA to be completed instead.</p><h2></h2><h2>Refined Requirements:</h2><p>Because of the disadvantages listed above, the requirements can be further refined.</p><ol><li>One task_sla record needs to be created for each assignment_group ever assigned to the incident.</li><li>The task_sla record should be paused whenever the current task is not assigned to that group.</li><li>No other SLA Definitions are impacted by the special processing required for these task_sla records.</li></ol><p></p><p>These requirements cannot be met by the base 2011 SLA Engine, because changes of the assignment group will result in records being cancelled (or completed), not paused.   Also, it is not possible to have one SLA definition associated to more than one active task_sla record because the base code detects the active record and prevents another from being attached.</p><p></p><p>At this point, we can look at using bolt-on business rules and other scripts to manipulate the data outside the engine.   It would make the most sense to look into the possibility of doing the minor customization described above so you could have a single SLA definition, and then combine it with business rules on task_sla.   At any given time, only one of the records for any assignment group would be active, all the others would be marked Completed.   If it was assigned back to a group, the custom logic would need to find the existing Completed task_sla for that group, and find a way to merge it into the new record.   There are several complexities to this merge, and it still is not possible to have the records Paused.</p><p></p><p>With these refined requirements, it becomes necessary to create changes to apply to base processing.   Here is an example of <span style="line-height: 1.5;">implementing these requirements using script includes to extend the base TaskSLAController script include and providing overrides to specific functions.</span></p><p></p><h2><span style="font-size: 16px; line-height: 1.5;">Example:</span></h2><p>1.   Add a custom string field to contract_sla, called u_special_processing_type, and provide a choice for it with value 'special' and label 'Special'.</p><p><img   alt="dictionary entry SLA.jpg" class="image-11 jive-image" src="440ee406db585f048c8ef4621f961920.iix" style="width: 620px; height: 388px; display: block; margin-left: auto; margin-right: auto;"/></p><p></p><p>2.   Add a custom reference field for sys_user_group to task_sla, called u_assignment_group, to track the assignment_group for the task_sla record.</p><p><img   alt="dictionary entry assignment sla.jpg" class="image-12 jive-image" src="3a9a4002db909704ed6af3231f961945.iix" style="width: 620px; height: 385px; display: block; margin-left: auto; margin-right: auto;"/></p><p>3.   Add a 'before-insert' business rule to task_sla called 'Populate Assignment Group'</p><ul><li>For Filter Conditions, make it SLA definition.Special processing type is Special.</li><li>For the script, make it:</li></ul><pre __default_attr="plain" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_1460654536794544 jive_text_macro" data-renderedposition="2449.3125_8_1192_48" jivemacro_uid="_1460654536794544"><p>function onBefore(current, previous) {</p><p>   current.u_assignment_group = current.task.assignment_group;</p><p>}</p></pre><p><img   alt="SLA override task.jpg" class="image-13 jive-image" src="9fadaffddb1c1704ed6af3231f9619db.iix" style="width: 620px; height: 435px; display: block; margin-left: auto; margin-right: auto;"/></p><p>4.   Create a custom script include to extend TaskSLAController called TaskSLAControllerMagic containing:</p><ul><li>One new function, <strong>queryMostTaskSLAs()</strong>, used as an alternative when building a filter of already-attached SLA Definitions, so we do not exclude our special processing SLA definitions.   <em>Note: queryTaskSLAs() needs to be present and unmodified for proper evaluation of task_sla records once they are attached.</em></li><li>A modified version of <strong>function _processNewSLAs_criticalSection()</strong>, with one line of code changed so the query of active SLAs uses queryMostTaskSLAs() instead of queryTaskSLAs().</li><li>A modified version of<strong> function _checkNewSLA()</strong>, with a block of code after attach() condition processing to determine if one of these task_sla records already exists for the assignment group; if it was not attached yet, it will attach another task_sla for this contract_sla but for this assignment_group.</li><li>A modified version of<strong> function _pauseUnpause()</strong>, which includes an additional check after pause() condition processing to see if this is a special processing SLA and if the task assignment_group does not match the task_sla assignment_group, to ensure the pause.</li></ul><p></p><p><img   alt="Screen Shot 2016-04-12 at 3.14.45 PM.png" class="image-6 jive-image" height="296" src="c94f288adb949344e9737a9e0f9619aa.iix" style="width: 736px; height: 295.582329317269px; display: block; margin-left: auto; margin-right: auto;" width="736"/></p><p style="text-align: center;"><img   alt="Screen Shot 2016-04-12 at 3.23.37 PM.png" class="image-7 jive-image" height="239" src="4adc80cedb9c1304b322f4621f9619fe.iix" style="width: 739px; height: 238.411055276382px;" width="739"/></p><p style="text-align: center;"><img   alt="Screen Shot 2016-04-12 at 3.26.39 PM.png" class="image-8 jive-image" height="240" src="1340ff71db989b048c8ef4621f96191d.iix" style="width: 742px; height: 239.38688085676px;" width="743"/></p><p><img   alt="Screen Shot 2016-04-12 at 3.28.57 PM.png" class="image-9 jive-image" height="181" src="d763150adbd89f048c8ef4621f961993.iix" style="width: 742px; height: 181.957788944724px; display: block; margin-left: auto; margin-right: auto;" width="743"/></p><p>5.   Change the 'Run SLAs' business rule script to call TaskSLAControllerMagic(), instead of TaskSLAController().</p><p><img   alt="run sla business script.jpg" class="image-14 jive-image" src="54f21502dbd4d344e9737a9e0f9619dc.iix" style="width: 620px; height: 209px; display: block; margin-left: auto; margin-right: auto;"/></p><p></p><p>6.   Finally, create a new SLA Definition for Table is Incident:</p><ul><li>Name:   Test Assignment</li><li>Process type:   Special</li><li>Start Condition:   Active is true</li><li>Stop Condition:   Active is false</li><li>Pause Condition:   Incident State is one of Awaiting Problem/Awaiting User Info/Awaiting Evidence/Resolved.</li><li>User Duration:   1 (24 hour) day</li></ul><h2></h2><p>After you complete the example set-up, you can test it and verify it produces the task_sla records as expected by following these steps:</p><ol><li>Create a new P1 incident, but leave the assignment_group empty; you will get one P1 task_sla.</li><li>Set the assignment_group to Network and Save; you will get one of the new Test Assignment SLAs for Network.</li><li>Change the assignment_group to Service Desk and Save; the Test Assignment SLA for Network will be Paused, and you will get a new Test Assignment SLA for Service Desk.</li><li>Clear out the assignment_group and Save; both of the Test Assignment SLAs will be Paused.</li><li>Change the assignment_group to Software and Save; you will get one more In Progress Test Assignment SLA for Software.</li><li>Now resolve the incident and save it; all of the Test Assignment SLAs will be Paused.</li><li>Close the incident, and all of the SLAs will be Completed.</li></ol><p></p><p>If you follow these recommendations, you will be able to satisfy<span style="font-size: 14px; font-weight: normal; line-height: 1.5;"> Service Level Agreement requirements that could not be met using base functionality.   We discussed different methods of achieving the requirements and I provided you with an example of one method of achieving these requirements.   </span><span style="line-height: 1.5;">The advantage of this method is you achieve the desired functionality not possible with the base code.   However, it is done in a targeted/focused manner which allows you to receive fixes and improvements to the base code while at the same time protecting your modifications.</span></p>