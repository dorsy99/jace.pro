---
title: "DurationCalculator Facade object"
date: 2016-02-20T02:23:13.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=edfce2a5dbd0dbc01dcaf3231f961937"
---
<p>All,</p><p></p><p>I am using this DurationCalculator facade object to simplify a duration calculation for the most common use-case that we face.</p><pre __default_attr="javascript" __jive_macro_name="code" class="jive_macro_code _jivemacro_uid_14559129376443130 jive_text_macro" data-renderedposition="70_8_1122_672" jivemacro_uid="_14559129376443130" modifiedtitle="true"><p>//@param strDateTime1: string in YYYY-MM-DD hh:mm:ss format</p><p>//@param strDateTime2: string in YYYY-MM-DD hh:mm:ss format</p><p>//@param scheduleId: sys_id for entry in cmn_schedule.   If omitted, the 8-5 week days excluding holidays schedule will be used</p><p>//Never returns a negative number. If strDateTime2 precedes strDateTime1 getDurationSeconds will return zero</p><p>//Prevents troublesome off by GMT offset errors</p><p>//<span style="color: rgba(0, 0, 0, 0); font-family: Consolas, 'Courier New', Courier, mono, serif; font-size: 12px;">getDurationSeconds() is the only public method exposed on this object</span></p><p>var u_durationCalculator = function (strDateTime1, strDateTime2, scheduleId) {   </p><p>   </p><p>       var outerScope = this;   </p><p>       //If they didn't provide a schedule ID default to the 8-5 week days excluding holidays schedule   </p><p>       this.scheduleId = (!JSUtil.nil(scheduleId)) ? scheduleId : '090eecae0a0a0b260077e1dfa71da828';     </p><p>       this.timeZone = gs.getSession().getTimeZone();   </p><p>       this.dt1 = correctStringDateTimeForGMT(strDateTime1);   </p><p>       this.dt2 = correctStringDateTimeForGMT(strDateTime2);   </p><p>   </p><p>   // Convert the string parameter to GlideDateTime using the assumption that the string provided was user TZ localized and needs to be converted to GMT</p><p>       function correctStringDateTimeForGMT(stringDateTime) {   </p><p>               var dt = new GlideDateTime(stringDateTime);   </p><p>               dt.getLocaltime();   </p><p>               var offSetInSeconds = dt.getTZOffset() / 1000; //convert from millis   </p><p>               var multiplier = (offSetInSeconds &lt; 0) ? -1 : 1;   </p><p>               dt.addSeconds(multiplier * offSetInSeconds);   </p><p>               return dt;   </p><p>       }   </p><p>   </p><p>       function getDurationSeconds() {   </p><p>               var dc = new DurationCalculator();   </p><p>               dc.setSchedule(outerScope.scheduleId, outerScope.timeZone);   </p><p>               var ans = dc.calcScheduleDuration(outerScope.dt1.getDisplayValue(), outerScope.dt2.getDisplayValue());   </p><p>               return ans;   </p><p>       }   </p><p>   </p><p>       return {   </p><p>               getDurationSeconds: getDurationSeconds   </p><p>       };   </p><p>};   </p><p>   </p><p>//Example usage   </p><p>var dc = new u_durationCalculator ('2016-02-19 12:00:00', '2016-02-22 09:30:00');   </p><p>gs.print('Duration Hours:' + dc.getDurationSeconds() / 3600);   </p><p>//Output   </p><p>*** Script: Duration Hours:6.5   </p></pre><p></p><p>The "<span style="color: #222222; font-family: arial, sans-serif; font-size: 16px;"><strong>façade </strong></span>" design pattern is used to provide a simplified interface.   Those who have used the existing DateTime function library may have also stumbled into the pitfalls.   I would love it if others were interested in joining me in an effort to create other facade objects for common use-cases involving DateTime calculations.</p><p></p><p>Godspeed,</p><p></p><p>Trey Carroll</p>