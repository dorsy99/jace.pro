---
title: "Troubleshooting SLAs"
date: 2012-07-07T01:28:50.000Z
authors: ["Mwatkins"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=6aecae65dbd0dbc01dcaf3231f961900"
---
<p><p>Howdy,<br />Today I'm going to talk about how to troubleshoot SLA's. Troubleshooting SLA's is no simple task. There are a lot of moving parts to the SLA engine and the engine itself has changed multiple times over the last 3 years. With this in mind, my goals for this article are two-fold. First I'd like to give a brief explanation of the workings of the current SLA engine; called the "2011" engine (com.snc.sla.engine.version). Second I will talk about how to approach troubleshooting an SLA issue.</p><br /><h4>How it works</h4><br /><p>From an event driven perspective, it all starts with a task (the table that is). Somebody or something submits an Incident, updates a Problem or requests a Service Catalog item. When this happens a business rule called "Run SLAs" kicks off. This Business Rule doesn't do too much except call a Script Include, "TaskSLAController". But that is actually saying quite a lot because the TaskSLAController is the gateway to the SLA Engine.</p><br /><br /><br /><br /><h5>Transitions</h5><br /><p>As of the June 2011 re-write of the SLA engine most all of the real work for SLAs are handled by Script Includes. The code is written in a re-usable and nicely encapsulated way that allows extension and customization. It also makes for much more easily understood code and a grouping of tasks into logical parts. Probably the most creative and helpful example of this encapsulation is the code that handles the transitions between stages. The key component of this is a base class Script Include (SLAConditionBase) with methods that can easily be overwritten should you desire custom functionality. (see the Wiki article, <a title="ki.service-now.com/index.php?title=Modifying_SLA_Condition_Rules" href="http://wiki.service-now.com/index.php?title=Modifying_SLA_Condition_Rules">Modifying SLA Condition Rules</a> for a great description.) If you notice that your stages are mysteriously going to "Complete" when you expect them to be "Achieved" it might be part of this mechanism that is mis-configured. If you notice systemic issues with calculations or SLA operation then perhaps one of the core Script Includes has been customized and did not update during your last upgrade.</p><br /><h5>Workflow</h5><br /><p>Since the 2010 engine (introduced in one of the later Spring 2010 patches), SLA Workflows have been used only for Notification purposes. Before that time they were used to update fields and manage escalations. If you are not getting the Notifications you expect or are not getting them at the right/expected times, Workflow is the place to look for issues.</p><br /><h5>Breach timers</h5><br /><p>Breach timers are sys_trigger records (System Scheduler &gt; Scheduled Jobs module). This is a very central table that handles all things scheduled in the system. Every time that an SLA goes into "In Progress" a Breach Timer is generated that will expire at the time indicated in the Planned End Time field. When the breach timers expire they call TaskSLA.breachTimerExpired(). I have not seen many issue with Breach Timers. If you did have an issue then it might look like incidents that breach later than they should. Sys_trigger records do not get destroyed during a restart and there isn't any normal reason for them to stop running unless something extreme like an out-of-memory error occurs. If your sys_trigger queue gets backed up then all the jobs in the queue will stop running. You'll notice that not only do SLA's stop breaching, but Workflow Notification will stop going out too because Workflow Timers run on sys_trigger records too. Remember, everything that can be scheduled is scheduled in the sys_trigger table.</p><br /><h5>Calculate on Display</h5><br /><p>Ever wonder what updates SLAs? If you were to set up reporting on your SLAs and run the same report twice you would notice that the elapsed percentage fields on your In Progress SLAs don't change. Seems odd doesn't it? In some cases customers will call in wondering why they can open an Incident, then twenty seconds later look at the Elapsed Percentage field and it is still at zero. The problem is that the Calculated fields on SLAs aren't magically getting upgraded in real time. Unless you turn on the glide.sla.calculate_on_display property, the calculations won't even get upgraded when you look at the Incident. The reason is that SLA calculations only get updated when some event occurs. By default this is when either the Conditions are met for the task_sla to go through a Transition, a Breach Timer expires or a Calculation Job runs (explanation coming up next). Even if you turn on the glide.sla.calculate_on_display System Property (sys_property table) you won't get the results you expect when looking at the task_sla table directly or through the reporting engine. This is because the Calculate on Display business rule only runs when a user looks at a task record not a task_sla record! Definitely something to consider when planning how you will design your <a title="ki.servicenow.com/index.php?title=Reporting_on_SLAs" href="http://wiki.servicenow.com/index.php?title=Reporting_on_SLAs">SLA reporting</a>.</p><br /><h5>Calculation Jobs</h5><br /><p>These are Scheduled Jobs (sys_trigger table) that run at different intervals and update the calculated values of SLAs that will breach soon or have already breached. These Calculation Jobs help keep more reliable calculated values for SLAs that are near breach. For example, if you search in the Scheduled Jobs table for jobs that start with "SLA Update" you'll find a number of jobs; one of which runs every minute and updates all SLAs that will breach within 10 minutes.</p><br /><h4>Troubleshooting</h4><br /><p>You can do this the hard way or the real hard way. All kidding aside, most SLA issues take time and effort to solve. Sometimes the effort is in understanding how the SLA engine should be expected to operate (so kudos to you for reading this article). It is worth the effort and time though because for most companies (maybe yours!) SLAs are the primary performance metric for their operation.</p><br /><p>The best way to start out is to determine exactly what the expected behavior is. Consider the different areas mentioned above. What mechanism controls the behavior that you believe is acting unexpectedly? What <a title="ki.service-now.com/index.php?title=Getting_Started_with_SLAs" href="http://wiki.service-now.com/index.php?title=Getting_Started_with_SLAs">version of the SLA engine</a> are you running and are there any customizations*?</p><br /><h5>Desk check</h5><br /><p>Here is my baby. I've been troubleshooting SLAs since Spring 2010 and I finally got tired of piecing together the who/what/whens of SLA mysteries so I wrote a background script that would grab almost all of the pertinent details and output them for me in a timeline. This script is pretty barebones on the display side, but it outputs all the configuration information for the Schedule, Workflow, SLA Definition and then outputs a timeline of all the related activity including the Activities of the Active Workflow Context, Changes to Task fields that affect the Task SLA Transitions, and the current values of the SLA calculations themselves. Note that the script does not force an update to the Task SLA Calculations so it is only as accurate as the last Calculation time. However, that would be a nice feature.</p><br /><p style="font-family:courier; margin-left:20px;"><br />/*<br /> * @Usage - Currently the following two examples are the way I<br /> * imagine this object being used. The first example will return a<br /> * report of a specified number of task_sla's. The second example<br /> * takes a sys_id of a task_sla record and returns a report about<br /> * that task_sla.<br /> */<br />var dCheck = newDCheck();<br />var filters = [<br />{"field":"end_time","operator":"!=","value":""},<br />{"field":"sys_created_on","operator":"&gt;","value":"2012-04-13 21:00:00"},<br />{"field":"sys_created_on","operator":"&lt;","value":"2012-04-13 23:00:00"}<br />];<br />gs.print(dCheck.getLatestByDefinition('name','ADSK - Incident- P3 Resolution(5 Days) ',3,filters));<br />gs.print(dCheck.getSlaTimeline('5161366d0a0a0b3000d59bf577381424'));<br /></p><br /><p style="font-family:courier; margin-left:20px;"><br />/*<br /> * @Description - This script speeds up the information gathering process<br /> * about an existing task_sla. It outputs information about the<br /> * contract_sla (SLA Definition), task (Incident, Problem, etc.), task_sla<br /> * (running SLA), wf_context (Running Workflow) and wf_history (History<br /> * of the running Workflow). First it outputs information about the<br /> * definitions of the above items and then it compiles the history of<br /> * changes to each item and orders them by timestamp so that you can piece<br /> * together expected vs. actual behavior. See bottom of script for usage<br /> * information.<br /> */<br />function newDCheck() {<br />return {<br />//Specify sys_id of the SLA definition<br />//@param fld {string} field of SLA Definition to query<br />//@param value {string} value to match agains fld<br />//@param filters {array} array of objects in format [{field:"",op:"",value:""},...]<br />getLatestByDefinition : function(fld, value, test, filters) {<br />if (typeof tests == "undefined")<br />tests = 3;//number of sla's to test<br />var out = ["NOTE: All times in GMT\n"];<br /><br /><br />var sld = new GlideRecord("contract_sla");<br />sld.addQuery(fld, value);<br />sld.query();<br />while (sld.next()) {<br />//Print conditions from SLA definition<br />out.push(this.printSlaDefinition(sld));<br /><br /><br />//Pull out the field names<br />var flds = this.getSlaConditions(sld);<br />out.push("fields from conditions: " + flds.join());<br /><br /><br />//Print information about the SLA schedule SKIPPED<br /><br /><br />//Get group of task_sla records<br />var slt = new GlideRecord("task_sla");<br />slt.addQuery("sla",sld.sys_id+"");<br />slt.addQuery("sys_created_on","&lt;",gs.daysAgoStart(1));<br />if (filters)<br />for (var iz = 0; iz &lt; filters.length; iz++)<br />slt.addQuery(filters[iz].field, filters[iz].operator, filters[iz].value);<br />slt.orderByDesc("sys_created_on");<br />slt.setLimit(tests);<br />slt.query();<br />//For each task_sla<br />id = 0;<br />while(slt.next()) {<br />out.push("\n*******" + ++id + "*******");<br />out.push(this.getSlaTimeline(slt, flds));<br />}<br />}<br />return out.join("\n");<br />},<br /></p><br /><p style="font-family:courier; margin-left:20px;"><br />printSlaDefinition : function(contract) {<br />var out = [];<br />var sldFlds = ['name', 'workflow', 'collection', 'duration', 'duration_type', 'retroactive', 'set_start_to', 'schedule', 'timezone', 'type', 'start_condition', 'stop_condition', 'pause_condition', 'reset_condition'];<br />for (var ia = 0; ia &lt; sldFlds.length; ia++)<br />out.push("contract_sla." + sldFlds[ia] + ": " + contract[sldFlds[ia]]);<br /><br /><br />return out.join("\n");<br />},<br /></p><br /><p style="font-family:courier; margin-left:20px;"><br />getSlaConditions : function(contract) {<br />var conds = ['start_condition', 'stop_condition', 'pause_condition', 'reset_condition'];<br />var flds = [];<br />for (var ib = 0; ib &lt; conds.length; ib++) {<br />var cond = contract[conds[ib]].split("^");<br />for (var ic = 0; ic &lt; cond.length; ic++) {<br />var fld = cond[ic].split(/[^a-z_]/)[0];<br />if (fld) flds.push(fld);<br />}<br />}<br />return flds;<br />},<br /><br /><br />timeline : {<br />_timeline : [],<br /><br /><br />sort : function() {<br />return this._timeline.sort();<br />},<br /><br /><br />push : function(value) {<br />var i = this._timeline.length;<br />while(i--) if (this._timeline <i>=== value) return;<br />this._timeline.push(value);<br />},<br /><br /><br />join : function(delim) {<br />return this._timeline.join(delim);<br />},<br /><br /><br />reset : function() {<br />this._timeline = new Array();<br />}<br />},<br /><br /><br />getSlaTimeline : function(sla, condFlds) {<br />//var timeline = [];<br />var fields = [];<br /><br /><br />if (typeof sla == "string") {<br />var sltask = new GlideRecord("task_sla");<br />sltask.get(sla);<br />sla = sltask;<br />fields.push(this.printSlaDefinition(sla.sla));<br />} else if (!sla) return;<br />if (!condFlds) condFlds = this.getSlaConditions(sla.sla);<br /><br /><br />//Print task information (retroactive value, any field in conditions...)<br />if (sla.task) {<br />var taskRec = new GlideRecord("task");<br />taskRec.addQuery("sys_id",sla.task+"");<br />taskRec.query();<br />if (taskRec.next()) {<br />var tFlds = ['sys_id','number',sla.sla.set_start_to];<br />for (var ih = 0; ih &lt; tFlds.length; ih++)<br />fields.push("task." + tFlds[ih] + ": " + sla.task[tFlds[ih]]);<br />//Add task information to timeline (sys_created_on, sys_updated_on...)<br /><br /><br />for (var ii = 0; ii &lt; condFlds.length; ii++) {<br />//Query audit tables for all field names from the conditions list ordered by Created On<br />var aud = new GlideRecord("sys_audit");<br />aud.addQuery("documentkey",sla.task.sys_id+"");<br />aud.addQuery("fieldname",condFlds[ii]);<br />aud.orderBy("sys_created_on");<br />aud.query();<br />if (aud.getRowCount() == 0) this.timeline.push(sla.task.sys_created_on + " Orig " + condFlds[ii] + ": " + sla.task[condFlds[ii]]);<br />while(aud.next()) {<br />this.timeline.push(aud.sys_created_on + " Task " + aud.fieldname + " old:" + aud.oldvalue + " new:" + aud.newvalue);<br />}<br />//Add audit information to timeline<br />}<br />} else {//bad reference<br />fields.push("ERROR: task is a bad reference");<br />}<br />}<br /><br /><br />//Print task_sla information<br />var sFlds = ['sys_id','task','start_time', 'end_time', 'planned_end_time', 'duration', 'percentage', 'pause_time', 'pause_duration', 'stage', 'has_breached', 'sys_created_on', 'sys_updated_on'];<br />for (var ie = 0; ie &lt; sFlds.length; ie++)<br />fields.push("task_sla."+sFlds[ie] + ": " + sla[sFlds[ie]]);<br /><br /><br />//Add task_sla information to timeline (start_time, end_time, planned_end)<br />var tlFlds = ['start_time', 'end_time', 'pause_time', 'planned_end_time', 'sys_created_on', 'sys_updated_on'];<br />for (var ig = 0; ig &lt; tlFlds.length; ig++)<br />this.timeline.push(sla[tlFlds[ig]] + " SLA " + tlFlds[ig]);<br /><br /><br />//Query wf_context for this task_sla<br />var wf = new GlideRecord("wf_context");<br />//Print wf_context info<br />wf.addQuery("id",sla.sys_id+"");<br />wf.query();<br />//Query all Activities in the wf_context<br />while(wf.next()) {<br />fields.push("wf_context.name: " + wf.name);<br />fields.push("wf_context.started: " + wf.started);<br />fields.push("wf_context.ended: " + wf.ended);<br />//Add Activity start/end to timeline<br />var wfe = new GlideRecord("wf_history");<br />wfe.addQuery("context",wf.sys_id+"");<br />wfe.query();<br />while(wfe.next()) {<br />this.timeline.push(wfe.started + " WF " + wfe.activity.name + " (activity) began");<br />this.timeline.push(wfe.ended + " WF " + wfe.activity.name + " (activity) ended");<br />}<br />}<br /><br /><br />var slaTimeline = fields.join("\n") + "\n**Timeline (GMT)**\n" + this.timeline.sort().join("\n");<br />this.timeline.reset();<br />return slaTimeline;<br />}<br />}<br />}<br /></i></p><i><br /></i><p><i>NOTE: I've also attached this as a file to this blog post for download</i></p><i><br /></i><h4><i>Gotcha's</i></h4><i><br /></i><p><i>Here's a collection of some of the most common mistakes I see.</i></p><i><br /></i><h5><i>Duplicate Workflows</i></h5><i><br /></i><p><i>SLA Workflows get kicked off when Conditions from the SLA Definition (contract_sla table) match. This means you don't need to have the workflow set up to Run If... If you do set up the Workflow to Run If then you'll get duplicate Active Workflow Contexts.</i></p><i><br /></i><h5><i>Retroactive Start Time set to Weird Values</i></h5><i><br /></i><p><i>Setting a Retroactive Start time means that at the <em>time of Task SLA (task_sla) creation</em> the Start Time field will be set to some field from the Task record. Task SLAs get started when a Task gets Updated. So if you set the Retroactive Start time to Updated On then you might as well not set it to anything! Also, retroactive start time has some caveats. Check out the Wiki's explanation of <a title="ki.service-now.com/index.php?title=Service_Level_Agreements#Aspen_Release" href="http://wiki.service-now.com/index.php?title=Service_Level_Agreements#Aspen_Release">prior pause time</a>. In June there were also issues discovered with workflow timers not working correctly with retroactive SLAs and Schedules.</i></p><br /><h5>Relative Duration</h5><br /><p>The biggest thing here is to understand that Relative Duration does not work with Pause Time. To avoid confusion we now hide the Pause Condition field on Relative Duration SLA Definitions. The next biggest thing to understand is the the "current" object is not supported in the scripted section of a Relative Duration. If you use it you will get results, but they will not be consistent. This means that you can not use Relative Duration SLAs to design an SLA that will have a different duration depending on some value on the Task record.</p><br /><h5>Calculate on Display</h5><br /><p>I already mentioned this earlier, but it's worth repeating. Setting the Calculate on Display Property means that every time a user views a <em>Task</em> record the calculations of the SLAs in the Related List will be updated. It does NOT mean that every time a <em>Task SLA</em> record is viewed it's calculations will be updated.</p><br /><br /><br /><p>Regards, Matthew Watkins</p><br /><br /><br /><p>* ServiceNow tracks most customizations to configuration records in your system. During the next upgrade, any changes that would otherwise be applied to configuration records that have been altered will be SKIPPED. You should make sure to check the Upgrade History module to see if any updates have been skipped and merge or overwrite the custom code with the new ServiceNow changes. If you want to know more about this, check the following WIKI articles:<br /><br /><a title="ki.service-now.com/index.php?title=Tracked_Customizations_in_Update_Sets" href="http://wiki.service-now.com/index.php?title=Tracked_Customizations_in_Update_Sets">Tracked Customizations in Update Sets</a><br /><br /><a title="ki.service-now.com/index.php?title=Upgrade_History" href="http://wiki.service-now.com/index.php?title=Upgrade_History">Upgrade History</a><br /></p><br /><br /><br /><p><br />What about you? What are some techniques you use to troubleshoot SLAs? What are some gotchas you've discovered?<br /></p></p>