---
title: "Conditional Filters"
date: 2011-11-25T00:03:08.000Z
authors: ["Chuck Tomasi"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=730e6e2ddbd0dbc01dcaf3231f961929"
---
<p><img  alt="" class="jive-image" src="43ab63fddb5893049c9ffb651f961998.iix" align="right" />One of the first things that blew me away about ServiceNow was the iTunes like way to make filters on lists, or conditions on things like UI policies. Recently, I had a need to build my own records with such filters. It turned out to be very easy and very powerful. Let me show you how you can add such flexibility to your data without adding complexity to your scripting.<br /><!--break--><br />Here's the story… the customer's change process required "templates" for their change tasks. They wanted to construct a library of tasks they could apply to the change request when a UI Action copied them over. At first this sounded like a quick easy reference field (change_request.u_change_model) that pointed to a Change Model Table (u_change_model). A second table "Change Model Tasks" (u_change_model_tasks) would contain the set of tasks for each model by using a Parent field to create a related list on u_change_model. Pretty straight forward. Then things got interesting.<br /><br />They also wanted a series of "administrative" task models that got applied for things like pre-implementation test, pre-implementation verification, post implementation verification etc. Oh, and if there was no change model specified, use a generic model. <i>(So much for the simple reference field.)</i><br /><br />My solution? Use the same Change Model table and add a few additional fields. First, a true/false checkbox to determine if this was an administrative model (so I could add a <a title="ki.service-now.com/index.php?title=Reference_Qualifiers" href="http://wiki.service-now.com/index.php?title=Reference_Qualifiers" target="_blank">reference qualifier</a> to change_request.u_change_model to keep the Admin task models out of the list of choices. The second and third fields are the key to this whole plan. They are two fields "Table" (u_change_model.u_table) and "Conditions" (u_conditions). They are defined in the dictionary like this:<br /><center><br /><img  alt="" class="jive-image" src="e1ce6d02db50530468c1fb651f961965.iix" /><br /></center><br />Since these types don't show up when you add new fields through (right click) Personalize&gt; Form Layout, you'll need to add them directly from the dictionary, then place them on the form separately. Don't forget to make u_conditions dependent on u_table. It's required so the fields in the condition filter get pulled from the proper source. For my example, I forced the value of u_table to change_request (since that's the only table I'll need) and made it read-only. Be sure to place the Table field on the form or Conditions complains that it doesn't know what to do. I also chose to hide it on the form with a simple UI Policy to avoid confusion with users entering data. A second UI policy hides the conditions when Administrative is false since standard change models do not have conditions, they're selected with the reference field.<br /><br />The final form looks like this:<br /><center><br /><img  alt="" class="jive-image" src="921e65c6dbd01744e9737a9e0f961932.iix" /><br /></center><br />This allows the customer to define as many standard models for implementation tasks and point to them with the Change Model field on the change form, and also include administrative tasks based on which ones match the conditions. If they want certain tasks to appear in the change tasks list based on the CI, the owner, the risk, or change type, it's all available, and more than one record can match. No need to replicate a bunch of change fields to the change_model table and write complex GlideRecord queries.<br /><br />So now that we've defined the data side of things, let's look at the piece that gets the appropriate records that match the conditions…<br /><br />The key is the Packages.com.glide.script.Filter and the checkRecord() method. Here's a quick little script to grab one change record and see which change model records meet the conditions of the change record data.<br /><br /><pre __default_attr="plain" __jive_macro_name="code" class="jive_text_macro jive_macro_code"><br /><br />var cr = new GlideRecord('change_request');<br />cr.get('46e9b4afa9fe198101026e122b85f442'); // Specific change for this test<br /><br />var mc = new GlideRecord('u_change_model');<br />var filter = Packages.com.glide.script.Filter;<br /><br />mc.addQuery('u_active', true);<br />mc.addNotNullQuery('u_conditions');<br />mc.query();<br /><br />while (mc.next()) {<br />   var match = filter.checkRecord(cr, mc.u_conditions);<br />   gs.print(mc.u_name + ' condition=' + mc.u_conditions + ' match=' + match);<br />}<br /></pre><br /><br />That's it. My UI action "Generate Tasks" basically does this. All I changed was a few functions in the script include to copy tasks from the change_request.u_change_model field (if not empty), and trade the gs.print() for a function that copies the tasks in u_change_model_tasks (with a parent of mc.sys_id) to change_tasks. <br /><br />Now you known how to use use the dictionary types "conditions" and "table_name" to create very powerful lists of records and check with ones match the given criteria without replicating lots of fields from lots of tables for specialized GlideRecord queries.<br /><br />Editors note: Apologies for the long time between posts. The last couple months have been dedicated to a very aggressive timeline for a very large customer. It's been a great implementation and I look forward to sharing more cool stuff from this project in upcoming articles.</p>