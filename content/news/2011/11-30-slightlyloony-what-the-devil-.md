---
title: "What the Devil"
date: 2011-11-29T21:08:35.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=8b9dae69dbd0dbc01dcaf3231f96192b"
---
<p><span class="asset-asset_lightbox-Small asset-align-right"><a href="/files/SlightlyLoony/devil%20child%20pen%20face_0.jpg" rel="lightbox"><img rel="lightbox" src="http://community.service-now.com/files/imagecache/Small/SlightlyLoony/devil%20child%20pen%20face_0.jpg" alt="" title="" class="imagecache imagecache-Small" /></a></span>Several times in various posts on this blog, I've mentioned some differences between JavaScript <i>primitive values</i> and their corresponding <i>objects</i>. The other day one of my readers asked me to elaborate a bit on this topic, as he found the whole thing very confusing. "Why are there two ways to represent a string or a number?" he asked, a bit plaintively. "How am I supposed to know which one is actually being used in any given situation, and why does it even matter?"<br /><br />Well, it's like this...<br /><!--break--><br />The first thing to understand is that when JavaScript evaluates an expression, that evaluation <i>always</i> uses primitive values. So, for instance, if I were to run this code:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var x = new Number(54);<br />var y = new Number(45);<br />var z = x + y;<br /></pre><br />When JavaScript evaluates the expression <span style="font-family=Courier;color:FireBrick;">x + y</span>, it first converts the <span style="font-family=Courier;color:FireBrick;">Number</span> instances to primitive number values, by calling the <span style="font-family=Courier;color:FireBrick;">valueOf()</span> method on each of them. The same thing is true for expressions whose operands include instances of <span style="font-family=Courier;color:FireBrick;">String</span>) or <span style="font-family=Courier;color:FireBrick;">Boolean</span>) as well. Any type coersion needed is done after the operands have been converted to primitive values. So you needn't worry about whether your expressions include primitive values or objects; they all end up as primitive values when they are evaluated.<br /><br />Their are certain situations in which JavaScript will automatically convert a primitive value to a corresponding object. Consider this code (which works just fine):<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var x = 532;<br />gs.log(x.toFixed(3));<br /></pre><br />After the first line is executed, the variable <span style="font-family=Courier;color:FireBrick;">x</span> contains a primitive number value. In the second line, that value is converted to a <span style="font-family=Courier;color:FireBrick;">Number</span> instance, and then the <span style="font-family=Courier;color:FireBrick;">toFixed()</span> method on that instance is called. The instance is then discarded, and the variable <span style="font-family=Courier;color:FireBrick;">x</span> remains a primitive number value.<br /><br />Because these conversions happen automatically and (for the most part) seamlessly, it's not very often that you really need to explicitly use one of the three value object types (<span style="font-family=Courier;color:FireBrick;">Number</span>, <span style="font-family=Courier;color:FireBrick;">Boolean</span>, or <span style="font-family=Courier;color:FireBrick;">String</span>). I can only think of two occasions when I've felt the need to use these value object types explicitly.<br /><br />First (and by far the more common need) is when I really needed to force JavaScript to coerce a value to a particular type. For example, consider this code:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var x = '1234';<br />var y = new Number(x).valueOf();<br />gs.log('x: ' + typeof x);<br />gs.log('y: ' + typeof y);<br /></pre><br />If you run this code, you'll see that <span style="font-family=Courier;color:FireBrick;">x</span> is a primitive string and <span style="font-family=Courier;color:FireBrick;">y</span> is a primitive number, just what I wanted. But this code does the same thing, more concisely:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var x = '1234';<br />var y = x - 0;<br />gs.log('x: ' + typeof x);<br />gs.log('y: ' + typeof y);<br /></pre><br />This is a good demonstration of how JavaScript evaluates expressions. It sees the minus sign and figures out that this must be a numeric expression (since minus signs can't appear in string or boolean expressions). So it coerces <span style="font-family=Courier;color:FireBrick;">x</span> to a primitive number value and subtracts zero from it (which doesn't change the value, of course), and then assigns the primitive number result to <span style="font-family=Courier;color:FireBrick;">y</span>. Yes, it's a bit of a trick — but it sure is much less of a mouthful than the previous method.<br /><br />The second reason I've explicitly used the object types is when I wanted (for whatever reason) to add properties to the value. If you're more used to other programming languages than you are to JavaScript, you may find this a bit of a mind-bender. But...in JavaScript, all the object types are child classes of the base class Object — and the Object class (and therefore, <i>all</i> JavaScript classes) allows you to add new properties anytime you'd like to. Check out this code:<br /> <pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var x = 12;<br />gs.log(typeof x);<br />x.a = 'OMG';<br />gs.log(x.a);<br /><br />x = new Number(12);<br />gs.log(typeof x);<br />x.a = 'OMG';<br />gs.log(x.a);<br /></pre><br />The first four lines fail dismally, because you can't add properties to a primitive value. But the second four lines work great, because I've explicitly created my numeric value as an instance of <span style="font-family=Courier;color:FireBrick;">Number</span>.<br /><br />Any other questions about primitive values versus the corresponding object types?</p>