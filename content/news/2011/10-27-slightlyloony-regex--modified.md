---
title: "Regex Modified Madness"
date: 2011-10-26T18:07:16.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=0eac2625dbd0dbc01dcaf3231f9619a6"
---
<p><span class="asset-asset_lightbox-Small asset-align-right"><a href="/files/SlightlyLoony/after_regex.jpg" rel="lightbox"><img rel="lightbox" src="http://community.service-now.com/files/imagecache/Small/SlightlyLoony/after_regex.jpg" alt="" title="" class="imagecache imagecache-Small" /></a></span>Yesterday I showed you how this regular expression (regex) worked to find SSNs in text:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />/(^|[^0-9])([0-9]{3}-[0-9]{2}-[0-9]{4})($|[^0-9])/m<br /></pre><br />Hopefully you didn't suffer too much brain damage in the process. Today I'm going to focus on something a bit easier: some different ways to write this regex, and some ways to make it work better. Along the way, you'll learn a few new things about regexes...<br /><!--break--><br />Let's start with the character class <span style="font-family=Courier;color:FireBrick;">[0123456789]</span>, which means "match any of the characters (which happen to be all the digits) within the square brackets." The square brackets designate a character class, and the characters between those brackets are the members of that character class. The <i>meaning</i> of a character class is that the regex will match any of its members at that position. Yesterday I showed you a shortcut in writing a character class, when all (or some) of its members are sequential. The digits 0 through 9 are sequential, so you can write the character class that includes all of them like this: <span style="font-family=Courier;color:FireBrick;">[0-9]</span>, which you can read as "0 through 9." A moment ago I said <i>sequential</i>, and that's actually a key concept here. Sequential, to a regex, means "in Unicode 16 order." If that doesn't mean anything to you, don't worry about it — generally speaking, the only useful sequences are the digits 0-9, the lower case letters a-z, and the upper case letters A-Z. Just for completeness, let me note that character class ranges can span <i>parts</i> of a sequence with no problem: <span style="font-family=Courier;color:FireBrick;">[a-g]</span> is a perfectly legitimate way to specify the lower case characters a-g. Something that might not be so obvious is that using a range where one end is a lower case letter and the other is an upper case letter (such as <span style="font-family=Courier;color:FireBrick;">[v-D]</span>) might not do what you expect — best not to try anything like that unless you really <i>do</i> understand Unicode 16 ordering! You can also create character classes that mix up individual characters and ranges. For example, <span style="font-family=Courier;color:FireBrick;">[15$%e-hC-G]</span> is the exact same thing as <span style="font-family=Courier;color:FireBrick;">[15$%efghCDEFG]</span> — a strange set of characters to match, but by gum it would work.<br /><br />Certain character classes are used so frequently that there are special regex "shorthand" codes for them. The character class for digits is one of them: <span style="font-family=Courier;color:FireBrick;">[0123456789]</span>, <span style="font-family=Courier;color:FireBrick;">[0-9]</span>, and <span style="font-family=Courier;color:FireBrick;">\d</span> are three ways of saying the same exact thing. If you're familiar with assembly language or C, this is your old friend: a <i>macro</i>. If you're not familiar with macros, think of <span style="font-family=Courier;color:FireBrick;">\d</span> being converted to <span style="font-family=Courier;color:FireBrick;">[0123456789]</span> before the regex is actually run. In fact, that is exactly how character class shorthands work in a regex. There are several of these macros (you can read <a title="w.w3schools.com/jsref/jsref_obj_regexp.asp" href="http://www.w3schools.com/jsref/jsref_obj_regexp.asp">more about them here</a>), and they follow a pattern that's worth remembering: if you change the letter to upper case, it takes on the opposite meaning. So <span style="font-family=Courier;color:FireBrick;">\D</span> (note the upper case 'D') means "any character that's <i>not</i> a digit," which is the same as <span style="font-family=Courier;color:FireBrick;">[^0-9]</span>. Got that?<br /><br />Using the shorthand character classes, we can now write yesterday's regex like this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />/(^|\D)(\d{3}-\d{2}-\d{4})($|\D)/m<br /></pre><br />JavaScript doesn't care which way you write it, and there's no difference in performance or behavior. You should feel perfectly free to write your regexes either with or without shorthand character classes — it's really just a matter of taste or preference. Similarly, if you have a fixed interval quantifier, you can chose to write your regex with or without the quantifier. The regex above could be written like this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />/(^|\D)(\d\d\d-\d\d-\d\d\d\d)($|\D)/m<br /></pre><br />It will behave exactly the same way, no difference at all. Again, it's a matter of taste or preference. If you think one is clearer, or prettier, or smells better — then go for it!<br /><br />Now for one last little thing today. Yesterday I showed you how the <i>.exec()</i> method would return this array of results:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />0: '(123-45-6789)'  // the entire matched text<br />1: '('              // capture group 1<br />2: '123-45-6789'    // capture group 2<br />3: ')'              // capture group 3<br /></pre><br />I also mentioned that the first and third capture groups had parentheses not because we really wanted (or needed!) to capture them, but because we needed to define the limits of the <i>or</i> character's action. Well, there's a way to make the <i>or</i> character work correctly, but without actually capturing the text. It's called a <i>non-capturing group</i>. No, that's not a failed military unit. It's a group that has all the elements of groupiness <i>except</i> that it doesn't capture any text, and won't result in an array entry in the results. You can write the first one from yesterday like this: <span style="font-family=Courier;color:FireBrick;">(?:^|[^0-9])</span>. I've added a <span style="font-family=Courier;color:FireBrick;">?:</span> just after the opening parenthesis, and that tells the regex that this is a non-capturing group. It still works exactly as before, but it doesn't capture any matching text. So if we rewrote our regex from yesterday like this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />/(?:^|\D)(\d{3}-\d{2}-\d{4})(?:$|\D)/m<br /></pre><br />and then ran it, we'd get this result:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />0: '(123-45-6789)'<br />1: '123-45-6789'<br /></pre><br />We've eliminated those two unnecessary capture groups. In our example it really doesn't hurt anything to have those unnecessary capture groups — it's just not as tidy as you might like. There <i>are</i> cases, however, where you really don't want the matched text to be captured, and that little piece of regex syntax comes in mighty handy for them.<br /><br />Now look at you — you're actually <i>understanding</i> that line of unintelligible gobble-de-gook up there! Woot woot! How many people in <i>your</i> town could tell you that's a regex for finding SSNs? This is better than the cross-your-heart-and-hope-to-die double-secret handshakes you had back in elementary school. You <i>know stuff</i> now!<br /><br />I think that's just about enough for one day. Are you feeling even a <i>little</i> more competent with regexes than you did before? If so, well, then <i>enjoy</i> it … 'cause I'm gonna take care of that but good tomorrow…</p>