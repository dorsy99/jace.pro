---
title: "JavaScript Bitwise Operators    and "
date: 2011-03-29T17:15:19.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=60dd66e9dbd0dbc01dcaf3231f961945"
---
<p><img  alt="" class="jive-image" src="cb2bc54edb90d304b322f4621f961983.iix" style="width: auto; height: 190px;" />Recently I was talking with a customer I'll call Paula who needed to set one particular bit in a numeric variable, to call a Java class that used a "flags" parameter. In this particular case, she needed to set bit 3, which is the bit with a value of 2^3, or 8. The variable that held the flags might or might not have bit 3 already set. She didn't know about JavaScript's bitwise operators, which make this kind of thing very easy. Instead, she was trying to do it with operators like add ('+') and subtract ('-'), and that wasn't working out all that well.<br /><br />So how <i>could</i> she have done this, easily?<br /><!--break--><br />JavaScript's <a title=".wikipedia.org/wiki/Bitwise_operators#Bitwise_operators" href="http://en.wikipedia.org/wiki/Bitwise_operators#Bitwise_operators">bitwise operators</a> perform logical operations on the binary value of the operands, which (oddly for JavaScript) are treated as 32 bit integers (not the usual double floating-point value). Paula could have used the logical OR operator ('|') to solve her problem, as in this code:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />flags = flags | 8;<br />flags |= 8;  // exactly the same result, more concisely...</pre><br /><br />For instance, imagine that her 'flags' variable contained the value 131. Here's what that math looks like, in decimal, hex, and binary:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />                 decimal      hex                binary<br />                 =======   ======   ===================<br />flags (before):      131   0x0083   0000 0000 1000 0011<br />    bit to set:        8   0x0008   0000 0000 0000 1000<br /> flags (after):      139   0x008b   0000 0000 1000 1011<br /></pre><br /><br />Each bit position in 'flags (after)' is a '1' if <i>either</i> 'flags (before)' or 'bit to set' has a '1' in the same bit position. Note that in this case the result is the same as adding: 131 + 8 = 139. But consider this case, where the inital value in 'flags' was 271 instead of 131:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />                 decimal      hex                binary<br />                 =======   ======   ===================<br />flags (before):      271   0x010f   0000 0001 0000 1111<br />    bit to set:        8   0x0008   0000 0000 0000 1000<br /> flags (after):      271   0x010f   0000 0001 0000 1111<br /></pre><br /><br />The initial value of 271 already has bit 3 set, so doing a logical OR of bit 3 being set has no effect at all. This is why you can't simply add to set a particular bit to an arbitrary value.<br /><br />The other operators perform other logical operations in the same bitwise fashion. The logical AND operation is most often used to isolate particular bits. For instance, suppose you had an arbitrary value in a variable 'x', and you wanted to isolate just the least significant byte. A logical AND will do the trick quite nicely:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />x = x &amp; 0xff;<br />x &amp;= 0xff;  // exactly the same result, more concisely...</pre><br /><br />When a logical AND is used in this manner, it's often referred to as "masking" (and the value 0xff I used would be called the "mask". Here's what this operation looks like by the numbers, assuming an initial value of 1763 for 'x':<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />               decimal      hex                binary<br />               =======   ======   ===================<br />  x (before):     1763   0x06e3   0000 0110 1110 0011<br />bits to mask:      255   0x0008   0000 0000 1111 1111<br />   x (after):      227   0x00e3   0000 0000 1110 0011<br /></pre><br /><br />The logical AND operator sets a '1' into any particular bit position only if both operands have a '1' in that same bit position. The 255 (0xff) "masks" the least significant 8 bits, exactly as we wanted.<br /><br />The last bitwise operator I'm going to talk about today is the negation operator ('~'). This operator flips every bit in the operand. You use it like this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />x = ~0xff;</pre><br /><br />And here's what it looks like by the numbers:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />                       decimal      hex                binary<br />                       =======   ======   ===================<br />mask (before):             255   0x00ff   0000 0000 1111 1111<br /> mask (after):      4294901760   0xff00   1111 1111 0000 0000<br /></pre><br /><br />Yes, Paula is sorry she ever asked me about this.<br /><br />But she'll be even more sorry tomorrow, when I talk about shifty bits!</p>