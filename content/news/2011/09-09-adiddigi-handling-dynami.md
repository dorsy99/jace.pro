---
title: "Handling Dynamic Approvals"
date: 2011-09-08T15:46:26.000Z
authors: ["adiddigi"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=760d2ea5dbd0dbc01dcaf3231f961913"
---
<p>The credit for this post is given to Hima Chalimadugu. Thanks to her, I am just spreading the knowledge :D<br /><br />3.1Layered Approach<br /> The approach designed to handle dynamic approvals is layered into 3 concentric layers as shown in the attached diagram.<br /><br /> <br /> <br />3.1.1 Layer 1 - Template<br /> This layer acts an assistant to note down what the requirements are. It makes sure that the requirements are not vague and are specific to whatever level the workflow demands.<br />i) Components of Template Layer <br />•Table to capture requirements<br />•UI actions on this table, for a better UI <br />ii)Description<br /> An external table is required to keep capturing all requirements. Though workflow can handle it initially, an external table would be needed if these requirements keep changing. Otherwise, any requirement which comes will directly go and change the whole workflow. This in turn changes business rules or other components which take care of smooth transitions. This table has few mandatory columns to identify exact time at which an approval is to be generated. The column structure of the table is something which keeps changing for customer to customer. But anyway, keeping worst case in mind, there wouldn't be more than 20 columns to capture these requirements. A generic structure of this table has been provided in the table below.<br />Type of TaskStage of TaskType of ApprovalApproverRole of approver (w.r.t requestor)Order Escalation Needed??Dependent FieldCondition 1Condition 2Condition N<br /><br />Type of task — Requested Item, Catalog Task, Change Request….so on<br />Stage — Waiting for approval, Awaiting User Revision…..any stage of the workflow<br />Type of Approval — Auto Approve, Parallel Approval…..based on requirement. (This logic is coded in the next layer. Hence type of approval should be known before-hand. (Not dynamic) )<br />Approver — Can be a direct reference to user table<br />Role — Manager, Vice President or Group Director of the requestor<br />Order — can be any integer value which differentiates each level of approval. ( The design of this field is responsible for all iterations. Hence it is better to maintain a constant difference between consequent approvals.)<br />The other fields are all dependent on how versatile an approval generation should be.<br /><br />3.1.2Layer 2 — Approval Log<br /> There are various needs which are all satisfied by yet another table that acts like a log. Layer 2 takes inputs from layer 1 and creates log entries which are used by layer 3 at any later point. This way, all approvals which are created are kept track of and handled separately. For each task created, an entry is made in approver log and is updated whenever approvals change. <br />iii) Components of Approval Log <br />•Table to keep track of approvals created<br />iv)Description<br /> Though we have sysapproval_approver table as a related list in Task table, an increase in number of approvals would result in a huge list of approvers without any other details. Also, all information we get from an approval record is the approval comments and approver. Hence, the approach uses a middle layer to see when an approval should be created ( from template) and creates them beforehand. This way only one approval activity is used in workflow to generate any number of approvals for one stage of an item. However, all details of the approvals are captured in the log. In short, we avoid creating N number of approvals and there by running a set of business rules N times and create N log entries from only one approval which is sent to different approvers. <br />A generic structure of this table has been provided in the table below.<br />TaskApproverOrderState of ApprovalStage of TaskComments Captured from approvalDescription of Approval<br /><br />Task — Every task for which dynamic approval is created<br />Approver — Name of the user<br />Order — order of the approval<br />State of Approval — 'Not yet requested', 'Approved', 'Rejected' in sync with state of sysapproval_approver record.<br />Stage of task — the stage for which an approval is needed<br />Comments — Entries made in approval comments<br />Description — Optional…if approval needs a little more description<br />3.1.3Layer 3 — Workflow<br /> The reason for placing workflow deep inside all the layers is that workflow should be stable enough to handle all types of requirements and conditions which keep coming. If it was exposed directly to requirements, there might be not just few but many re-design and re-works happening in the workflow. Also, workflow can be used to bring in other components which cannot be coupled elsewhere. Activities in workflow take their own time to execute and there will always be a maximum count of activities, after which the workflow cancels by itself. If approval-user activity is taken, it has very limited options directly available. Hence advanced script of approval-user is used to take inputs from layer2 directly. Hence, only one approval-user activity is called every time. Our workflow uses two scratchpad variables to store minimum order and maximum order. This approval-user is called from minimum order till maximum order. That is how, need for different approvals has been eliminated. <br />v) Components of Workflow Layer <br />•Approval — User<br />•Run Scripts to glide approver log<br />•IF condition to iterate all levels<br /><br />vi)Description<br /><br />Approval — user is an activity which is usually used to create an approval for one or many approvers. We use the advanced script to push our own approvers depending on the order of the approval for a particular task. So this activity runs for all orders logged for a task. i.e if there are 3 records logged in approval log for task RITM0019024, then this approval — user runs for order 10, 20 and 30 sequentially. For order 10, it generates 1 approval record, for order 20, sends this same record to the corresponding approver and so on. After 30, final state of the approval determines the flow. <br />Scripts are anyways needed to capture order and to get the approval type and approver name.<br />IF condition is where we increment the order by a constant difference and iterator until maximum order is reached. <br />3.1.4Bridges joining layers<br />There are two bridges which join these three layers. <br />The first one between layers 1 and 2 is a business rule which captures template, makes entries in the log for all tasks created or updated. This is maximum point to which requirements can reach. Beyond this, there will not be any rework coming from requirement changes. This will pass on inputs from layer1 to layer 2<br />The second bridge is nothing but the run-script which joins workflow and approval log. This bridge is always stable and not changed. Its job is to glide approval log and iterate over approval-user. This will pass on over inputs from layer2 to layer 3 which are finally implemented.<br />Apart from these 4 or 5 components, there is one business rule which synchronizes approval log and sysapproval_approver tables. Whenever a dynamic approval record's state changes in sysapprova_approver, the log entry is updated with comments and state.<br />3.2 How generic can this approach be <br /><br />This approach is designed in such a way that a small customization in the component properties would be enough to make it work for any type of task like catalog request or change request. The layers would still remain the same, but number of run-scripts would increase or decrease depending on the table. It is the maximum for 'Requested Item' table as Service-Now had its own restrictions.<br /><br />Customizations are to be done only to table names wherever needed. However, layer 1 and layer 2 remain the same for all types of tasks. In Workflow layer, as table on which this workflow runs is different, only properties should be changed. <br />4.Implementation — Scenario 1<br />4.1Problem Statement<br /> Based on the price of the requested item, approvals should be directed to requestor's level1 manager, level2 manager, level3 manager…….level 9 manager. Out of which level3, level 5 and level7 managers' approvals need to be auto approved. A next level approval should be generated only if the present approval is approved. <br />4.2 Implementing 'dynamic approval' design for this scenario<br /> Customizations are to be made for this design to function according to requirements. But the foundation remains the same. <br />Customizations for scenario 1: <br />Layer 1: u_dynamic_approval table<br />Screenshot 1: Design of the form<br /> <br /><br />Screenshot 2: Customized the form by creating all required select boxes to capture requirements<br /> <br />Screenshot 3: Implementing up to four levels first. Out of this, Area Manager approval should be auto approved.<br /> <br /> <br />Layer 2: u_list_of_approver table<br />The table is designed to capture the task number, approver, order, stage of task which needs approval and state of approval. These are populated by a business rule biz_sc_intialApproverList, which runs before insertion of a task. No one should be able to edit this table, as the information should be constant.<br /> <br />Layer 3: Wf_specialItemApproval with a subflow Wf_ItemApproval<br /> <br />Few utilities can be customized and removed if not necessary. The activities which are vital are<br />Run Script: This script acts like a bridge between layer 2 and the inner most layer. It fetches data from u_list_of_approver and stores it in temporary scratchpad variables. The script is given below.<br />Script: <br /><pre __default_attr="plain" __jive_macro_name="code" class="jive_text_macro jive_macro_code"><br /><br />var minorder = 10;<br />var maxorder = 10;<br />var gr = new GlideRecord("u_list_of_approver");<br />gr.addQuery("u_task", current.sys_id);<br />gr.addQuery('u_stage', current.stage);<br />gr.query();<br />while (gr.next()) {<br />workflow.debug(minorder +':'+ maxorder +'in glide:' + gr.u_order);<br />if(gr.u_order &gt; maxorder ){<br />maxorder = gr.u_order;<br />workflow.debug('maxorder changed to: ' + maxorder);<br />}<br />if(gr.u_order &lt; minorder ){<br />minorder = gr.u_order;<br />workflow.debug('minorder changed to: ' + minorder);<br />}<br />}<br />workflow.scratchpad.currentorder = minorder;<br />workflow.scratchpad.actualorder = maxorder;<br /> ****************************End of run script*************************************<br /></pre><br />Subflow: Wf_ItemApproval is needed only if the approval needs to be a re-usable component for many other workflows. Or it can be replaced by an approval-user activity. This approval-user activity should have an advanced script which populates approver from the list_of_approver records.<br /> <br />At present, as the subflow is on requested item and as we do not have an effective way of passing variables from main workflow to its subflow directly, there is an additional glide in this approval-user. This additional script is not required for any table where 'Workflow Inputs' can be used. Ex: sc_request, change_request…etc. <br />Approval Script implemented for approval-user is given below. <br />********************************************************************************<br />Script: <br /><pre __default_attr="plain" __jive_macro_name="code" class="jive_text_macro jive_macro_code"><br /><br />var pastorder = 10;<br />var reqorder = 10;<br />var order = 0;<br />// Checking for approvals that have been completed<br />var gr = new GlideRecord("u_list_of_approver");<br />gr.addQuery("u_task", current.sys_id );<br />gr.addQuery("u_state", 'Approved');<br />gr.addQuery('u_stage', current.stage);<br />gr.query();<br />while (gr.next()) {<br />if(gr.u_order &gt; order){<br />pastorder = gr.u_order;<br />}<br />}<br />// Checking for the next approval in queue<br />var gr = new GlideRecord("u_list_of_approver");<br />gr.addQuery("u_task", current.sys_id );<br />gr.addQuery("u_state", 'Not Yet Requested');<br />gr.addQuery('u_stage', current.stage);<br />gr.query();<br />while (gr.next()) {<br />if(gr.u_order &lt; reqorder){<br />reqorder = gr.u_order;<br />}<br />}<br /><br />/* Validating if past order and required order are correct…Indirectly checking if u_list_of_approvers hasn't been changed */<br />if(reqorder == (pastorder + 10) || reqorder == 10 ){<br />var gr = new GlideRecord("u_list_of_approver");<br />gr.addQuery("u_task", current.sys_id );<br />gr.addQuery('u_stage', current.stage);<br />gr.addQuery("u_order", reqorder );<br />gr.query();<br />while (gr.next()){<br />// Pushing the approver dynamically<br />answer.push(gr.u_approver);<br />}<br />}<br />else {<br /><br />}<br />End of Approval Script<br /></pre><br />IF condition: checks the result of the subflow. 'Approved', 'Rejected' or 'Sent Back' ('send back' option is out-of-scope for this document.) <br />IF condition to check if approvals are needed any more: This script controls the iterations.<br />**************************************************************************<br /><pre __default_attr="plain" __jive_macro_name="code" class="jive_text_macro jive_macro_code"><br /><br />Script:<br />// This script needs to set answer to 'yes' or 'no' to indicate the state of the activity.<br />//<br />// For example,<br />//<br />workflow.scratchpad.currentorder = workflow.scratchpad.currentorder + 10 ;<br />answer = ifScript();<br />//<br />function ifScript() {<br />if ( workflow.scratchpad.currentorder &lt;= workflow.scratchpad.actualorder ) {<br />return 'yes';<br />}<br />else {<br />return 'no';<br />}<br /><br />}<br /></pre><br />**********************************************************************************<br />Business Rule: Biz_sc_initialApproverList<br />Connects: u_dynamic_approval &amp; u_list_of_approver<br />Table: Sc_req_item<br />Script: <br /><pre __default_attr="plain" __jive_macro_name="code" class="jive_text_macro jive_macro_code"><br /><br />if(current.operation() == 'insert'){<br />fnAddApprovers();<br />}<br />function fnAddApprovers(){<br />var gr = new GlideRecord("u_dynamic_approval");<br />gr.addQuery("u_catalog_item", current.cat_item);<br />gr.query();<br />while(gr.next()) {<br />// There are entries made in dynamic approval template for this catalog item.<br />// Hence add one by one to the log.<br />var gr1 = new GlideRecord("u_list_of_approver");<br />gr1.initialize();<br />gr1.u_stage = current.stage;<br />gr1.u_task = current.sys_id;<br />gr1.u_state = 'Not Yet Requested';<br />gr1.u_order = gr.u_order;<br />/************ The way an approver/ approval group is given to list of approvers is<br />************* something which needs customization********************************/<br />if(gr.u_type_of_approval == 'Role from Hierarchy'){<br />if( gr.u_hierarchical_role == 'Group Manager'){<br />gr1.u_approver = current.request.requested_for.u_team.manager;<br />}<br />else if( gr.u_hierarchical_role == 'Area Manager'){<br />gr1.u_approver = current.request.requested_for.u_team.u_area.u_manager;<br />}<br />else if( gr.u_hierarchical_role == 'Department Manager'){<br />gr1.u_approver = current.request.requested_for.u_team.u_area.u_department.u_manager;<br />}<br />else {<br />gr1.u_approver = current.request.requested_for.manager;<br />}<br />}<br />else if(gr.u_type_of_approval == 'Auto Approval'){<br />gr1.u_approver = current.request.requested_for.manager;<br />/* var approval = new GlideRecord('sysapproval_approver');<br />approval.initialize();<br />approval.sysapproval = current.sys_id;<br />approval.state = 'not_required';<br />approval.approver = current.request.requested_for.manager;<br />approval.due_date = current.due_date;<br />approval.insertWithReferences();*/<br />gr1.u_state = 'Auto Approved';<br />}<br />/* else if(gr.u_type_of_approval == 'Fetch from SRF'){<br />var value=gr.u_variable.name;<br />gs.addInfoMessage('value is '+value);<br />gs.addInfoMessage('variable '+current.variable_pool.value);<br />var objRecord = new GlideRecord('sc_item_option_mtom');<br />objRecord.addQuery('request_item.sys_id',current.sys_id);<br />objRecord.addQuery('sc_item_option.item_option_new.name','slt_cbs_shortName');<br />objRecord.query();<br />gs.addInfoMessage('row count:'+objRecord.getRowCount());<br />while(objRecord.next()){<br />gs.addInfoMessage(objRecord.sc_item_option.value);<br />}<br />}<br />*/else {<br /><br />}<br />/*Before insertion, all that has to be checked is if our item falls in the price range */<br />if(gr.u_price_required == true ){<br />if(current.price &gt;= gr.u_minimum_price){<br />gr1.insert();<br />return ;<br />}<br />}<br />else {<br />// If price_required fields is unchecked, insert the approval anyway.<br />gr1.insert ();<br />return ;<br />}<br />}<br />}<br /><br />***********************End of Biz_sc_initialApproverList********************************<br /></pre><br /><br />Business Rule: Biz_sc_updateApproverList<br />Connects: sysapproval_approver &amp; u_list_of_approver<br />Table: Sc_req_item<br />Run: Before Update<br />Script: <br /><pre __default_attr="plain" __jive_macro_name="code" class="jive_text_macro jive_macro_code"><br /><br />var gr = new GlideRecord("u_list_of_approver");<br />gr.addQuery("u_task", current.sysapproval);<br />gr.addQuery("u_approver",current.approver);<br />gr.query();<br />if (gr.next()) {<br />gr.u_state = current.state; // cascading state of approval to list_of_approver<br />gr.update();<br /><br />}<br />else {<br /><br />}<br />***********************End of Biz_sc_updateApproverList********************************<br /></pre></p>