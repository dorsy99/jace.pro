---
title: "Count and Sum and Avg and Min and Max Oh My"
date: 2011-08-15T20:01:13.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=c1fca2a5dbd0dbc01dcaf3231f961961"
---
<p><img __jive_id="5355" alt="" class="jive-image" src="ShowChoiceList.png" style="width: auto; height: 94px;" />Occasionally you may find yourself needing to write a script that needs to look at more than one row to get its answer. For instance, perhaps you need a count of all the Dell servers in a particular datacenter. Or maybe you need to know the average amount of memory installed on certain servers, or which servers have the most memory. Or maybe somebody is asking you a crazy question like "How much storage capacity do we have in the datacenter?"<br /><br />You could, of course, write a little script that does any of these things â€” but that little script will have to read each record involved in the calculation, which means that every one of those records will have to be pulled out of the database and into your ServiceNow instance. If the calculation involves thousands of records, this is rather inefficient.<br /><br />Wouldn't it be nice if the database could do this work for you? If you're familiar with SQL, you may know about the "aggregate functions" (COUNT, SUM, AVG, MIN, and MAX) that do exactly these sorts of things. They're called aggregate functions because the operate on an "aggregation" (collection) of records, not just one record. But how can you use an aggregate function from ServiceNow scripting? Why, with a <i>GlideAggregate</i>, of course!<br /><!--break--><br />Here's how you might get some statistics on memory in your Dell servers using the usual scripting techniques:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var gr = new GlideRecord('cmdb_ci_server');<br />gr.addQuery('manufacturer.name', 'Dell');<br />gr.query();<br />var count = 0;<br />var sum = 0<br />var min = 999999999;<br />var max = 0;<br />while (gr.next()) {<br />    var ram = gr.ram - 0;<br />    count++;<br />    sum += ram;<br />    if (ram &lt; min) min = ram;<br />    if (ram &gt; max) max = ram;<br />}<br />gs.log('Total: ' + sum);<br />gs.log('Num: ' + count);<br />gs.log('Average: ' + (sum/count));<br />gs.log('Min: ' + min);<br />gs.log('Max: ' + max);</pre><br />That works great, but when I run it against a CMDB with 10,000 Dell servers in it...it takes a long time. <br /><br />Here's how to do the same thing with a GlideAggregate:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var ga = new GlideAggregate('cmdb_ci_server');<br />ga.addAggregate('SUM', 'ram');<br />ga.addAggregate('COUNT', null);<br />ga.addAggregate('AVG', 'ram');<br />ga.addAggregate('MIN', 'ram');<br />ga.addAggregate('MAX', 'ram');<br />ga.addQuery('manufacturer.name', 'Dell');<br />ga.setGroup(false);<br />ga.query();<br />if (ga.next()) {<br />   gs.log('Total: ' + ga.getAggregate('SUM', 'ram'));<br />   gs.log('Num: ' + ga.getAggregate('COUNT', null));<br />   gs.log('Average: ' + ga.getAggregate('AVG', 'ram'));<br />   gs.log('Min: ' + ga.getAggregate('MIN', 'ram'));<br />   gs.log('Max: ' + ga.getAggregate('MAX', 'ram') + '\n');<br />}</pre><br />Not only is the code simpler, but it executes <i>much</i> faster, and entirely in the database. Win!<br /><br />A few notes:<br /><ul><li>The COUNT aggregate doesn't have to have a field name. If you supply a null (as I did, above) for the name, then it simply counts every record (like a COUNT(*) in SQL). If you supply a name, then it counts all the non-null occurrences of that field.</li><li>I called .setGroup(false) above to turn off grouping, which is on by default. Grouping allows you to get statistics for multiple groups of records in a single operation. See the script below for an example.</li><li>The ServiceNow wiki has <a title="ki.service-now.com/index.php?title=GlideAggregate" href="http://wiki.service-now.com/index.php?title=GlideAggregate">documentation for GlideAggregate</a></li></ul><br /><br />Here's a script that will get memory statistics for each server manufacturer:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var ga = new GlideAggregate('cmdb_ci_server');<br />ga.addAggregate('SUM', 'ram');<br />ga.addAggregate('COUNT', null);<br />ga.addAggregate('AVG', 'ram');<br />ga.addAggregate('MIN', 'ram');<br />ga.addAggregate('MAX', 'ram');<br />ga.setGroup(true);<br />ga.groupBy('manufacturer');<br />ga.query();<br />while (ga.next()) {<br />   gs.log('Total: ' + ga.getAggregate('SUM', 'ram'));<br />   gs.log('Num: ' + ga.getAggregate('COUNT', null));<br />   gs.log('Average: ' + ga.getAggregate('AVG', 'ram'));<br />   gs.log('Min: ' + ga.getAggregate('MIN', 'ram'));<br />   gs.log('Max: ' + ga.getAggregate('MAX', 'ram') + '\n');<br />}<br /></pre><br />Note that this is an almost trivial change from the GlideAggregate script above, and is far easier than trying to do the same thing with GlideRecord...</p>