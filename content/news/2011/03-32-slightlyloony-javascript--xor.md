---
title: "JavaScript XOR and More"
date: 2011-03-31T19:09:35.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=b76ceea1dbd0dbc01dcaf3231f961909"
---
<p><img  alt="" class="jive-image" src="18c6c8c2dbd8db048c8ef4621f961922.iix" style="width: auto; height: 100px;" />There's just one more bitwise JavaScript operator left for us to talk about: the exclusive-or (aka XOR) operator, which is "^". There's also one more topic related to the bitwise operators that I'll cover today: how they can work as boolean operators through the magic of <i>type coercion</i>.<br /><br />XOR and coercion — now doesn't that sound exciting? Or are you as confused as these giraffes?<br /><!--break--><br />If you run this code, 'z' will end up with 673:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var x = 593;<br />var y = 240;<br />var z = x ^ y;</pre><br /><br />Here's what it looks like in decimal, hex, and binary:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />      decimal      hex                binary<br />      =======   ======   ===================<br />  x:      593   0x0251   0000 0010 0101 0001<br />  y:      240   0x00f0   0000 0000 1111 0000<br />  z:      673   0x02a1   0000 0010 1010 0001</pre><br /><br />There is no direct arithmetic equivalent for what the XOR operator does. It's easiest to understand in binary. For each bit position in 'x' where the corresponding bit in 'y' is a different, the resulting bit in 'z' is a 1. Where the 'x' and 'y' bits are the same, the result in 'z' is a zero. Many programmers think of XOR in a way that sounds different, but is actually exactly the same thing: for each bit position in 'y' that contains a 1, the corresponding bit in 'z' will be flipped, 1s for 0s and vice versa, from the corresponding bits 'x'.<br /><br />And now for something completely different, but related...<br /><br />Some of the bitwise operators ("&amp;", "|", "^", and "~") all can be used much like a boolean operator. For instance, this code will print 'Test':<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var x = true;<br />var y = false;<br />if (x | y)<br />    gs.log('Test');</pre><br /><br />Why does this work? It's because 'x' and 'y' will both be coerced to numbers (1 and 0, respectively), the bitwise operator will produce the answer 1, and that will be coerced back to the boolean value 'true'. Trust me, it really does work like that. But why would you ever want to do such a thing? There are at least two reasons: First, you might not want short circuit evaluation. Consider this code:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />if (x() &amp; y())<br />    gs.log('Test');</pre><br /><br />In this case, no matter what value 'x()' returns, the function 'y()' will still be called. If you used the normal '&amp;&amp;' operator, if 'x()' returned false then the function 'y()' wouldn't be called. The other case where you might find this useful is if you wanted an XOR operator — the only flavor of this operator available in JavaScript is the bitwise one.</p>