---
title: "Now Hear This"
date: 2011-11-03T19:57:48.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=97ad66a9dbd0dbc01dcaf3231f961980"
---
<p>Actually, it's even better. She just discovered the joys of dynamic JavaScript object methods.</p><p></p><p>Huh?</p><p></p><p>In the most popular programming languages, the methods that a class has are defined as part of the class, and they're fixed — you can't change them while the program is running. These are <em>static</em> object methods.</p><p></p><p>Most of the time when you're using JavaScript, that's probably how you think about JavaScript as well. But JavaScript actually has <em>dynamic</em> object methods that you <em>can</em> change while the program is running. If you've never seen anything like this before, even the <em>idea</em> of dynamic methods may seem strange.</p><p></p><p>Here's a very simple example just to show you how the mechanics work. This isn't intended to be realistic or useful:</p><pre style="margin-left: 20px; line-height: 1; color: firebrick;"><br/>// define a class X - with no methods...<br/>function X(a, b) {<br/>       this.x = a;<br/>       this.y = b;<br/>}<br/><br/>// make a couple instances of class X...<br/>var one = new X(3, 4);<br/>var two = new X(5, 6);<br/><br/>// make a couple functions...<br/>var mul = function() {<br/>       return this.x * this.y;<br/>}<br/>var add = function() {<br/>       return this.x + this.y;<br/>}<br/><br/>// dynamically assign methods to our instances of class X!<br/>one.process = mul;<br/>two.process = add;<br/><br/>// now run them to show the results...<br/>gs.log(one.process());<br/>gs.log(two.process());</pre><p><br/>Let's take this from top to bottom...</p><p></p><p>First we're defining the class <span style="font-family=courier;color: FireBrick;">X</span>, which is ridiculously simple. Its constructor just stores the two parameters as instance properties, and there are no instance methods defined.</p><p></p><p>Next we create two instances of this class, in <span style="font-family=courier;color: FireBrick;">one</span> and <span style="font-family=courier;color: FireBrick;">two</span>. Nothing fancy there.</p><p></p><p>Now we make a couple of functions: <span style="font-family=courier;color: FireBrick;">mul</span> and <span style="font-family=courier;color: FireBrick;">add</span>. These look a little odd, mainly because in the body of each of these functions we're using the "this" reference — but these are just standalone functions, not part of any object, so what does the "this" reference actually mean? Actually, these <em>are</em> part of an object (the <em>global</em> object), even though we're not really thinking of them as such. But even so, the "this" reference looks odd here, because we think of it being used when we call a function as a method. If we just called one of these as a standalone function (like <span style="font-family=courier;color: FireBrick;">mul();</span>, it would return <span style="font-family=courier;color: FireBrick;">NaN</span> (not a number) because the internal uses of the "this" reference wouldn't return anything sensible. For the moment, just ignore this oddness.</p><p></p><p>Next comes the part that got Trudy all excited — and which will make sense of the preceding. On each of the instances of the class <span style="font-family=courier;color: FireBrick;">X</span> we'd previously made, we assign one of the functions we just made to the property <span style="font-family=courier;color: FireBrick;">process</span>. When a property of an object contains a function, that property becomes a method of that object. So we just manufactured a method (<span style="font-family=courier;color: FireBrick;">process</span>) on our two instances — a method that we <em>didn't</em> define as part of the class (that is, we didn't assign it to the prototype). That's a dynamic method!</p><p></p><p>Finally, we call the new <span style="font-family=courier;color: FireBrick;">process()</span> methods and observe that they actually do what we wanted them to do. Note that because we're now calling them <em>as an object method</em>, the "this" reference makes sense — and returns the values we'd expect it to.</p><p></p><p>Where is this sort of thing useful? I've used it myself most commonly in circumstances where I have objects with data in them, but I won't know until runtime what I need to do with the data. One way (most certainly not the <em>only</em> way!) to accomplish this is to build objects with that data, then use dynamic methods to actually do something with that data. This is really what the simple example above does. Another place where I've used dynamic methods is when I'm letting the user define some script to do something, and then I (carefully!) <span style="font-family=courier;color: FireBrick;">eval()</span> that script as a function body, and use the result to populate a dynamic method. I've also seen nifty examples of dynamic methods in several open source JavaScript client libraries. It's one of those generally useful tools that you might not need very often, but when you <em>do</em> need it, you're very glad to have it in your toolbox.</p><p></p><p>Trudy collects fine tools, and a new one makes her very happy...</p>