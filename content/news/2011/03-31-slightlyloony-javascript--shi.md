---
title: "JavaScript Shifty Operations"
date: 2011-03-31T01:08:57.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=5a9c6ee1dbd0dbc01dcaf3231f9619c3"
---
<p><img  alt="" class="jive-image" src="cef668c2db14dfc03eb27a9e0f961987.iix" style="width: auto; height: 119px;" />There are three bitwise JavaScript operators that I didn't talk about yesterday: "&gt;&gt;", "&gt;&gt;&gt;", and "&lt;&lt;". They are JavaScript's shift operators. No, that's not some kind of shady operator like our fellow at right. These operators do just what their name implies: they shift bits around.<br /><br />But what does that actually mean?<br /><!--break--><br />An example is probably the easiest way to explain this. Consider the code below. When it runs, 'y' ends up with a value of 3096:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var x = 387;<br />var y = x &lt;&lt; 3;</pre><br /><br />Here's what it looks like in decimal, hex, and binary:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />      decimal      hex                binary<br />      =======   ======   ===================<br />  x:      387   0x0183   0000 0001 1000 0011<br />  y:     3096   0x0c18   0000 1100 0001 1000</pre><br /><br />Note how the binary value of 'y' has exactly the same bits set to a '1' as the binary value of 'x', but the bits in 'y' are shifted left by three positions relative to the bits in 'x'. That's where these operators get their name: they shift bits in a value either to the left or to the right. <br /><br />In the case of the left shift operator shown above, zeroes are always shifted in from the right hand side. Each time you shift a value to the left by one bit position, it is arithmetically identical to multiplying it by 2. In the example above, we shifted left by 3 positions, which is the same as 2 ·2 ·2 = 8 = 2^3, and sure enough, 8 ·387 = 3096.<br /><br />For the right shift operators, there are two variants.<br /><br />The <i>arithmetic</i> right shift operator is "&gt;&gt;". It's called an arithmetic shift because it preserves the sign of the result. In the binary twos-complement representation that virtually all modern computers use, a negative number always has the upper bit set. With an arithmetic right shift, the bits shifted in from the left match the original sign bit. Consider this code:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var w = 387;<br />var x = -387;<br />var y = w &gt;&gt; 3;<br />var z = x &gt;&gt; 3;</pre><br /><br />Which results in y = -48 and z = -48:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />      decimal      hex                binary<br />      =======   ======   ===================<br />  w:      387   0x0183   0000 0001 1000 0011<br />  x:     -387   0xfe7d   1111 1110 0111 1101<br />  y:       48   0x0048   0000 0000 0011 0000<br />  z:      -48   0xffcf   1111 1111 1100 1111</pre><br /><br />Note how 'w' shifted right into 'y' results in 0 bits being shifted into the left side, as it was a positive number — and 'x' shifted right into 'z' results in 1 bits being shifted into the left side, as it was a negative number. In both cases, the sign of the result is the same as the sign of the starting value. You might think that shifting right arithmetically would be equivalent to a divide by 2, just like shifting left was equivalent to multiplying by 2. You'd almost be right — it <i>is</i> the same if you neglect the effect of bits "falling off" the right hand side, and into the proverbial bit bucket. And actually the same thing is true for a left shift: if bits fall off the left side, the result will no longer be identical to multiplying by 2.<br /><br />The logical right shift operator is "&gt;&gt;&gt;", and it works the same way except that it always shifts 0 bits into the left side. Here's what the preceding example looks like using the logical right shift operator:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var w = 387;<br />var x = -387;<br />var y = w &gt;&gt;&gt; 3;<br />var z = x &gt;&gt;&gt; 3;</pre><br /><br />Which results in y = -48 and z = -48:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />      decimal      hex                binary<br />      =======   ======   ===================<br />  w:      387   0x0183   0000 0001 1000 0011<br />  x:     -387   0xfe7d   1111 1110 0111 1101<br />  y:       48   0x0048   0000 0000 0011 0000<br />  z:  3153871   0x1fcf   0001 1111 1100 1111</pre><br /><br />Note how the sign of 'x' right shifted into 'z' changed — and how the value no longer looks anything at all like a division!<br /><br />After all these shifty shenanigans, you might well be wondering what on earth anybody would ever do with such bizzare operators. Why does the language even <i>include</i> them? Here's an example that may (or may not!) help you understand: <br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var x = 0x0c;<br />var y = 0x06;<br />var z = (x &lt;&lt; 4) | y;</pre><br /><br />Here are the results of running this code:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />      decimal      hex                binary<br />      =======   ======   ===================<br />  x:       12   0x000c   0000 0000 0000 1100<br />  y:        6   0x0006   0000 0000 0000 0110<br />  z:      198   0x00c6   0000 0000 1100 0110</pre><br /><br />In this example, 'x' and 'y' each contain a "nibble" (a 4-bit value). After running this code, 'z' contains both nibbles, one to the left of the other. It's easiest to see this in hex, because each hex digit is equal to one nibble. This is often referred to as "packing", and it's a common operation needed when you're formatting values for certain APIs or for communicating with hardware devices (the former is much more likely in JavaScript). You <i>could</i> accomplish the same thing arithmetically:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var x = 0x0c;<br />var y = 0x06;<br />var z = x * 16 + y;</pre><br /><br />But some would argue that this code isn't clear at all — it's a mysterious "magic incantation" that you'd have a hard time explaining to your mother. Come to think of it, explaining left shifts to your mom probably isn't much easier. Nonetheless, on the occasions when you need them, the shift operators can be quite handy things to have in your programming toolkit...</p>