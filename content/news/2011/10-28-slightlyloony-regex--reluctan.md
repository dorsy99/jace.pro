---
title: "Regex Reluctant Madness"
date: 2011-10-27T19:06:56.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=917dee29dbd0dbc01dcaf3231f9619aa"
---
<p><span class="asset-asset_lightbox-Small asset-align-right"><a href="/files/SlightlyLoony/crying-girl3.jpg" rel="lightbox"><img rel="lightbox" src="http://community.service-now.com/files/imagecache/Small/SlightlyLoony/crying-girl3.jpg" alt="" title="" class="imagecache imagecache-Small" /></a></span>Here's our exercise for today: write a regex and accompanying script that will allow us to extract the parenthetical text from this sample:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />Once upon a time (a long time ago), there was a purple frog living<br />in a yellow lake.  A princess came along and thought (if that's the<br />right term to apply) to herself "I think I'll kiss this purple frog!" (have<br />you ever met such a princess?).  Right away (as in immediately), the<br />frog morphed into a handsome prince, who ignored the princess<br />and started chasing the flies hovering over the lake (the end).<br /></pre><br />Note that each line of this sample text is terminated by a newline.<br /><br />How would you do this?<br /><br />Oh, dear, now look what I've done — I've made Judy cry...<br /><!--break--><br />Well, with what I've told you about so far, you might try writing a function and test code something like this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var text = 'Once upon a time (a long time ago), there was a purple frog living\n';<br />text +=     'in a yellow lake.  A princess came along and thought (if that\'s the\n';<br />text +=     'right term to apply) to herself "I think I\'ll kiss this purple frog!" (have\n';<br />text +=     'you ever met such a princess?).  Right away (as in immediately), the\n';<br />text +=     'frog morphed into a handsome prince, who ignored the princess\n';<br />text +=     'and started chasing the flies hovering over the lake (the end).\n';<br />JSUtil.logObject(getParentheticals(text));<br /><br />function getParentheticals(text) {<br />    var parser = /([a-zA-Z .,]{1,})/g;<br />    var results = [];<br />    var x;<br />    while ((x = parser.exec(text)) != null)<br />        results.push(x[1]);<br />    return results;<br />}<br /></pre><br />Actually, I snuck something new in here: the <i>g</i> flag in the regex literal — see that at the end? That flag stands for <i>global</i>, and it tells the regex that we want to find all the occurrences of a match in our text. If you leave that flag off, bad things happen: the <i>while</i> loop never terminates, because it keeps searching for (and finding!) the first occurrence of our pattern.<br /><br />Anyway, what you're thinking is that this regex will match the left parenthesis, then one or more of any those characters in the character class, then the right parenthesis. But when you run it, you don't get what you expected:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />     [0]: string = Once upon a time<br />     [1]: string = a long time ago<br />     [2]: string = , there was a purple frog living<br />     [3]: string = in a yellow lake.  A princess came along and thought<br />     [4]: string = if that<br />     [5]: string = s the<br />     [6]: string = right term to apply<br />     [7]: string =  to herself<br />     [8]: string = I think I<br />     [9]: string = ll kiss this purple frog<br />    [10]: string = <br />    [11]: string = have<br />    [12]: string = you ever met such a princess<br />    [13]: string = .  Right away<br />    [14]: string = as in immediately<br />    [15]: string = , the<br />    [16]: string = frog morphed into a handsome prince, who ignored the princess<br />    [17]: string = and started chasing the flies hovering over the lake<br />    [18]: string = the end<br />    [19]: string = .<br /></pre><br />Just look at the very first result — it matched something with no parentheses at all! What's the matter with this stupid regex!?!?!<br /><br />Well, the dumb thing is doing exactly what you told it to do. Remember that parentheses are used by regexes to define <i>capture groups</i>? That's what's happening here — it's not <i>matching</i> those parentheses, it's just defining the capture group — which, btw, you're using in that code to extract the matched text and put it in the results. So how do you tell a regex that you want to match parentheses, and not use them to define a capture group? The general rule in regexes is that if you want the regex to interpret a character as just the character, and not as a <i>metacharacter</i>, you escape it by preceding it with a backslash ("\"). So if we change our regex to this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    /\(([a-zA-Z .,]{1,})\)/g<br /></pre><br />and run it again, we get this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    [0]: string = a long time ago<br />    [1]: string = as in immediately<br />    [2]: string = the end<br /></pre><br />Now that's more like it! But still not right — our example text contains 5 parentheticals, but we only got 3 of them in the output. Can you see why? The problem is that our character class is missing several characters contained in the parentheticals that we missed: the newline, an apostrophe, and a question mark. If we add them to the character class:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    /\(([a-zA-Z .,'?\n]{1,})\)/g<br /></pre><br />and run it again, we get this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    [0]: string = a long time ago<br />    [1]: string = if that's the<br />right term to apply<br />    [2]: string = have<br />you ever met such a princess?<br />    [3]: string = as in immediately<br />    [4]: string = the end<br /></pre><br />That's what we want! Yay!<br /><br />But…we've actually written a pretty lame regex here. As soon as we have some text with some new character that we didn't anticipate in a parenthetical, this will not work correctly. What we <i>really</i> need is a way to match any character. There is a shorthand character class built into regex that matches <i>almost</i> anything: the dot (a period, or <span style="font-family=Courier;color:FireBrick;">.</span>), which is equivalent to <span style="font-family=Courier;color:FireBrick;">[^\n]</span>. This little guy will match any character <i>except</i> a newline. So if we change our regex to:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    /\((.{1,})\)/g<br /></pre><br />and run it, we get this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    [0]: string = a long time ago<br />    [1]: string = as in immediately<br />    [2]: string = the end<br /></pre><br />Note that it once again doesn't match the two parentheticals that cross a line boundary.<br /><br />That dot is a handy little shorthand class, and there are lots of good uses for it — but it doesn't solve today's problem (though it does fail with less characters than our previous fail :-)). So how can we get the regex to match <i>any</i> character? There's a cute little trick that has become the defacto standard (in JavaScript) for this problem: the trick is to build a character class using a shorthand class <i>and</i> it's opposite. For example, <span style="font-family=Courier;color:FireBrick;">[\d\D]</span> is a character class that says "match any character that is a digit or is not a digit" — which is a strange way of saying "match anything at all". A newline is not a digit, so it matches, an exclamation point is not a digit, so it matches, and so on. By convention (and for no other reason), the shorthand character class used for this purpose is for whitespace or not whitespace, like this: <span style="font-family=Courier;color:FireBrick;">[\s\S]</span> — but there's really nothing special about this particular choice. So if we rewrite the regex like this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    /\(([\s\S]{1,})\)/g<br /></pre><br />and run it, we get:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    [0]: string = a long time ago), there was a purple frog living<br />in a yellow lake.  A princess came along and thought (if that's the<br />right term to apply) to herself "I think I'll kiss this purple frog!" (have<br />you ever met such a princess?).  Right away (as in immediately), the<br />frog morphed into a handsome prince, who ignored the princess<br />and started chasing the flies hovering over the lake (the end<br /></pre><br />Whoa! What just happened?<br /><br />We are the victim of something called <i>greedy quantification</i>, which is the default behavior of a regex. What's happened here is that the regex has matched as many characters as it possibly could. When it found the first opening parenthesis, it then matched every following character up to the <i>last</i> closing parenthesis. This didn't happen before because we used a character class that didn't include parentheses — but with our "match anything" character class, we can even match them. It's called <i>greedy</i> because of this take-everything-I-possibly-can behavior, and it's a behavior that confuses many a regex writer. Understanding greediness is important.<br /><br />But right now we have a case where we really don't want greediness. What we want is <i>reluctance</i> — we want it to match the <i>fewest</i> possible characters and still match the pattern. There's an app for that! Well, not an app — a character. If I add one little old question mark in the right place:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    /\(([\s\S]{1,}?)\)/g<br /></pre><br />I'll get what I want:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    [0]: string = a long time ago<br />    [1]: string = if that's the<br />right term to apply<br />    [2]: string = have<br />you ever met such a princess?<br />    [3]: string = as in immediately<br />    [4]: string = the end<br /></pre><br />That's a perfectly good regex for matching parentheticals — but I've got one more thing to show you today. Just as there are shorthands for character classes, there are also shorthands for commonly used quantifiers — three of them:<br /><ul><li><span style="font-family=Courier;color:FireBrick;">?</span> is a shorthand for <span style="font-family=Courier;color:FireBrick;">{0,1}</span></li><li><span style="font-family=Courier;color:FireBrick;">+</span> is a shorthand for <span style="font-family=Courier;color:FireBrick;">{1,}</span></li><li><span style="font-family=Courier;color:FireBrick;">*</span> is a shorthand for <span style="font-family=Courier;color:FireBrick;">{0,}</span></li></ul><br />One of those is exactly what we're using, and if we rewrite our regex to:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    /\(([\s\S]+?)\)/g<br /></pre><br />and run it, we still get the correct results.<br /><br />There's a good example in the preceding of a <i>context-sensitive</i> metacharacter, of which there are several in regexes. In this case, the question mark — which we used earlier to indicate <i>reluctance</i> — is being used as a shorthand for a quantifier. Question marks are interpreted by regexes based on what kind of "thing" they follow (that's what's meant by context-sensitive). Earlier we used a question mark after a quantifier — in that context, the question mark indicates reluctance. On the other hand, if a question mark follows a character (or character class), then it indicates a shorthand for a quantifier. The only hard part about this, really, is learning to read the regex gobble-de-gook like the regex itself does — then it's easy!<br /><br />Did I hurt your brain today? I hope so, 'cause that was my intent!</p>