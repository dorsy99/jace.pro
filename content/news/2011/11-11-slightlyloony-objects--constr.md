---
title: "Objects Constructor Consequences"
date: 2011-11-10T21:34:39.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=374de229dbd0dbc01dcaf3231f961938"
---
<p><span class="asset-asset_lightbox-Small asset-align-right"><a href="/files/SlightlyLoony/young%20construction%20worker.jpg" rel="lightbox"><img rel="lightbox" src="http://community.service-now.com/files/imagecache/Small/SlightlyLoony/young%20construction%20worker.jpg" alt="" title="" class="imagecache imagecache-Small" /></a></span>This is the first in a short series on JavaScript classes and objects, something I get a lot of questions about. In this series I'll be exploring how the JavaScript class mechanism actually works and how the <span style="font-family=Courier;color:FireBrick;">prototype.js</span> library makes defining classes a bit easier.<br /><br />A few months ago one of my colleagues made an offhand comment that I think summarizes how a lot of developers understand JavaScript classes and objects. He said: "I understand the mechanics of defining a class, but I think of them as a magic incantation — I don't actually understand what's happening when I use them." Take a deep breath, and let's dive into it:<br /><!--break--><br />Here's a silly little sample script that I'm going to use as an example:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var MyObj = function(x, y) {<br />    this.x = x;<br />    this.y = y;<br />}<br /><br />MyObj.toString = function(){<br />    return 'MyObj';<br />}<br /><br />MyObj.prototype.x = null;<br />MyObj.prototype.y = null;<br />MyObj.prototype.average = function() {<br />    return (this.x + this.y) / 2;<br />}<br /><br />var mo = new MyObj(5, 12);<br /><br />gs.log(mo.average());<br />gs.log(MyObj.toString());<br />gs.log(mo.constructor.toString());<br /><br />JSUtil.logObject(mo, 'mo, an instance of MyObj');<br />JSUtil.logObject(mo.constructor.prototype, 'prototype of MyObj');<br /></pre><br />I'm going to dissect this, top to bottom. First bit:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var MyObj = function(x, y) {<br />    this.x = x;<br />    this.y = y;<br />}<br /></pre><br />This is defining a <i>constructor function</i> for the class named <i>MyObj</i>. There's really nothing special about a constructor function. It's just an ordinary function whose <i>purpose</i> is to initialize a new instance of a class. You'll see a little later how JavaScript knows that's what you're doing. Next bit:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />MyObj.toString = function(){<br />    return 'MyObj';<br />}<br /></pre><br />This is creating a class method on the constructor function. Take a minute to understand this, if the idea is new to you. The constructor function is a <i>function object</i> — and just like any other JavaScript object, you can define new properties for it. If the property you define happens to itself be a function (like this one), then you can call it just like any other function. When you define a function as a property on a constructor function, we call that a <i>class method</i> because you can call it without having an instance of that class. You'll see this in action a little later. Tip: defining a <span style="font-family=Courier;color:FireBrick;">toString()</span> method on constructor functions is a good general practice, because (as you'll see) it lets other code figure out what <i>kind</i> of object they've got. Next bit:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />MyObj.prototype.x = null;<br />MyObj.prototype.y = null;<br />MyObj.prototype.average = function() {<br />    return (this.x + this.y) / 2;<br />}<br /></pre><br />These three statements define the <span style="font-family=Courier;color:FireBrick;">prototype</span> for my class. Note that the prototype is just another property defined on the <i>constructor function</i>. It's called a <i>prototype</i> because it defines the model for instances of this class — the properties and methods defined in the prototype become the properties and methods that instances of this class have. It's an example of a <i>class property</i> for the same reason the <span style="font-family=Courier;color:FireBrick;">toString()</span> method we just discussed is called a <i>class method</i>. In this prototype, we're defining two <i>instance properties</i> (<span style="font-family=Courier;color:FireBrick;">x</span> and <span style="font-family=Courier;color:FireBrick;">y</span>) and an <i>instance method</i> (<span style="font-family=Courier;color:FireBrick;">average</span>). These are called <i>instance properties</i> and <i>instance methods</i> because you must have an instance of this class to use them. You'll see this in action in a moment. Next bit:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var mo = new MyObj(5, 12);<br /></pre><br />Here I'm actually creating an instance (in <span style="font-family=Courier;color:FireBrick;">mo</span>) of the class <span style="font-family=Courier;color:FireBrick;">MyObj</span>. Here's where we're telling JavaScript to do something different with the constructor function — and it's all because of the magic word <span style="font-family=Courier;color:FireBrick;">new</span>. By putting that word in there, we're telling JavaScript to do these things (in this order):<br /><ol><li>Create a new generic instance of the built-in JavaScript class <i>Object</i>.</li><li>Find the constructor function named <span style="font-family=Courier;color:FireBrick;">MyObj</span>.</li><li>Copy the properties and methods of the constructor function's prototype to the new object. For example, if the prototype has a property named 'x', then it will define a new property named 'x' on our new object, and copy the prototype's value to it.</li><li>Define a property named <span style="font-family=Courier;color:FireBrick;">constructor</span> on our new object, and initialize it with a reference to our constructor function. Many developers don't know this property exists, but it can be quite handy!</li><li>Invoke the constructor function to initialize our new object. When the constructor function is invoked, <span style="font-family=Courier;color:FireBrick;">this</span> contains a reference to our new object. The constructor function, like any other function, may have parameters. In this case we're passing a 5 and a 12 to initialize our instance of this class.</li><li>Return a reference to our shiny new, freshly initialized object (in this case, so that I can assign it to <span style="font-family=Courier;color:FireBrick;">mo</span>).</li></ol><br />Whew! That's a lot of stuff for a three-letter keyword. Seems like it ought to be multisyllabic, don't you think? Next bit:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />gs.log(mo.average());<br />gs.log(MyObj.toString());<br />gs.log(mo.constructor.toString());<br /></pre><br />Here we're exercising various methods of our class and instance. The first line calls the <i>instance method</i> <span style="font-family=Courier;color:FireBrick;">average()</span> for our instance in <span style="font-family=Courier;color:FireBrick;">mo</span>, and it returns the expected result. Note that we had to call that method by referring to our <i>instance</i>. Next we call the <i>class method</i> <span style="font-family=Courier;color:FireBrick;">toString()</span> by referring to our constructor function directly, by its name. Finally the last line here does exactly the same thing as the preceding line — except that instead of referring to our constructor function by name, we're getting the constructor function indirectly, by referencing the constructor property of our instance (<span style="font-family=Courier;color:FireBrick;">mo.constructor</span>). Consider the implications of that: that means you can write code that can figure out what kind of an object it has (perhaps obtained through a parameter) — but only if you were polite enough to define a <span style="font-family=Courier;color:FireBrick;">toString()</span> method on the constructor function. That's why I said earlier that it was a good idea to do so! Last bit:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />JSUtil.logObject(mo, 'mo, an instance of MyObj');<br />JSUtil.logObject(mo.constructor.prototype, 'prototype of MyObj');<br /></pre><br />Here I'm just logging what my instance looks like, and what my class' prototype looks like. Here's the result:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />Log Object: mo, an instance of MyObj<br />  Object<br />    x: number = 5<br />    y: number = 12<br />    average: function<br /><br />Log Object: prototype of MyObj<br />  Object<br />    y: null = null<br />    average: function<br />    x: null = null<br /></pre><br />The first output shows my instance in <span style="font-family=Courier;color:FireBrick;">mo</span>. You can see the <i>instance properties</i> with their expected values 5 and 12, and the <i>instance method</i> shows as a function. All as expected. The second output shows the contents of the <i>class prototype</i> (contained in <span style="font-family=Courier;color:FireBrick;">MyObj.prototype</span>, which is the same thing as <span style="font-family=Courier;color:FireBrick;">mo.constructor.prototype</span>). It has the same two <i>instance properties</i>, but containing no value, and it has the same <i>instance method</i>. Does it make sense that the properties you see in the first output were created by copying the properties you see in the second output? Then does it make sense that after the properties in the instance were created, they were initialized by the constructor function?<br /><br />Ok, now you're an expert on the basics of how classes and objects in JavaScript work!</p>