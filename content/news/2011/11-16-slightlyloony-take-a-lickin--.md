---
title: "Take A Lickin and Keep On Tickin"
date: 2011-11-15T21:41:23.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=4c1d6ea5dbd0dbc01dcaf3231f9619e8"
---
<p>I got a call the other day from Otzi (he and I go <a href="http://en.wikipedia.org/wiki/Otzi"><em>way</em> back</a>). He ran across a piece of code that just didn't make any sense to him:</p><pre style="margin-left: 20px; line-height: 1; color: firebrick;"><br/>var ans = undefined;<br/>try {<br/>       ans = otzi.process();<br/>}<br/>catch (err) {<br/>       gs.log(err);<br/>}<br/>finally {<br/>       if (ans === undefined)<br/>             ans = null;<br/>}</pre><p><br/>"What," he demanded, "does that gobbledegook mean?"</p><p></p><p>Well, Otzi, here's your answer...</p><p></p><p>There are three parts to this. First, there's the <span style="font-family=courier;color: FireBrick;">try { }</span> block. The curly braces enclose the statements we're <em>trying</em>:</p><pre style="margin-left: 20px; line-height: 1; color: firebrick;"><br/>try {<br/>       ans = otzi.process();<br/>}</pre><p><br/>In Otzi's example, there's only one line inside the curly braces, but there could have been any number of lines. The code inside those curly braces will execute just like it would if it <em>wasn't</em> inside the curly braces, with just one difference: if something goes horribly wrong when executing that code, the next part (below) comes into play. By "horribly wrong," I mean that some kind of error occurs. For example, suppose we tried executing the code above while the variable <span style="font-family=courier;color: FireBrick;">otzi</span> was null, or even undefined? Without the <span style="font-family=courier;color: FireBrick;">try { }</span>, you'd get an error in the log and your script would stop. With the <span style="font-family=courier;color: FireBrick;">try { }</span> block, something entirely different happens:</p><pre style="margin-left: 20px; line-height: 1; color: firebrick;"><br/>catch (err) {<br/>       gs.log(err);<br/>}</pre><p><br/>If an error occurs when the code inside the <span style="font-family=courier;color: FireBrick;">try { }</span> block executes, the code inside the <span style="font-family=courier;color: FireBrick;">catch {err}</span> block will execute. For example, if <span style="font-family=courier;color: FireBrick;">otzi</span> was null when we ran the script, JavaScript would <em>throw</em> an error when it tried to execute the <span style="font-family=courier;color: FireBrick;">.process()</span> method (it's kind of hard for null to have a <span style="font-family=courier;color: FireBrick;">.process()</span> method!). When JavaScript <em>throws</em> an error, it creates an instance of the <a title="eveloper.mozilla.org/en/JavaScript/Reference/Global_Objects/Error" href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error">Error class</a> containing a message describing the error. Then it calls the <span style="font-family=courier;color: FireBrick;">catch (err)</span> block, exactly as if <span style="font-family=courier;color: FireBrick;">catch()</span> were a function. The code inside your <span style="font-family=courier;color: FireBrick;">catch (err)</span> block can then read the message inside the <span style="font-family=courier;color: FireBrick;">Error</span> instance and do whatever it needs to do. In Otzi's example, all that the <span style="font-family=courier;color: FireBrick;">catch (err)</span> block is doing is logging the error — but it could do anything at all.</p><p></p><p>Finally, there's the <span style="font-family=courier;color: FireBrick;">finally { }</span> block:</p><pre style="margin-left: 20px; line-height: 1; color: firebrick;"><br/>finally {<br/>       if (ans === undefined)<br/>             ans = null;<br/>}</pre><p><br/>The first thing to know about the <span style="font-family=courier;color: FireBrick;">finally { }</span> block is that it's optional — <span style="font-family=courier;color: FireBrick;">try { }</span> blocks don't have to be followed by a <span style="font-family=courier;color: FireBrick;">finally { }</span> block, and most of the time they aren't. When there <em>is</em> a <span style="font-family=courier;color: FireBrick;">finally { }</span> block, the code inside of it will be executed <em>no matter what happens</em> when executing the code inside the <span style="font-family=courier;color: FireBrick;">catch { }</span> block. In Otzi's example, the <span style="font-family=courier;color: FireBrick;">finally { }</span> block is simply ensuring that the <span style="font-family=courier;color: FireBrick;">ans</span> variable ends up defined: even if an error occurs, even if an undefined value is returned.</p><p></p><p>When the <span style="font-family=courier;color: FireBrick;">finally { }</span> block finishes executing (or when the <span style="font-family=courier;color: FireBrick;">catch { }</span> block finishes, if there is no <span style="font-family=courier;color: FireBrick;">finally { }</span> block), the script keeps on executing. This is really the most important thing of all about using a <span style="font-family=courier;color: FireBrick;">try { }/catch { }</span> construct: it's a way for your code to take a lickin' and keep on tickin'. For any situation where an error <em>could</em> occur, but isn't catastrophic (and therefore doesn't warrant aborting the script's execution), the <span style="font-family=courier;color: FireBrick;">try { }/catch { }</span> construct is your friend.</p><p></p><p>A couple more details worth knowing:</p><p></p><p>If your script is calling Java code (whether through a Packages.xxx call or through a Java class exposed as a JavaScript class), and that code throws a Java exception (a mechanism within Java that's very much like the JavaScript <span style="font-family=courier;color: FireBrick;">try { }/catch { }</span> construct), then JavaScript will turn that Java exception into a JavaScript Error and throw it. Bottom line: you can <em>catch</em> one of these error just like you can catch a JavaScript Error.</p><p></p><p>JavaScript doesn't have a monopoly on the ability to throw an error — your own code can do it. Here's a trivial example:</p><pre style="margin-left: 20px; line-height: 1; color: firebrick;"><br/>var x = 0;<br/>try {<br/>       gs.log(digits(x));<br/>}<br/>catch (err) {<br/>       gs.log(err);<br/>}<br/><br/>// return the number of integer digits in a positive number...<br/>function digits(arg) {<br/>       if (arg &lt;= 0)<br/>               throw new Error('Argument must be positive!');<br/>       return 1 + Math.floor(Math.LOG10E * Math.log(arg));<br/>}</pre><p><br/>If <span style="font-family=courier;color: FireBrick;">x</span> has a number greater than zero, we'll log the number of integer digits in that number. Otherwise our function will throw an error, we <em>won't</em> log the number of digits (which we couldn't compute), and we'll log an error instead.</p><p></p><p>Are you feeling a little more enlightened now, oh ancient Otzi?</p>