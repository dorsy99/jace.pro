---
title: "Regex Stop the Madness"
date: 2011-10-25T18:01:47.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=3a3deae5dbd0dbc01dcaf3231f9619e3"
---
<p><span class="asset-asset_lightbox-Small asset-align-right"><a href="/files/SlightlyLoony/after_regex2.jpg" rel="lightbox"><img rel="lightbox" src="http://community.service-now.com/files/imagecache/Small/SlightlyLoony/after_regex2.jpg" alt="" title="" class="imagecache imagecache-Small" /></a></span>Yesterday I showed you a regular expression (regex) that would find an SSN in text:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />/(^|[^0-9])([0-9]{3}-[0-9]{2}-[0-9]{4})($|[^0-9])/m<br /></pre><br />I didn't tell you anything at all about <i>how</i> it worked, though. Let's take it a whack at understanding it:<br /><!--break--><br />This is a JavaScript regex <i>literal</i>. Much like you can quote a string to make a string literal, you can surround a regex with slashes ("/") to make a regex literal. Unlike a string literal, though, a regex literal can be followed by so-called <i>flag</i> characters. In the case of our example, we've got an <i>m</i> — that's the <i>multiline</i> flag, which I'll explain later in this post.<br /><br />The stuff between the slashes is our actual regex. Here it is, piece by piece:<br /><ul><li><span style="font-family=Courier;color:FireBrick;">[0-9]</span> This is an example of a <i>character class</i>, which you can recognize by the enclosing square brackets. Character classes define what characters should match at a particular place. This particular character says "match any characters between 0 and 9, inclusive." In other words, it says "match any digit." The dash ("-") indicates a range. We could have specified this character class as <span style="font-family=Courier;color:FireBrick;">[0123456789]</span>, which means exactly the same thing (but is more work to write out!).</li><li><span style="font-family=Courier;color:FireBrick;">[^0-9]</span> This looks very much like the preceding example, except for that little caret character. The caret changes everything: it means "match everything <i>but</i> what follows." In this case, it means "match anything that's <i>not</i> a digit."</li><li><span style="font-family=Courier;color:FireBrick;">{3}</span> This is called a <i>quantifier</i>, specifically, an <i>interval quantifier.</i> Quantifiers define how many characters to match. An interval quantifier (recognizable by the surrounding curly braces) specifies either an exact number of characters (<i>{n}</i>) or an inclusive range of allowable number of characters (<i>{n, m}</i>). An inclusive range with the first number missing (<i>{, m}</i>) means any number from 0 to m; if the last number is missing (<i>{n, }</i>) means any number n or more. In our example's case, it means match 3 characters. The absence of any quantifier (interval or otherwise) means "match one character."</li><li><span style="font-family=Courier;color:FireBrick;">[0-9]{3}</span> This puts a couple of the preceding points together. It means "match three digits." Really! That's all it means.</li><li><span style="font-family=Courier;color:FireBrick;">([0-9]{3}-[0-9]{2}-[0-9]{4})</span> This is a big part of the entire regex, but you should be able to read it now. It means "match three digits, dash, two digits, dash, four digits." Those dashes that it's matching are outside a character class, and in that context the dash has no special meaning, and is simply directly matched. That description sounds like the entire problem, doesn't it? We've described the <i>pattern</i> of an SSN. But if you think about it, the SSN must have something other than a digit before it — otherwise we might think that a sentence containing '0123-45-6789' contained an SSN, when it doesn't. Similarly, it has to have a non-digit following it as well. There's one other thing here that I've just sort of ignored: the parentheses surrounding it. In a regex, those parentheses designate a <i>capture group</i>. That's not a military unit, but rather a directive that says "capture any text that matches between these parentheses." You can have any number of capture groups in a regex. I'll show you how you use the captured text a little later in this post. Our example has three capture groups — see 'em?</li><li><span style="font-family=Courier;color:FireBrick;">(^|[^0-9])</span> This little beauty means "match the beginning of a line <i>or</i> a non-digit (<i>one</i> non-digit, because there is no quantifier saying otherwise)." The first caret character here is outside of a character class (it's not inside square brackets), and has a different meaning in this context — it means "beginning of line". The vertical bar ("|") means match what's on the left side of it <i>or</i> what's on the right. The whole thing is in a capture group not because we actually want to capture it, but rather to define the limits of the <i>or</i>. It still will be captured, but that's only a side-effect in this case.</li><li><span style="font-family=Courier;color:FireBrick;">($|[^0-9])</span> This is much like the preceding one — the only new bit is the dollar sign ("$"), which means "match the end of line." Taken all together, this bit means "match the end of a line <i>or</i> a non-digit."</li><li><span style="font-family=Courier;color:FireBrick;">(^|[^0-9])([0-9]{3}-[0-9]{2}-[0-9]{4})($|[^0-9])</span> Now you're ready for the whole thing. This means "capture and match either the beginning of a line or a non-digit, then capture and match three digits, then a dash, then two digits, then a dash, then four digits, then finally capture and match either the end of a line or a non-digit." When you "run" your regex (see the <i>.exec()</i> method below), the text you're searching through is scanned from the first character through the last, looking for anything that matches the pattern of text that your regex has specified. Piece of cake!</li></ul><br />The capture groups become useful when we start trying to use the text we've matched. This little snippet of code from yesterday's example makes use of them:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var parser = /(^|[^0-9])([0-9]{3}-[0-9]{2}-[0-9]{4})($|[^0-9])/m;<br />var ans = parser.exec(text);<br />return (ans == null) ? null : ans[2];<br /></pre><br />The first line just creates a regex object (contained in <i>parser</i>) from the regex literal, making it ready for use. The second line uses it (via the <i>.exec()</i> method) to search the contents of the variable <i>text</i>. The <i>.exec()</i> method returns a <i>null</i> if it didn't match anything, but if it <i>did</i> match, then it returns an array of useful information. The first ([0]) entry of the array contains the entire matched text. In yesterday's example, the text we were searching was:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />'I have written my social security number (123-45-6789) in here, like this.'<br /></pre><br />So the first entry of the array would contain:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />0: '(123-45-6789)'<br /></pre><br />That's our SSN, plus the preceding and succeeding non-digits.<br /><br />The other entries in the array are for each capture group. You figure the capture group number by counting the left parentheses from left to right (this distinction matters because it is possible to have nested capture groups). Our example has three capture groups, and their results will show up in entries 1, 2, and 3 as follows;<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />0: '(123-45-6789)'<br />1: '('<br />2: '123-45-6789'<br />3: ')'<br /></pre><br />The [2] entry has our SSN, and that code above uses <i>ans[2]</i> to get it. <br /><br />Now that wasn't so hard, was it?<br /><br />Way back in the beginning of this post, I promised I'd explain the <i>multiline</i> flag. It controls the way the beginning of line ("^") and end of line ("$") metacharacters work. Without the multiline flag, they match the beginning and end of the entire string. With the multiline flag, they will also match the beginning or end of a <i>line</i> within the text. Our example would actually work just fine either way, but I included it to introduce you to the notion of a flag character. We'll run into some more of these fine beasties in later posts.<br /><br />Ok, now go wrap your head in cold, wet towels. This will help with the brain overheating...</p>