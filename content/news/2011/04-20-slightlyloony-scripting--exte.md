---
title: "Scripting Extending a Class Part IV"
date: 2011-04-19T18:26:42.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=140de6a5dbd0dbc01dcaf3231f9619db"
---
<p><img  alt="" class="jive-image" src="f082ec02db9c5304b322f4621f9619f7.iix" style="width: auto; height: 113px;" />You may never need to temporarily extend a JavaScript class, but today I'm going to show you how to do it anyway. Why? Mainly because it's a useful introduction into two important concepts: JavaScript <i>contexts</i>, and the actual mechanics of JavaScript class extension.<br /><br />The brown-eyed lass at right doesn't seem to be convinced any of this is useful. Let's see why it is...<br /><!--break--><br /><div style="clear:right;float:right;border:1px solid FireBrick;"><p style="margin:10px;font-size:80%;line-height:120%"><br />Posts in this series:<br /><a title="lightlyLoony/blog/2011/4/13/2067" href="/community?id=community_blog&sys_id=0a3daae5dbd0dbc01dcaf3231f9619b4">A JavaScript Class to be Extended</a><br /><a title="lightlyLoony/blog/2011/4/14/2068" href="/community?id=community_blog&sys_id=7e7ce2e1dbd0dbc01dcaf3231f961916">Extending a Class, Part I...</a><br /><a title="lightlyLoony/blog/2011/4/15/2069" href="/community?id=community_blog&sys_id=fedc2a65dbd0dbc01dcaf3231f9619ad">Extending a Class, Part II...</a><br /><a title="lightlyLoony/blog/2011/4/18/2070" href="/community?id=community_blog&sys_id=08bc2a25dbd0dbc01dcaf3231f961925">Extending a Class, Part III...</a><br /></p></div>The starting point today is <i>GRUtil</i> as I introduced it in <a title="lightlyLoony/blog/2011/4/13/2067" href="/community?id=community_blog&sys_id=0a3daae5dbd0dbc01dcaf3231f9619b4">the first post of this series</a>: with a <i>getTables()</i> method, but without a <i>getChildTables()</i> method. Then we're going to run this code:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />GRUtil.prototype.getChildTables = function(table) {<br />      var om = Packages.com.glide.db.DBObjectManager.get();<br />      var tables = om.getTableExtensions(table);<br />      return j2js(tables);<br />   };<br /><br />var gru = new GRUtil();<br />gs.log(gru.getChildTables('cmdb_ci_server'));<br /></pre><br /><br />What have we done here? If you dissect the first line of code, you see that we're assigning a function to the <i>getChildTables</i> property of the <i>prototype</i> property of the <i>GRUtil</i> object. Why on earth would we do such a crazy-looking thing? To understand why, you need to understand a little bit about how classes and objects work in JavaScript...<br /><br />When JavaScript executes a piece of code like <i>var x = new GRUtil()</i>, here's what actually happens:<br /><ol><li><b>A new object is created</b>: an ordinary, untyped JavaScript object is created, exactly as if the code <i>var x = {}</i> had been executed.</li><li><b>The new object is initialized</b>: the properties of <i>GRUtil.prototype</i> are copied into the new object. In this case there are two such properties: <i>initialize</i> and <i>getTables</i> (which were put here by the <i>GRUtil.prototype = {...}</i> code in the <i>GRUtil</i> script include — plus the property <i>getChildTables</i> we added in the first line of code above. All of these properties happen to contain functions, but they could have been anything at all. When the copy has been completed, the new object has the same three properties.</li><li><b>The new object's constructor function is called</b>: because we've used the <a title="w.prototypejs.org/" href="http://www.prototypejs.org/">prototype.js</a> library to construct our object, the visible effect is that the <i>initialize</i> method is called. Our object's <i>initialize</i> method is empty, so this does nothing. We'll be talking much more about this in later posts.</li></ol><br /><br />Creating a JavaScript objects makes a lot of work for the little nanognomes that run your computer!<br /><br />Ok, that explains how that first line of code above could add the <i>getChildTables</i> method to <i>GRUtil</i>. But what was I babbling about when I mentioned JavaScript contexts?<br /><br />JavaScript contexts are the environment that any particular JavaScript program executes in. Within the Service-now platform, the lifetime of a JavaScript context is generally either one <i>web server request</i> or one <i>scheduled job</i>. For most kinds of scripts that you might write, the former is the important one to understand. Each <i>request</i> is initiated by some action on the web browser. It could be that the user clicked on a button or link to go to a new page, and getting that new page would be one request. It could also be an <a title=".wikipedia.org/wiki/Ajax_%28programming%29" href="http://en.wikipedia.org/wiki/Ajax_%28programming%29">AJAX request</a> from JavaScript on a web page asking the Service-now instance for something; that would also be one request. For the duration of the work that the Service-now instance does to process that request, there is a single JavaScript context.<br /><br />In the code above, we added a new property (<i>getChildTables</i>) to <i>GRUtil.prototype</i>. That modification occurs in memory, in the running program — <i>not</i> in the script include. The lifetime of the in-memory modified version is the same as the lifetime of the JavaScript context. When a new JavaScript context starts up, and <i>GRUtil</i> is referenced, then it is <i>reloaded</i> from the script include — and the modification our code above made would be missing (unless, of course, we re-ran that modifying code in the new JavaScript context).<br /><br />So...do you think our brown-eyed lass is no longer puzzled? Or is she now wondering why she ever got interested in programming in the first place?</p>