---
title: "Regex Accounting Madness"
date: 2011-10-28T19:54:28.000Z
authors: ["SlightlyLoony"]
link: "https://community.servicenow.com/community?id=community_blog&sys_id=91bd6aa9dbd0dbc01dcaf3231f961981"
---
<p><span class="asset-asset_lightbox-Small asset-align-right"><a href="/files/SlightlyLoony/accounting_girl.jpg" rel="lightbox"><img rel="lightbox" src="http://community.service-now.com/files/imagecache/Small/SlightlyLoony/accounting_girl.jpg" alt="" title="" class="imagecache imagecache-Small" /></a></span>Today we're going to take the things you've already learned, and apply them to something a bit more like the real world. Let's say we've imported that old standby, a .csv file (comma-separated values, with optional quoting of strings containing commas or quotes) — a .csv file with a set of line items on an invoice. Our sample data, from the Dweezle-Dwee Government Surplus Store, looks like this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />dat,qty,itm,amt,ext,cur,typ<br />10/14/2011,1,"Meat Cleaver, Sharp",47.8,47.8,dollars,purchase<br />10/12/2011,10,Ballpoint Pen,0.44,4.4,dollars,purchase<br />7/4/2011,3,"Space Shuttle, Used",-500,-1500,dollars,rma<br />8/21/2011,1,"Country, ""Greece""",1,1,euros,purchase<br />9/30/2011,5,"Computer, PC, Obsolete",169.99,849.95,dollars,purchase<br /></pre><br />Your job is to parse that mess into a nice JavaScript object, ready for some code to deal with it. Our accountant (at right) is eagerly anticipating your success...<br /><!--break--><br />Most of this is very straightforward, boring regex stuff. The one challenging bit is the "item" column — it's contents might or might not be quoted. If it <i>is quoted</i>, we don't want those quotes in our result. Here's what we came up with:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var test = 'dat,qty,itm,amt,ext,cur,typ\n';<br />test +=     '10/14/2011,1,"Meat Cleaver, Sharp",47.8,47.8,dollars,purchase\n';<br />test +=     '10/12/2011,10,Ballpoint Pen,0.44,4.4,dollars,purchase\n';<br />test +=     '7/4/2011,3,"Space Shuttle, Used",-500,-1500,dollars,rma\n';<br />test +=     '8/21/2011,1,"Country, ""Greece""",1,1,euros,purchase\n';<br />test +=     '9/30/2011,5,"Computer, PC, Obsolete",169.99,849.95,dollars,purchase\n';<br />var result = parse(test);<br />JSUtil.logObject(result);<br /><br />function parse(csv) {<br />    var parser = /^(\d+)\/(\d+)\/(\d+),(\d+),((?:"(?:(?:""|[^"])+)")|(?:[^,]+)),(-?[\d.]+),(-?[\d.]+),([^,]+),([^,]+?)$/gm;<br />    var result = [];<br />    var x;<br />    while ((x = parser.exec(csv)) != null) {<br />        var item = {};<br />        item.date = x[3] + '/' + x[1] + '/' + x[2];<br />        item.quantity = x[4] - 0;<br />        item.description = x[5].replace(/^"/, '').replace(/"$/, '').replace(/""/g,'"');<br />        item.amount = x[6] - 0;<br />        item.extended = x[7] - 0;<br />        item.currency = x[8];<br />        item.type = x[9];<br />        result.push(item);<br />    }<br />    return result;<br />}</pre><br />When we run this test code, here's the result:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />  Array of 5 elements<br />    [0]: Object<br />      quantity: number = 1<br />      description: string = Meat Cleaver, Sharp<br />      type: string = purchase<br />      amount: number = 47.8<br />      date: string = 2011/10/14<br />      currency: string = dollars<br />      extended: number = 47.8<br />    [1]: Object<br />      quantity: number = 10<br />      description: string = Ballpoint Pen<br />      type: string = purchase<br />      amount: number = 0.44<br />      date: string = 2011/10/12<br />      currency: string = dollars<br />      extended: number = 4.4<br />    [2]: Object<br />      quantity: number = 3<br />      description: string = Space Shuttle, Used<br />      type: string = rma<br />      amount: number = -500<br />      date: string = 2011/7/4<br />      currency: string = dollars<br />      extended: number = -1500<br />    [3]: Object<br />      quantity: number = 1<br />      description: string = Country, "Greece"<br />      type: string = purchase<br />      amount: number = 1<br />      date: string = 2011/8/21<br />      currency: string = euros<br />      extended: number = 1<br />    [4]: Object<br />      quantity: number = 5<br />      description: string = Computer, PC, Obsolete<br />      type: string = purchase<br />      amount: number = 169.99<br />      date: string = 2011/9/30<br />      currency: string = dollars<br />      extended: number = 849.95<br /></pre><br />That JavaScript object is a <i>lot</i> easier than the raw .csv file text for other code to work with.<br /><br />Let's take it one piece at a time...<br /><br />The first thing to note is that the column names don't appear in the result. The reason is very simple: that big ol' regex doesn't match on that line. The regex is looking for dates and numbers that don't appear in the header; no match, no output.<br /><br />Now note that we have two flags after the regex: <i>g</i> (for global), and <i>m</i> for multiline. This time we really <i>need</i> the multiline flag. Our regex starts with a "^" (beginning of line) and ends with a "$" (end of line), and we need those to be interpreted as the beginning and end of a <i>line</i>, not of the entire text.<br /><br />The part of the regex that parses the date looks like this: <span style="font-family=Courier;color:FireBrick;">(\d+)\/(\d+)\/(\d+),</span>. This should be easy for you — we're looking for digits, a slash, digits, a slash, digits, and a comma. The slashes ("/") have to be escaped because the slash character is a metacharacter that brackets the regex literal. If we don't escape it, JavaScript will get very confused and give you hateful error messages when you try to run it. Note that we have three separate capture groups here, one for each group of digits (month, day, year). In the code where we're using the date information, we're reordering it (to year, month, day): <br /><span style="font-family=Courier;color:FireBrick;">item.date = x[3] + '/' + x[1] + '/' + x[2];</span><br /><br />Next comes the bit that parses the quantity: <span style="font-family=Courier;color:FireBrick;">(\d+),</span>. At this point, that should be quite obvious to you!<br /><br />Now we get the tricky bit: the possibly-quoted item description. The piece of the regex that deals with this is: <span style="font-family=Courier;color:FireBrick;">((?:"(?:(?:""|[^"])+)")|(?:[^,]+)),</span>. If you look closely, there are really two separate things going on there, with one or the other working: one for quoted strings (<span style="font-family=Courier;color:FireBrick;">(?:"(?:(?:""|[^"])+)")</span>) and one for unquoted strings (<span style="font-family=Courier;color:FireBrick;">(?:[^,]+)</span>). These two bits are surrounded by <span style="font-family=Courier;color:FireBrick;">(a|b),</span> (where the a and b stand for our two parts), which just says to capture one or the other and look for a comma after it. Regexes try alternatives like this from left to right, so it will first look for the quoted string, then if that fails, it will look for the unquoted string. <br /><br />The quoted string piece is a little tricky all by itself. It's easy to see that it's looking for a beginning and ending quote, but what is that stuff in the middle (<span style="font-family=Courier;color:FireBrick;">(?:(?:""|[^"])+)</span>)? Well, it's looking for one or more of either a pair of quotes or a non-quote character. This little trick lets it match on the doubled quotes that Microsoft used to specify a quote <i>within</i> a quoted string. We don't want those to match as the end-of-string, and this little trick neatly prevents that.<br /><br />The unquoted string piece is easy: it's just looking for a sequence of characters that don't include a comma.<br /><br />In the JavaScript code you'll see this line for dealing with the item description:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />item.description = x[5].replace(/^"/, '').replace(/"$/, '').replace(/""/g,'"');<br /></pre><br />This obscure-looking line first replaces any leading quote with nothing, then any trailing quote with nothing, and finally any double quotes with a single quote. That scrubs the quotes and makes the string look like what we really expect it to be.<br /><br />Next we're looking for the amount and extended amount (quantity times amount). These both use the same regex: <span style="font-family=Courier;color:FireBrick;">(-?[\d.]+),</span>. The only new thing for you here is the <span style="font-family=Courier;color:FireBrick;">-?</span>, which tells the regex to match on either 0 or 1 dashes. This matches the optional minus sign (for a negative number) that might precede the digits. The rest of it just matches any combination of digits and decimal points (periods). Note that inside a character class, the period is not a metacharacter, so we don't need to escape it.<br /><br />The last bits (currency and type) are just looking for an unquoted string. But the very last one (type) has one very slightly tricky bit to it: <span style="font-family=Courier;color:FireBrick;">([^,]+?)</span>. The tricky bit is the question mark near the end. In this case, it's indicating that the quantifier (the plus sign) should be <i>reluctant</i>. Why do we need that here? It actually only matters on the very last line of the input text. In that case, the line is terminated with a newline (the \n). If we didn't have the question mark in there, the last line would match on the <i>end of text</i> instead of the end of line (like all the other lines did), just because with a greedy quantifier, it could. Matching at the end of text would mean that the newline itself would be included in the result, which we don't want. By making that quantifier reluctant, it will stop matching at the newline and won't include it in the result.<br /><br />And our accounting girl is overjoyed...</p>