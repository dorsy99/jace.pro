---
title: "What I Never New"
date: 2011-11-02T18:26:13.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=666d2e29dbd0dbc01dcaf3231f961961"
---
<p><span class="asset-asset_lightbox-Small asset-align-right"><a href="/files/SlightlyLoony/angry_engineer.jpg" rel="lightbox"><img rel="lightbox" src="http://community.service-now.com/files/imagecache/Small/SlightlyLoony/angry_engineer.jpg" alt="" title="" class="imagecache imagecache-Small" /></a></span>A few weeks ago I helped someone troubleshoot an interesting JavaScript code problem. The actual case was fairly complicated, and the error wasn't at all obvious to my (very frustrated) colleague, but here's a simple program that demonstrates the equivalent problem:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />function Person(first, last) {<br />    this.first = first;<br />    this.last = last;<br />    this.count = 0;<br />}<br />Person.prototype.name = function() {<br />    this.count++;<br />    return this.first + ' ' + this.last;<br />}<br /><br />var count = 10;<br />while (count &gt; 0) {<br />    gs.log('Got here');<br />    var p = Person('Slightly', 'Loony');<br />    count--;<br />}<br /></pre><br />You'd expect this to print "Got here" 10 times, but it didn't — it only prints once. Do you see why?<br /><!--break--><br />The problem is in this line:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    var p = Person('Slightly', 'Loony');<br /></pre><br />The programmer forgot to put the <span style="font-family=Courier;color:FireBrick;">new</span> before the <span style="font-family=Courier;color:FireBrick;">Person('Slightly', 'Loony')</span>. Add that, and everything works fine. But why?<br /><br />To understand the reason, you need to know (and remember!) a few things:<br /><ul><li><u><i>Constructors are functions</i></u>. Unlike many other programming languages, JavaScript uses ordinary functions as constructors. It's perfectly allowable to invoke a constructor as if it were a function — for the simple reason that it really <i>is</i> a function. That what our error of leaving out the "new" did — we just invoked it as an ordinary function.</li><li><u><i>Functions have "this" references</i></u>. The "this" reference is what lets functions be methods of object instances. When an instance method (which is really just a function) is invoked, the "this" reference is automatically initialized to the instance we're calling the method on.</li><li><u><i>The "new" keyword does stuff</i></u>. In particular, it creates a new, uninitialized instance of the object we're creating, and it passes a reference to that object as the "this" pointer when invoking the constructor function. This is how the constructor knows what instance to initialize.</li><li><u><i>Functions invoked outside the context of an instance are passed the global object as "this"</i></u>. Normally a function designed to be invoked outside the context of any instance (in other words, functions that aren't methods) wouldn't use the "this" pointer at all. But if they did, they'd find that it was set to the global object.</li></ul><br />Now we can explain what happened in our program. When the erroneous line was run, the <span style="font-family=Courier;color:FireBrick;">Person</span> function was being called outside the context of any instance. Therefore its "this" reference was set to the global object. When the constructor function executed this line:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />    this.count = 0;<br /></pre><br />It set the global variable <span style="font-family=Courier;color:FireBrick;">count</span> to 0. So in this loop:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var count = 10;<br />while (count &gt; 0) {<br />    gs.log('Got here');<br />    var p = Person('Slightly', 'Loony');<br />    count--;<br />}<br /></pre><br />Even though <span style="font-family=Courier;color:FireBrick;">count</span> was set to 10 to start with, when we executed the <span style="font-family=Courier;color:FireBrick;">Person</span> function, it got set to 0. The following <span style="font-family=Courier;color:FireBrick;">count--</span> set it to -1, and then the loop terminated.<br /><br />All that mess because the "new" was accidently left out.<br /><br />Can you protect your JavaScript classes against such an accident. Yes, you can. One thing you can do is this:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />function Person(first, last) {<br />    if (this === JSUtil.getGlobal())<br />        throw new Error('You forgot the "new", you hamburger!');<br />   <br />    this.first = first;<br />    this.last = last;<br />    this.count = 0;<br />}<br /></pre><br />We just added a test to see if the "this" reference was identical to the global object, and if it was, we throw an error. Note that the <span style="font-family=Courier;color:FireBrick;">JSUtil.getGlobal()</span> is specific to the JavaScript environment on a ServiceNow instance; on the client side you would use the <span style="font-family=Courier;color:FireBrick;">window</span> object.<br /><br />So now if someone forgets the "new", they'll get a big old nasty error, but at least you won't get these crazy, hard to troubleshoot side effects. But can we do even better than this? Of course:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />function Person(first, last) {<br />    if (this === JSUtil.getGlobal())<br />        return new Person(first, last);<br />   <br />    this.first = first;<br />    this.last = last;<br />    this.count = 0;<br />}<br /></pre><br />Now if someone leaves out the "new", we supply it for them! This works just fine, and basically has the effect of making the "new" keyword completely optional. Some built-in JavaScript objects work exactly like this. For example, both lines below do the same thing:<br /><pre style="margin-left:20px;line-height:1;color:FireBrick;"><br />var x = new Boolean('true');<br />var y = Boolean('true');<br /></pre><br />This is how JavaScript allows certain constructor functions to be used both for new instance construction and as if they were conversion functions. You can use the same trick in your own classes. Note that there is no requirement for the return value to be of any particular type — we could have returned a number or a string just as well as a Person.<br /><br />Ah, the things we never new!</p>